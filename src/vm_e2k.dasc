|// Low-level VM code for E2K CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2021 Mike Pall. See Copyright Notice in luajit.h
|
|.arch e2k
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|.define RRET1,     r0
|.define RARG1,     r0
|.define RARG2,     r1
|.define RARG3,     r2
|.define RARG4,     r3
|.define RARG5,     r4
|.define RARG6,     r5
|.define RARG7,     r6
|.define RARG8,     r7
|
|.define CRET1,     b0
|.define CRET2,     b1
|.define CRET3,     b2
|.define CRET4,     b3
|.define CRET5,     b4
|.define CRET6,     b5
|.define CRET7,     b6
|.define CRET8,     b7
|.define CARG1,     b0
|.define CARG2,     b1
|.define CARG3,     b2
|.define CARG4,     b3
|.define CARG5,     b4
|.define CARG6,     b5
|.define CARG7,     b6
|.define CARG8,     b7
|
|.define BASE,      r4
|.define KBASE,     r5
|.define STACK,     r6
|.define PC,        r7
|.define DISPATCH,  r8
|
|.define TMP0,      r9
|.define TMP1,      r10
|
|.define RA,        r11
|.define RB,        r12
|.define RC,        r13
|.define RD,        r14
|.define ITYPE,     r15
|
|.macro do_fault
| addd 0, 0x0, 0x0, RARG1
| ldd 0, RARG1, 0x0, RARG1
|.endmacro
|
|// Type definitions. Some of these are only used for documentation.
|.type L,           lua_State
|.type GL,          global_State
|.type TVALUE,      TValue
|.type GCOBJ,       GCobj
|.type STR,         GCstr
|.type TAB,         GCtab
|.type LFUNC,       GCfuncL
|.type CFUNC,       GCfuncC
|.type PROTO,       GCproto
|.type UPVAL,       GCupval
|.type NODE,        Node
|.type NARGS,       int
|.type TRACE,       GCtrace
|.type SBUF,        SBuf
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|//-----------------------------------------------------------------------
|.define CFRAME_SPACE,  0x30                // 8*6
|.define STACK_SPACE,   0xffffffd0          // -(8*6)
|.define MULTRES,       0x0
|.define SAVE_NRES,     0x8
|.define SAVE_ERRF,     0xc
|.define SAVE_L,        0x10
|.define SAVE_PC,       0x18
|.define SAVE_CFRAME,   0x20
|.define STACK_TMP,     0x28
|
|//-----------------------------------------------------------------------
|// Instruction decode+dispatch.
|.macro ins_NEXT             // AD = {D |A|OP}, ABC = {B|C|A|OP}, AC = {lo_D|A|OP}
|<
| ldw 0, PC, 0x0, TMP0
| ldb 2, PC, 0x0, TMP1
| addd 1, PC, 0x4, PC
| nop 2
|>
|<
| shld 2, TMP1, 0x3, TMP1
| shrd 3, TMP0, 0xd, RD
| shrd 4, TMP0, 0x15, RB
| shrd 5, TMP0, 0x5, RA
|>
|<
| ldd 2, TMP1, DISPATCH, TMP1
| andd 3, RD, 0x7fff8, RD
| andd 4, RA, 0x7f8, RA
| nop 2
|>
|<
| movtd 0, TMP1, ctpr1
| andd 3, RB, 0x7f8, RB
| andd 4, RD, 0x7f8, RC
|>
| ct ctpr1
|.endmacro
|
|// Instruction footer.
|.if 1
| // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
| .define ins_next, ins_NEXT
| .define ins_next_, ins_NEXT
|.else
| // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
| // Affects only certain kinds of benchmarks (and only with -j off).
| // Around 10%-30% slower on Core2, a lot more slower on P4.
| .macro ins_next
|   disp ctpr1, ->ins_next
| .endmacro
| .macro ins_next_
| ->ins_next:
|   ins_NEXT
| .endmacro
|.endif
| 
|// Call decode and dispatch.
|.macro ins_callt
| // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, [BASE-8] = PC
|<
| ldd 3, RB, LFUNC->pc, PC
| nop 2
|>
|<
| ldw 3, PC, 0x0, RA
| ldb 5, PC, 0x0, TMP0
| nop 2
|>
|<
| shld 0, TMP0, 0x3, TMP0                   // jmp to [DISPATCH+OP*8]
| addd 1, PC, 0x4, PC
| shrd 3, RA, 0x5, RA
|>
|<
| ldd 0, TMP0, DISPATCH, TMP0
| andd 3, RA, 0x7f8, RA
| nop 2
|>
| movtd 0, TMP0, ctpr1
| ct ctpr1
|.endmacro
|
|.macro ins_call
| // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, PC = caller PC
| std 5, BASE, 0xfffffff8, PC
| ins_callt
|.endmacro
|
|//-----------------------------------------------------------------------
|.define PC_OP, 0xfffffffc                  // Byte
|.define PC_RA, 0xfffffffd                  // Byte
|.define PC_RB, 0xffffffff                  // Byte
|.define PC_RC, 0xfffffffe                  // Byte
|.define PC_RD, 0xfffffffe                  // Halfword
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)      (GG_DISP2G + (int)offsetof(global_State, field))
#define PC2PROTO(field)         ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|//-----------------------------------------------------------------------

/* Generate subroutines used by opcodes and other parts of the VM */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
    |.code_sub
    |
    |//-----------------------------------------------------------------------
    |//-- Return handling ----------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_returnp:
    | disp ctpr1, ->cont_dispatch
    |<
    | cmpandesb 0, PC, FRAME_P, pred0
    | nop 2
    |>
    |<
    | ct ctpr1, pred0
    | andd 3, PC, 0xfffffff8, PC, ~pred0
    | subd 4, RA, 0x8, RA, ~pred0
    |>
    |
    | // Return from pcall or xpcall fast func
    |<
    | subd 3, BASE, PC, BASE                // Restore caller base.
    | addd 4, RA, PC, RA                    // Rebase RA and prepend one result.
    | addd 5, 0x0, U64x(0xfffeffff,0xffffffff), ITYPE
    |>
    | ldd 3, BASE, 0xfffffff8, PC           // Fetch PC of previous frame.
    | // Prepending may overwrite the pcall frame, so do it at the end.
    | std 5, BASE, RA, ITYPE                // Prepend true to results.
    |
    |->vm_returnc:
    |<
    | addd 0, 0x0, LUA_YIELD, RRET1
    | addd 3, RD, 0x8, RD                   // RD = (nresults+1)*8
    | disp ctpr1, ->vm_unwind_c_eh
    |>
    |<
    | cmpandedb 0, PC, FRAME_TYPE, pred1
    | cmpedb 3, RD, 0x0, pred0
    | disp ctpr2, ->BC_RET_Z
    |>
    |<
    | stw 2, STACK, MULTRES, RD, ~pred0
    | ct ctpr1, pred0
    |>
    | ct ctpr2, pred1                       // Handle regular return to Lua.
    |
    |->vm_return:
    | // BASE = base, RA = resultofs, RD/MULTRES = (nresults+1)*8, PC = return
    |<
    | xord 1, PC, FRAME_C, PC
    | subd 2, 0x0, 0x8, TMP1
    | addd 3, RA, 0x0, CARG4
    | subd 4, RD, 0x8, CARG3
    | ldd 5, STACK, SAVE_L, RB
    | disp ctpr1, ->vm_returnp
    |>
    |<
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | andd 1, PC, TMP1, TMP1
    | addd 2, 0x0, ~LJ_VMST_C, TMP0
    | cmpedb 3, CARG3, 0x0, pred1
    | disp ctpr2, >2
    |>
    |<
    | ldw 0, STACK, SAVE_NRES, RA, pred0
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), TMP0, pred0
    | subd 3, TMP1, BASE, PC, pred0
    | ct ctpr1, ~pred0
    |>
    | return ctpr3
    |<
    | ldw 0, STACK, MULTRES, RD
    | subd 3, 0x0, PC, PC                   // Previous base = BASE - delta
    | disp ctpr1, >1
    |>
    |<
    | shld 0, RA, 0x3, RA                   // RA = wanted (nresults+1)*8
    | std 5, RB, L->base, PC
    | ct ctpr2, pred1
    |>
    |1:                                     // Move results down.
    |<
    | ldd 3, BASE, CARG4, TMP1
    | subd 4, CARG3, 0x8, CARG3
    | nop 1
    |>
    | cmpedb 4, CARG3, 0x0, pred0
    |<
    | addd 3, BASE, 0x8, BASE
    | std 5, BASE, 0xfffffff0, TMP1
    | ct ctpr1, ~pred0
    |>
    |2:
    | disp ctpr1, >4
    | cmpesb 0, RA, RD, pred0
    | ct ctpr1, ~pred0                      // More/less results wanted?
    |3:
    |<
    | addd 2, 0x0, 0x0, RRET1               // Ok return status for vm_pcall.
    | ldd 3, STACK, SAVE_CFRAME, TMP0       // Restore previous C frame.
    | subd 4, BASE, 0x10, BASE
    | nop 1
    |>
    | std 5, RB, L->top, BASE
    |<
    | std 5, RB, L->cframe, TMP0
    | ct ctpr3
    |>
    |4:
    |<
    | ldd 3, RB, L->maxstack, TMP0
    | addd 4, 0x0, LJ_TNIL, TMP1
    | disp ctpr1, >5
    | nop 1
    |>
    |<
    | cmpbsb 0, RA, RD, pred0
    | disp ctpr2, >6
    |>
    |<
    | cmpbedb 3, BASE, TMP0, pred1
    | nop 1
    |>
    | ct ctpr1, pred0                       // Less results wanted?
    | disp ctpr1, <4
    |<
    | subd 3, BASE, 0x10, TMP0, pred1
    | ct ctpr2, ~pred1                      // Need to grow stack?
    |>
    |<
    | addd 3, BASE, 0x8, BASE
    | adds 4, RD, 0x8, RD
    | std 5, TMP0, 0x0, TMP1                // Check stack size and fill up results with nil.
    | return ctpr3
    |>
    |<
    | cmpesb 0, RA, RD, pred0
    | nop 1
    |>
    |<
    | ldd 3, STACK, SAVE_CFRAME, TMP0, pred0 // Restore previous C frame.
    | subd 4, BASE, 0x10, BASE, pred0
    | ct ctpr1, ~pred0                      // More/less results wanted?
    |>
    |<
    | addd 0, 0x0, 0x0, RRET1               // Ok return status for vm_pcall.
    | std 5, RB, L->top, BASE
    | nop 1
    |>
    |<
    | std 5, RB, L->cframe, TMP0
    | ct ctpr3
    |>
    |5:                                     // Less results wanted.
    | disp ctpr1, <3
    | cmpesb 0, RA, 0x0, pred0
    |<
    | subd 0, RA, RD, RA, ~pred0            // Negative result!
    | ct ctpr1, pred0
    |>
    |<
    | addd 0, BASE, RA, BASE                // Correct top.
    | ct ctpr1
    |>
    |
    |6:
    | // Corner case: need to grow stack for filling up results.
    | // This can happen if:
    | // - A C function grows the stack (a lot).
    | // - The GC shrinks the stack in between.
    | // - A return back from a lua_call() with (high) nresults adjustment.
    |
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    |<
    | adds 0, RA, 0x0, CARG2
    | addd 1, RB, 0x0, CARG1
    | stw 2, STACK, MULTRES, RD
    | std 5, RB, L->top, BASE               // Save current top held in BASE (yes).
    |>
    | call ctpr1, wbs = 0x8
    |<
    | ldw 0, STACK, MULTRES, RD
    | ldw 2, STACK, SAVE_NRES, RA
    | ldd 3, RB, L->top, BASE               // Need the (realloced) L->top in BASE
    | disp ctpr1, <4
    | nop 2
    |>
    |<
    | shld 0, RA, 0x3, RA
    | ldd 2, STACK, SAVE_CFRAME, TMP0       // Restore previous C frame.
    | return ctpr3
    |>
    | cmpesb 0, RA, RD, pred0
    |<
    | addd 0, 0x0, 0x0, RRET1, pred0        // Ok return status for vm_pcall.
    | subd 3, BASE, 0x10, BASE, pred0
    | ct ctpr1, ~pred0                      // More/less results wanted?
    |>
    |<
    | std 2, RB, L->cframe, TMP0
    | std 5, RB, L->top, BASE
    | ct ctpr3
    |>
    |
    |->vm_unwind_c:                         // Unwind C stack, return from vm_pcall.
    | // (void *cframe, int errcode)
    |<
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | addd 0, RARG1, 0x0, STACK
    | addd 1, RARG2, 0x0, RRET1             // Error return status for vm_pcall.
    |>
    |->vm_unwind_c_eh:                      // Landing pad for external unwinder.
    |<
    | ldd 0, STACK, SAVE_L, RB
    | return ctpr3
    | nop 2
    |>
    |<
    | ldd 0, RB, L->glref, RB
    | addd 1, 0x0, ~LJ_VMST_C, TMP0
    | nop 2
    |>
    |<
    | stw 2, RB, GL->vmstate, TMP0
    | ct ctpr3
    |>
    |
    |->vm_unwind_ff:                        // Unwind C stack, return from ff pcall.
    | // (void *cframe)
    |<
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | andd 0, RARG1, CFRAME_RAWMASK, RARG1
    |>
    | addd 0, RARG1, 0x0, STACK
    |->vm_unwind_ff_eh:                     //  Landing pad for external unwinder.
    |<
    | ldd 0, STACK, SAVE_L, RB
    | addd 3, 0x0, (1+1)*8, RD              // Really 1+2 results, incr. later.
    | disp ctpr1, ->vm_returnc
    |>
    |<
    | addd 0, 0x0, ~LJ_VMST_INTERP, TMP0
    | addd 3, 0x0, U64x(0xffff7fff,0xffffffff), RA
    | nop 1
    |>
    |<
    | ldd 0, RB, L->glref, DISPATCH         // Setup pointer to dispatch table.
    | ldd 2, RB, L->base, BASE
    | nop 2
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC           // Fetch PC of previous frame.
    | addd 1, DISPATCH, GG_G2DISP, DISPATCH
    | ldd 3, BASE, 0x0, RB
    | nop 2
    |>
    |<
    | std 2, BASE, 0xfffffff8, RB
    | std 5, BASE, 0xfffffff0, RA           // Prepend false to error message.
    |>
    |<
    | subd 3, 0x0, 0x10, RA                 // Results start at BASE+RA = BASE-16.
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), TMP0
    | ct ctpr1                              // Increments RD/MULTRES and returns.
    |>
    |
    |//-----------------------------------------------------------------------
    |//-- Grow stack for calls -----------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_growstack_c:                      // Grow stack for C function.
    | // RB = L, L->base = new base, L->top = top 
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    |<
    | addd 0, 0x0, LUA_MINSTACK, CARG2
    | addd 1, RB, 0x0, CARG1
    | nop 3
    |>
    | call ctpr1, wbs = 0x8
    |<
    | ldd 3, RB, L->base, BASE
    | ldd 5, RB, L->top, RD
    | nop 2
    |>
    |<
    | ldd 3, BASE, 0xfffffff0, RB
    | subd 4, RD, BASE, RD
    | nop 2
    |>
    |<
    | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
    | addd 4, RD, 0x8, RD
    |>
    | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8
    | ins_callt                             // Just retry the call
    |
    |->vm_growstack_v:                      // Grow stack for vararg Lua function.
    |<
    | ldb 0, PC, PC2PROTO(framesize)-4, RA
    | addd 1, PC, 0x4, PC                   // Must point after first instruction.
    | subd 3, RD, 0x10, RD                  // LJ_FR2
    |>
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    |<
    | std 2, STACK, SAVE_PC, PC
    | std 5, RB, L->base, BASE
    |>
    |<
    | addd 0, RA, 0x0, CARG2
    | addd 3, RB, 0x0, CARG1
    | std 5, RB, L->top, RD
    | call ctpr1, wbs = 0x8
    |>
    | // RB = L, L->base = new base, L->top = top 
    |<
    | ldd 3, RB, L->base, BASE
    | ldd 5, RB, L->top, RD
    | nop 2
    |>
    |<
    | ldd 3, BASE, 0xfffffff0, RB
    | subd 4, RD, BASE, RD
    | nop 2
    |>
    |<
    | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
    | addd 4, RD, 0x8, RD
    |>
    | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8
    | ins_callt                             // Just retry the call
    |
    |->vm_growstack_f:                      // Grow stack for fixarg Lua function.
    | // BASE = new base, RD = (nargs+1)*8, RB = L, PC = first PC
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    |<
    | ldb 0, PC, PC2PROTO(framesize)-4, RA
    | addd 1, PC, 0x4, PC                   // Must point after first instruction.
    | addd 3, BASE, RD, RD
    | nop 1
    |>
    |<
    | std 2, STACK, SAVE_PC, PC
    | subd 3, RD, 0x8, RD
    | std 5, RB, L->base, BASE
    |>
    |<
    | addd 0, RA, 0x0, CARG2
    | addd 3, RB, 0x0, CARG1
    | std 5, RB, L->top, RD
    |>
    | call ctpr1, wbs = 0x8
    | // RB = L, L->base = new base, L->top = top 
    |<
    | ldd 3, RB, L->base, BASE
    | ldd 5, RB, L->top, RD
    | nop 2
    |>
    |<
    | ldd 3, BASE, 0xfffffff0, RB
    | subd 4, RD, BASE, RD
    | nop 2
    |>
    |<
    | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
    | addd 4, RD, 0x8, RD
    |>
    | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8
    | ins_callt                             // Just retry the call
    |
    |//-----------------------------------------------------------------------
    |//-- Entry points into the assembler VM ---------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_resume:                           // Setup C frame and resume thread.
    | // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
    |<
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | disp ctpr1, >2
    |>
    |<
    | getsp 0, STACK_SPACE, STACK
    | addd 1, RARG1, 0x0, RB
    |>
    |<
    | addd 0, 0x0, 0x0, RD
    | addd 1, 0x0, FRAME_CP, PC
    | ldd 2, RB, L->glref, DISPATCH         // Setup pointer to dispatch table.
    |>
    |<
    | addd 1, RARG2, 0x0, RA
    | ldb 3, RB, L->status, TMP0
    | addd 4, STACK, CFRAME_RESUME, KBASE
    |>
    |<
    | std 2, STACK, SAVE_CFRAME, RD
    | stw 5, STACK, SAVE_NRES, RD
    |>
    |<
    | stw 2, STACK, SAVE_ERRF, RD
    | std 5, RB, L->cframe, KBASE
    |>
    |<
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | std 2, STACK, SAVE_PC, RD             // Any value outside of bytecode is ok.
    | cmpedb 3, TMP0, 0x0, pred0
    | nop 2
    |>
    |<
    | std 2, STACK, SAVE_L, RARG1
    | ct ctpr1, pred0                       // Initial resume (like a call).
    |>
    | 
    | // Resume after yield (like a return).
    |<
    | ldd 3, RB, L->base, BASE
    | ldd 5, RB, L->top, TMP1
    | disp ctpr2, ->BC_RET_Z
    |>
    |<
    | addd 1, 0x0, ~LJ_VMST_INTERP, TMP0
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    | disp ctpr1, ->vm_return
    |>
    |<
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), TMP0
    | stb 5, RB, L->status, RD
    |>
    |<
    | ldd 3, BASE, 0xfffffff8, PC
    | subd 4, TMP1, RA, RD
    | subd 5, RA, BASE, RA                  // RA = resultofs
    |>
    | addd 3, RD, 0x8, RD                   // RD = (nresults+1)*8
    | stw 2, STACK, MULTRES, RD
    |<
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | nop 2
    |>
    | ct ctpr2, pred0
    | ct ctpr1
    |
    |->vm_pcall:                            // Setup protected C frame and enter VM.
    | // (lua_State *L, TValue *base, int news1, ptrdiff_t ef)
    |<
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | disp ctpr1, >1
    |>
    |<
    | getsp 0, STACK_SPACE, STACK
    | addd 1, 0x0, FRAME_CP, PC
    | nop 1
    |>
    |<
    | stw 2, STACK, SAVE_ERRF, RARG4
    | ct ctpr1
    |>
    |
    |->vm_call:                             // Setup C frame and enter VM.
    | // (lua_State *L, TValue *base, int nres1)
    |<
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    |>
    |<
    | getsp 0, STACK_SPACE, STACK
    | addd 1, 0x0, FRAME_C, PC
    |>
    |
    |1: // Entry point for vm_pcall above (PC = ftype)
    |<
    | std 2, STACK, SAVE_L, RARG1
    | addd 3, RARG2, 0x0, RA
    | addd 4, RARG1, 0x0, RB
    | stw 5, STACK, SAVE_NRES, RARG3
    |>
    |<
    | ldd 0, RB, L->glref, DISPATCH            // Setup pointer to dispatch table.
    | ldd 3, RB, L->cframe, KBASE              // Add our C frame to cframe chain.
    | nop 3
    |>
    |<
    | std 2, STACK, SAVE_CFRAME, KBASE
    | std 5, STACK, SAVE_PC, RB                // Any value outsize of bytecode is ok.
    |>
    |<
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | std 2, RB, L->cframe, STACK
    |>
    |
    |2: // Entry point for vm_resume/vm_cpcall (RA = base, RB = L, PC = ftype)
    |<
    | addd 0, PC, RA, PC
    | addd 1, 0x0, ~LJ_VMST_INTERP, TMP0
    | ldd 3, RB, L->base, BASE              // BASE = old base (used in vmeta_call).
    | ldd 5, RB, L->top, RD
    | disp ctpr1,  ->vmeta_call
    |>
    |<
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    |>
    |<
    | ldd 0, RA, 0xfffffff0, RB             // RB = LFUNC
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), TMP0
    | nop 1
    |>
    |<
    | subd 0, PC, BASE, PC                  // PC = frame delta + frame type
    | addd 3, RA, 0x0, CARG2
    |>
    |<
    | sard 0, RB, 0x2f, ITYPE
    | andd 1, RB, U64x(0x00007fff,0xffffffff), RB
    | subd 3, RD, CARG2, RD
    |>
    |<
    | lddsm 0, RB, LFUNC->pc, CARG1
    | cmpesb 1, ITYPE, LJ_TFUNC, pred0
    | addd 3, RD, 0x8, RD                   // RD = (nargs+1)*8
    | nop 1
    |>
    |<
    | addd 3, CARG2, 0x0, BASE, pred0       // BASE = new base
    | ct ctpr1, ~pred0
    |>
    |<
    | ldb 2, CARG1, 0x0, TMP1
    | ldw 3, CARG1, 0x0, RA
    | nop 2
    |>
    |<
    | shld 0, TMP1, 0x3, TMP1               // jmp to [DISPATCH+OP*8]
    | std 2, BASE, 0xfffffff8, PC           // [BASE-8] = PC
    |>
    |<
    | ldd 0, TMP1, DISPATCH, TMP1
    | addd 1, CARG1, 0x4, PC
    | shrd 3, RA, 0x5, RA
    | nop 2
    |>
    |<
    | movtd 0, TMP1, ctpr1
    | andd 3, RA, 0x7f8, RA
    |>
    | ct ctpr1
    |
    |->vm_cpcall:                           // Setup protected C frame, call C.
    | // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
    |<
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    |>
    |<
    | getsp 0, STACK_SPACE, STACK
    | addd 1, RARG1, 0x0, RB
    | ldd 2, RARG1, L->top, TMP1
    |>
    |<
    | ldd 0, RB, L->stack, TMP0
    | ldd 2, RB, L->glref, DISPATCH         // Setup pointer to dispatch table.
    | nop 1
    |>
    |<
    | movtd 0, RARG4, ctpr1
    | std 2, STACK, SAVE_L, RB
    |>
    |<
    | subd 0, TMP0, TMP1, TMP0
    | addd 1, 0x0, 0x0, TMP1
    | std 2, STACK, SAVE_PC, RB
    |>
    |<
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | stw 2, STACK, SAVE_ERRF, TMP1         // No error function.
    |>
    |<
    | ldd 0, RB, L->cframe, TMP0
    | stw 2, STACK, SAVE_NRES, TMP0         // Neg. delta means cframe w/o frame.
    |>
    |<
    | addd 0, RARG1, 0x0, CARG1
    | std 2, STACK, SAVE_CFRAME, TMP0
    |>
    |<
    | addd 0, RARG2, 0x0, CARG2
    | std 2, RB, L->cframe, STACK
    |>
    |<
    | addd 0, RARG3, 0x0, CARG3
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    | call ctpr1, wbs = 0x8                 // (lua_State *L, lua_CFunction func, void *ud)
    |>
    | // TValue * (new base) or NULL returned.
    | lddsm 0, STACK, SAVE_CFRAME, TMP0     // Restore previous C frame.
    | disp ctpr1, <2
    | nop 1
    |<
    | cmpedb 1, CRET1, 0x0, pred0
    | return ctpr3
    |>
    |<
    | addd 0, 0x0, 0x0, RRET1, pred0        // Ok return status for vm_pcall.
    | std 2, RB, L->cframe, TMP0, pred0
    |>
    | ct ctpr3, pred0
    |<
    | addd 0, CRET1, 0x0, RA
    | addd 1, 0x0, FRAME_CP, PC
    | ct ctpr1                              // Else continue with the call.
    |>
    |
    |//-----------------------------------------------------------------------
    |//-- Metamethod handling ------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |//-- Continuation dispatch ----------------------------------------------
    |
    |->cont_dispatch:
    | // BASE = meta base, RA = resultofs, RD = (nresults+1)*8 (also in MULTRES)
    |<
    | andd 2, PC, 0xfffffff8, PC
    | addd 3, BASE, RA, RA
    | addd 4, BASE, 0x0, RB
    | addd 5, 0x0, LJ_TNIL, TMP0
    | disp ctpr2, >1
    |>
    |<
    | subd 3, BASE, PC, BASE                // Restore caller BASE.
    | addd 4, RA, RD, TMP1
    | addd 5, RA, 0x0, CRET1
    | disp ctpr1, ->cont_ffi_callback
    |>
    |<
    | ldd 0, RB, 0xffffffe8, PC             // Restore PC from [cont|PC].
    | ldd 2, RB, 0xffffffe0, RA
    | disp ctpr3, ->vm_call_tail
    |>
    | lddsm 3, BASE, 0xfffffff0, CARG2
    |<
    | cmpbedb 0, RA, 0x1, pred0
    | cmpedb 1, RA, 0x1, pred1
    | std 5, TMP1, 0xfffffff8, TMP0         // Ensure one valid arg.
    | nop 2
    |>
    |.if FFI
    | ct ctpr2, pred0
    |.endif
    |<
    | movtd 0, RA, ctpr1
    | andd 3, CARG2, U64x(0x00007fff,0xffffffff), KBASE
    |>
    |<
    | ldd 3, KBASE, LFUNC->pc, KBASE
    | nop 2
    |>
    |<
    | ldd 3, KBASE, PC2PROTO(k), KBASE
    | nop 1
    |>
    | ct ctpr1                              // Jump to continuation.
    | // BASE = base, CRET1 = result, RB = meta base
    |
    |.if FFI
    |1:
    |<
    | subd 0, RB, BASE, RB, ~pred1
    | ct ctpr1, pred1                       // cont = 1: return from FFI callback.
    |>
    | // cont = 0: Tail call from C function.
    |<
    | subd 0, RB, 0x18, RD
    | ct ctpr3
    |>
    |.endif
    |
    |->cont_cat:                            // BASE = base, CRET1 = result, RB = mbase
    |<
    | ldb 0, PC, PC_RB, CARG3
    | lddsm 2, CRET1, 0x0, TMP0
    | subd 3, RB, 0x20, RB
    | disp ctpr1, ->cont_ra
    | nop 2
    |>
    |<
    | shld 3, CARG3, 0x3, CARG3
    | disp ctpr2, ->BC_CAT_Z
    |>
    | addd 3, BASE, CARG3, CARG3
    | subd 3, CARG3, RB, CARG3
    |<
    | cmpedb 3, CARG3, 0x0, pred0
    | nop 2
    |>
    |<
    | ldd 0, STACK, SAVE_L, CARG1, ~pred0
    | subd 1, 0x0, CARG3, CARG3
    | ct ctpr1, pred0
    |>
    |<
    | shrd 0, CARG3, 0x3, CARG3
    | addd 1, RB, 0x0, CARG2
    | std 2, RB, 0x0, TMP0
    | nop 1
    |>
    |<
    | std 2, CARG1, L->base, BASE
    | ct ctpr2
    |>
    |
    |//-- Table indexing metamethods -----------------------------------------
    |
    |->cont_nop:                            // BASE = base, (CRET1 = result)
    | ins_next
    |
    |->vmeta_tgets:
    |<
    | ldbsm 0, PC, PC_RB, CARG1               // Reload TValue *t from RB.
    | disp ctpr1, >1
    |>
    |<
    | addd 0, 0x0, LJ_TSTR, ITYPE
    | ldb 2, PC, PC_OP, TMP1
    |>
    |<
    | shld 0, ITYPE, 0x2f, ITYPE
    | addd 1, DISPATCH, DISPATCH_GL(tmptv), TMP0 // Store GStr * in g->tmptv
    | addd 2, DISPATCH, DISPATCH_GL(tmptv2), CARG2 // Store fn->l.env in g->tmptv2.
    |>
    |<
    | ord 0, RC, ITYPE, RC                  // RC = GCstr *
    | addd 1, 0x0, LJ_TTAB, RA
    | shldsm 2, CARG1, 0x3, CARG1
    |>
    |<
    | cmpedb 0, TMP1, BC_GGET, pred0
    | shld 1, RA, 0x2f, RA
    | std 2, TMP0, 0x0, RC
    |>
    |<
    | addd 0, TMP0, 0x0, RC
    | ord 1, RA, RB, RA                     // RB = GCtab * ?
    |>
    |<
    | addd 0, BASE, CARG1, RB, ~pred0
    | addd 1, CARG2, 0x0, RB, pred0
    | std 2, CARG2, 0x0, RA, pred0
    | ct ctpr1
    |>
    |
    |->vmeta_tgetb:
    |<
    | ldb 0, PC, PC_RC, TMP1
    | ldb 2, PC, PC_RB, RB                  // Reload TValue *t from RB.
    | disp ctpr1, >1
    | nop 2
    |>
    |<
    | istofd 0, TMP1, TMP0
    | addd 1, DISPATCH, DISPATCH_GL(tmptv), RC
    | shld 2, RB, 0x3, RB
    |>
    |<
    | addd 0, BASE, RB, RB
    | std 2, RC, 0x0, TMP0
    | ct ctpr1
    |>
    |
    |->vmeta_tgetv:
    |<
    | ldb 0, PC, PC_RC, RC                  // Reload TValue *k from RC.
    | ldb 2, PC, PC_RB, RB                  // Reload TValue *t from RB.
    | nop 2
    |>
    |<
    | shld 0, RC, 0x3, RC
    | shld 1, RB, 0x3, RB
    |>
    |<
    | addd 0, BASE, RC, RC
    | addd 1, BASE, RB, RB
    |>
    |1:
    | disp ctpr1, extern lj_meta_tget       // (lua_State *L, TValue *o, TValue *k)
    |<
    | ldd 0, STACK, SAVE_L, CARG1
    | addd 1, RB, 0x0, CARG2
    | addd 2, RC, 0x0, CARG3
    | nop 2
    |>
    |<
    | std 2, CARG1, L->base, BASE
    | addd 3, CARG1, 0x0, RB
    |>
    |<
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    | // TValue * (finished) or NULL (metamethod) returned.
    |<
    | cmpedb 0, CRET1, 0x0, pred0
    | ldd 3, RB, L->base, BASE
    | disp ctpr3, >2
    | nop 4
    |>
    | ct ctpr3, pred0
    |
    |->cont_ra:                             // BASE = base, CRET1 = result
    |<
    | ldw 0, PC, 0x0, TMP0
    | ldb 2, PC, 0x0, TMP1
    | nop 1
    |>
    | ldb 0, PC, PC_RA, CARG3
    |<
    | ldd 0, CRET1, 0x0, CARG2
    | shld 2, TMP1, 0x3, TMP1
    | shrd 3, TMP0, 0xd, RD
    | shrd 4, TMP0, 0x15, RB
    | shrd 5, TMP0, 0x5, RA
    |>
    |<
    | shld 0, CARG3, 0x3, CARG3
    | addd 1, PC, 0x4, PC
    | ldd 2, TMP1, DISPATCH, TMP1
    | andd 3, RD, 0x7fff8, RD
    | andd 4, RA, 0x7f8, RA
    | nop 2
    |>
    |<
    | movtd 0, TMP1, ctpr1
    | andd 3, RB, 0x7f8, RB
    | andd 4, RD, 0x7f8, RC
    |>
    |<
    | std 2, BASE, CARG3, CARG2
    | ct ctpr1
    |>
    |
    |2:                                     // Call __index metamethod. 
    | // BASE = base, L->top = new base, stack = cont/func/t/k
    |<
    | ldd 3, RB, L->top, RA
    | nop 2
    |>
    |<
    | addd 4, RA, FRAME_CONT, PC
    | std 5, RA, 0xffffffe8, PC             // [RA-24] cont|PC
    |>
    |<
    | subd 2, PC, BASE, PC
    | ldd 3, RA, 0xfffffff0, RB             // [RA-16] Guaranteed to be a function here.
    | addd 4, 0x0, (2+1)*8, RD              // (2+1)*8 args for func(t, k)
    | nop 2
    |>
    |<
    | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
    | addd 4, RA, 0x0, BASE
    |>
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |
    |->vmeta_tgetr:
    | disp ctpr1, extern lj_tab_getinth     // // (GCtab *t, int32_t key)
    |<
    | addd 0, RB, 0x0, CARG1
    | adds 1, RC, 0x0, CARG2
    | nop 3
    |>
    | call ctpr1, wbs = 0x8
    | // cTValue * or NULL returned.
    |<
    | ldw 0, PC, 0x0, TMP0
    | ldb 2, PC, 0x0, TMP1
    |>
    |<
    | ldb 0, PC, PC_RA, RA
    | cmpedb 1, CRET1, 0x0, pred0
    | lddsm 2, CRET1, 0x0, ITYPE
    | nop 1
    |>
    |<
    | shld 2, TMP1, 0x3, TMP1
    |>
    |<
    | ldd 0, TMP1, DISPATCH, TMP1
    | addd 2, 0x0, LJ_TNIL, ITYPE, pred0
    | shld 3, RA, 0x3, RA
    |>
    |<
    | addd 1, PC, 0x4, PC
    | std 2, BASE, RA, ITYPE
    | shrd 3, TMP0, 0xd, RD
    | shrd 4, TMP0, 0x15, RB
    | shrd 5, TMP0, 0x5, RA
    |>
    |<
    | andd 3, RD, 0x7fff8, RD
    | andd 4, RA, 0x7f8, RA
    |>
    |<
    | movtd 0, TMP1, ctpr1
    | andd 3, RB, 0x7f8, RB
    | andd 4, RD, 0x7f8, RC
    |>
    | ct ctpr1
    |
    |//-----------------------------------------------------------------------
    |
    |->vmeta_tsets:
    |<
    | ldb 0, PC, PC_OP, TMP0
    | addd 1, 0x0, LJ_TSTR, ITYPE
    | ldbsm 2, PC, PC_RB, CARG1             // Reload TValue *t from RB.
    | addd 3, 0x0, LJ_TTAB, CARG2
    | disp ctpr1, >1
    |>
    |<
    | shld 0, ITYPE, 0x2f, ITYPE
    | shld 1, CARG2, 0x2f, CARG2
    |>
    |<
    | ord 0, RC, ITYPE, TMP1                // STR:RC = GCstr *
    | addd 1, STACK, STACK_TMP, CARG3
    |>
    |<
    | cmpedb 0, TMP0, BC_GSET, pred0
    | shld 1, CARG1, 0x3, CARG1
    | std 2, STACK, STACK_TMP, TMP1
    | nop 2
    |>
    |<
    | addd 0, BASE, CARG1, CARG2, ~pred0
    | ord 1, CARG2, RB, RA, pred0           // RB = GCtab *
    | addd 2, DISPATCH, DISPATCH_GL(tmptv), CARG2, pred0 // Store fn->l.env in g->tmptv
    |>
    |<
    | std 2, RB, 0x0, RA, pred0
    | ct ctpr1
    |>
    |
    |->vmeta_tsetb:
    |<
    | ldb 0, PC, PC_RC, TMP0
    | ldb 2, PC, PC_RB, RB                     // Reload TValue *t from RB.
    | disp ctpr1, >1
    | nop 2
    |>
    |<
    | istofd 0, TMP0, TMP0
    | shld 1, RB, 0x3, RB
    | nop 1
    |>
    |<
    | addd 0, STACK, STACK_TMP, CARG3
    | addd 1, BASE, RB, CARG2
    | std 2, STACK, STACK_TMP, TMP0
    | ct ctpr1
    |>
    |
    |->vmeta_tsetv:
    |<
    | ldb 0, PC, PC_RC, RC                  // Reload TValue *k from RC.
    | ldb 2, PC, PC_RB, RB                  // Reload TValue *t from RB.
    | nop 2
    |>
    |<
    | shld 0, RC, 0x3, RC
    | shld 1, RB, 0x3, RB
    |>
    |<
    | addd 0, BASE, RC, CARG3
    | addd 1, BASE, RB, CARG2
    |>
    |1:
    | disp ctpr1, extern lj_meta_tset      // (lua_State *L, TValue *o, TValue *k)
    |<
    | ldd 0, STACK, SAVE_L, CARG1
    | nop 2
    |>
    | std 2, STACK, SAVE_PC, PC
    |<
    | std 2, CARG1, L->base, BASE
    | addd 0, CARG1, 0x0, RB
    | call ctpr1, wbs = 0x8
    |>
    | // TValue * (finished) or NULL (metamethod) returned.
    |<
    | cmpedb 0, CRET1, 0x0, pred0
    | disp ctpr1, >2
    | nop 4
    |>
    |<
    | ldd 3, RB, L->base, BASE
    | ct ctpr1, pred0
    |>
    | // NOBARRIER: lj_meta_tset ensures the table is not black.
    |<
    | ldw 0, PC, 0x0, TMP0
    | ldb 2, PC, 0x0, TMP1
    |>
    |<
    | ldb 0, PC, PC_RA, CARG2
    | nop 2
    |>
    |<
    | shld 0, CARG2, 0x3, CARG2
    | addd 1, PC, 0x4, PC
    | shld 2, TMP1, 0x3, TMP1
    | shrd 3, TMP0, 0xd, RD
    | shrd 4, TMP0, 0x15, RB
    | shrd 5, TMP0, 0x5, RA
    |>
    |<
    | ldd 0, BASE, CARG2, CARG3
    | ldd 2, TMP1, DISPATCH, TMP1
    | nop 2
    |>
    |<
    | movtd 0, TMP1, ctpr1
    | andd 3, RD, 0x7fff8, RD
    | andd 4, RA, 0x7f8, RA
    |>
    |<
    | std 2, CRET1, 0x0, CARG3
    | andd 3, RB, 0x7f8, RB
    | andd 4, RD, 0x7f8, RC
    | ct ctpr1
    |>
    |
    |2: // Call __newindex metamethod
    | // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
    | // Copy value to third argument.
    |<
    | ldd 0, RB, L->top, RA
    | ldb 2, PC, PC_RA, RC
    | nop 2
    |>
    |<
    | std 2, RA, 0xffffffe8, PC             // [cont|PC]
    | shld 3, RC, 0x3, RC
    |>
    |<
    | addd 0, RA, FRAME_CONT, PC
    | ldd 3, BASE, RC, RB
    | nop 2
    |>
    |<
    | subd 0, PC, BASE, PC
    | std 2, RA, 0x10, RB
    |>
    |<
    | ldd 3, RA, 0xfffffff0, RB             // Guaranteed to be a function here.
    | addd 4, 0x0, (3+1)*8, RD              // 3 args for func (t, k, v)
    | nop 3
    |>
    |<
    | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
    | addd 4, RA, 0x0, BASE
    |>
    | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, PC = caller PC
    |<
    | ldd 0, RB, LFUNC->pc, PC
    | addd 1, PC, 0x0, TMP1
    | nop 2
    |>
    |<
    | ldw 0, PC, 0x0, RA
    | nop 2
    |>
    |<
    | andd 0, RA, 0xff, TMP0
    | addd 1, PC, 0x4, PC
    | std 5, BASE, 0xfffffff8, TMP1
    |>
    | shld 0, TMP0, 0x3, TMP0               // jmp to [DISPATCH+OP*8]
    |<
    | ldd 0, TMP0, DISPATCH, TMP0
    | shrd 3, RA, 0x5, RA
    | nop 2
    |>
    |<
    | movtd 0, TMP0, ctpr1
    | andd 3, RA, 0x7f8, RA
    |>
    | ct ctpr1
    |
    |->vmeta_tsetr:
    | disp ctpr1, extern lj_tab_setinth     // (lua_State *L, GCtab *t, int32_t key)
    |<
    | ldd 0, STACK, SAVE_L, CARG1
    | addd 1, RB, 0x0, CARG2
    | nop 1
    |>
    |<
    | std 2, STACK, SAVE_PC, PC
    | adds 0, RC, 0x0, CARG3
    | nop 1
    |>
    |<
    | std 2, CARG1, L->base, BASE
    | call ctpr1, wbs = 0x8
    |>
    | // TValue * returned.
    |<
    | ldw 0, PC, 0x0, TMP0
    | addd 1, PC, 0x4, PC
    | ldb 2, PC, 0x0, TMP1
    | ldb 3, PC, PC_RA, CARG2
    | nop 3
    |>
    |<
    | shld 1, CARG2, 0x3, CARG2
    | shld 2, TMP1, 0x3, TMP1
    | shrd 3, TMP0, 0xd, RD
    | shrd 4, TMP0, 0x15, RB
    | shrd 5, TMP0, 0x5, RA
    |>
    |<
    | ldd 0, BASE, CARG2, ITYPE
    | ldd 2, TMP1, DISPATCH, TMP1
    | andd 3, RD, 0x7fff8, RD
    | andd 4, RA, 0x7f8, RA
    | nop 2
    |>
    |<
    | movtd 0, TMP1, ctpr1
    | std 2, CRET1, 0x0, ITYPE
    | andd 3, RB, 0x7f8, RB
    | andd 4, RD, 0x7f8, RC
    |>
    | ct ctpr1
    |
    |//-- Comparison metamethods ---------------------------------------------
    |
    |->vmeta_comp:
    | disp ctpr1, extern lj_meta_comp       // (lua_State *L, TValue *o1, *o2, int op)
    |<
    | ldh 0, PC, PC_RD, RD
    | addd 1, PC, 0x4, TMP0
    | ldb 2, PC, PC_RA, RA
    |>
    |<
    | ldd 0, STACK, SAVE_L, RB
    | subd 1, TMP0, BCBIAS_J*4, TMP1
    | ldb 2, PC, PC_OP, CARG4
    |>
    | ldh 0, TMP0, PC_RD, TMP0
    |<
    | shld 0, RD, 0x3, RD
    | shld 1, RA, 0x3, RA
    | addd 2, RB, 0x0, CARG1
    |>
    |<
    | addd 0, BASE, RA, CARG2
    | addd 1, BASE, RD, CARG3
    | std 2, RB, L->base, BASE
    |>
    |<
    | shld 0, TMP0, 0x2, TMP0
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    | // 0/1 or TValue * (metamethod) returned.
    |<
    | cmpbedb 0, CRET1, 0x1, pred0
    | cmpbdb 1, CRET1, 0x1, pred1
    | ldd 3, RB, L->base, BASE
    | disp ctpr2, ->vmeta_binop
    | nop 4
    |>
    |<
    | addd 0, PC, 0x4, PC, pred0
    | ct ctpr2, ~pred0
    |>
    | addd 0, TMP1, TMP0, PC, ~pred1
    | ins_next
    |
    |->cont_condt:
    | // BASE = base, CRET1 = result
    |<
    | ldd 0, CRET1, 0x0, ITYPE
    | addd 1, PC, 0x4, PC
    |>
    |<
    | ldh 0, PC, PC_RD, TMP0
    | subd 1, PC, BCBIAS_J*4, TMP1
    | nop 1
    |>
    | sard 0, ITYPE, 0x2f, ITYPE
    |<
    | cmpbsb 0, ITYPE, LJ_TISTRUECOND, pred0
    | shld 1, TMP0, 0x2, TMP0
    | nop 1
    |>
    | addd 0, TMP1, TMP0, PC, pred0         // Branch if result is true.
    | ins_next
    |
    |->cont_condf:                          // BASE = base, CRET1 = result
    |<
    | ldd 0, CRET1, 0x0, ITYPE
    | addd 1, PC, 0x4, PC
    |>
    |<
    | ldh 0, PC, PC_RD, TMP0
    | subd 1, PC, BCBIAS_J*4, TMP1
    | nop 1
    |>
    | sard 0, ITYPE, 0x2f, ITYPE
    |<
    | cmpbsb 0, ITYPE, LJ_TISTRUECOND, pred0
    | shld 1, TMP0, 0x2, TMP0
    | nop 1
    |>
    | addd 0, TMP1, TMP0, PC, ~pred0        // Branch if result is false.
    | ins_next
    |
    |->vmeta_equal:
    | disp ctpr1, extern lj_meta_equal      // (lua_State *L, GCobj *o1, *o2, int ne)
    |<
    | ldd 0, STACK, SAVE_L, RB
    | addd 1, RB, 0x0, CARG4
    | subd 2, PC, 0x4, PC
    | andd 3, RD, U64x(0x00007fff,0xffffffff), RD
    |>
    |<
    | ldh 0, PC, PC_RD, TMP0
    | subd 1, PC, BCBIAS_J*4, TMP1
    | nop 1
    |>
    |<
    | addd 0, RA, 0x0, CARG2
    | addd 1, RB, 0x0, CARG1
    | std 2, RB, L->base, BASE
    |>
    |<
    | addd 0, RD, 0x0, CARG3
    | shld 1, TMP0, 0x2, TMP0
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    | // 0/1 or TValue * (metamethod) returned.
    |<
    | cmpbedb 0, CRET1, 0x1, pred0
    | cmpbdb 1, CRET1, 0x1, pred1
    | addd 2, TMP1, 0x4, TMP1
    | ldd 3, RB, L->base, BASE
    | disp ctpr2, ->vmeta_binop
    | nop 4
    |>
    |<
    | addd 0, PC, 0x4, PC, pred0
    | ct ctpr2, ~pred0
    |>
    | addd 0, TMP1, TMP0, PC, ~pred1
    | ins_next
    |
    |->vmeta_equal_cd:
    |.if FFI
    | disp ctpr1, extern lj_meta_equal_cd   // (lua_State *L, BCIns ins)
    |<
    | ldd 0, STACK, SAVE_L, RB
    | subd 1, PC, 0x4, PC
    |>
    |<
    | ldw 0, PC, 0xfffffffc, CARG2
    | ldh 2, PC, PC_RD, TMP0
    | nop 1
    |>
    |<
    | subd 0, PC, BCBIAS_J*4, TMP1
    | addd 1, RB, 0x0, CARG1
    | std 2, RB, L->base, BASE
    |>
    |<
    | addd 0, TMP1, 0x4, TMP1
    | shld 1, TMP0, 0x2, TMP0
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    | // 0/1 or TValue * (metamethod) returned.
    |<
    | cmpbedb 0, CRET1, 0x1, pred0
    | cmpbdb 1, CRET1, 0x1, pred1
    | ldd 3, RB, L->base, BASE
    | disp ctpr2, ->vmeta_binop
    | nop 4
    |>
    |<
    | addd 0, PC, 0x4, PC, pred0
    | ct ctpr2, ~pred0
    |>
    | addd 0, TMP1, TMP0, PC, ~pred1
    | ins_next
    |.endif
    |
    |->vmeta_istype:
    | disp ctpr1, extern lj_meta_istype     // (lua_State *L, BCReg ra, BCReg tp)
    |<
    | ldd 0, STACK, SAVE_L, RB
    | nop 2
    |>
    |<
    | std 2, RB, L->base, BASE
    | shrd 0, RD, 0x3, CARG3
    | shrd 1, RA, 0x3, CARG2
    |>
    |<
    | addd 1, RB, 0x0, CARG1
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    | ldd 3, RB, L->base, BASE
    | ins_next
    |
    |//-- Arithmetic metamethods ---------------------------------------------
    |
    |.macro vmeta_arith_base
    | disp ctpr1, extern lj_meta_arith      // (lua_State *L, TValue *ra, *rb, *rc, BCReg op)
    |<
    | ldb 0, PC, PC_OP, CARG5
    | addd 1, RA, 0x0, CARG2
    | ldd 2, STACK, SAVE_L, CARG1
    | nop 2
    |>
    |<
    | addd 0, RC, 0x0, CARG4
    | addd 1, RB, 0x0, CARG3
    | std 2, CARG1, L->base, BASE
    |>
    |<
    | addd 0, CARG1, 0x0, RB
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    | // NULL (finished) or TValue * (metamethod) returned.
    |<
    | ldd 3, RB, L->base, BASE
    | cmpedb 4, CRET1, 0x0, pred0
    | disp ctpr2, ->cont_nop
    |>
    |<
    | disp ctpr1, ->vmeta_binop
    | nop 3
    |>
    | ct ctpr2, pred0
    | ct ctpr1
    |.endmacro
    |
    |->vmeta_arith_vn:
    |<
    | addd 3, KBASE, RC, RC
    | addd 4, BASE, RB, RB
    | addd 5, BASE, RA, RA
    |>
    | vmeta_arith_base
    |
    |->vmeta_arith_nv:
    |<
    | addd 3, KBASE, RC, RB
    | addd 4, BASE, RB, RC
    | addd 5, BASE, RA, RA
    |>
    | vmeta_arith_base
    |
    |->vmeta_unm:
    |<
    | addd 3, BASE, RD, RC
    | addd 4, BASE, RD, RB
    | addd 5, BASE, RA, RA
    |>
    | vmeta_arith_base
    |
    |->vmeta_arith_vv:
    |<
    | addd 3, BASE, RC, RC
    | addd 4, BASE, RB, RB
    | addd 5, BASE, RA, RA
    |>
    | vmeta_arith_base
    |
    | // Call metamethod for binary op.
    |->vmeta_binop:
    | // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
    |<
    | addd 0, CRET1, 0x0, RA
    | subd 1, CRET1, BASE, CRET1
    |>
    |<
    | addd 1, CRET1, FRAME_CONT, PC
    | std 2, RA, 0xffffffe8, PC             // [cont|PC]
    | addd 3, 0x0, (2+1)*8, RD              // 2 args for func(o1, o2).
    |>
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    |<
    | ldd 0, RA, 0xfffffff0, RB
    | disp ctpr1, ->vmeta_call
    | nop 2
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
    |>
    |<
    | cmpesb 3, ITYPE, LJ_TFUNC, pred0
    | nop 2
    |>
    |<
    | addd 3, RA, 0x0, BASE, pred0
    | ct ctpr1, ~pred0
    |>
    | ins_call
    |
    |->vmeta_len:
    | disp ctpr1, extern lj_meta_len        // (lua_State *L, TValue *o)
    |<
    | ldh 0, PC, PC_RD, RD
    | ldd 2, STACK, SAVE_L, RB
    | nop 2
    |>
    |<
    | shld 3, RD, 0x3, RD
    | std 5, RB, L->base, BASE
    |>
    |<
    | std 2, STACK, SAVE_PC, PC
    | addd 3, BASE, RD, CARG2
    | addd 4, RB, 0x0, CARG1
    | call ctpr1, wbs = 0x8
    |>
    | // NULL (retry) or TValue * (metamethod) returned.
    |<
    | ldd 3, RB, L->base, BASE
    | disp ctpr2, ->vmeta_binop             // Binop call for compatibility.
    | nop 4
    |>
#if LJ_52
    |<
    | cmpedb 0, CRET1, 0x0, pred0
    | ldd 3, BASE, RD, CARG1
    | disp ctpr1, ->BC_LEN_Z
    | nop 2
    |>
    | ct ctpr2, ~pred0
    |<
    | andd 0, CARG1, U64x(0x00007fff,0xffffffff), CARG1
    | ct ctpr1
    |>
#else
    | ct ctpr2
#endif
    |
    |//-- Call metamethod ----------------------------------------------------
    |
    |->vmeta_call:                          // Resolve and call __call metamethod.
    | // BASE = old base, RA = new base, RD = (nargs+1)*8
    | disp ctpr1, extern lj_meta_call       // (lua_State *L, TValue *func, TValue *top)
    |<
    | ldd 0, STACK, SAVE_L, CARG1
    | subd 1, RA, 0x10, CARG2
    | addd 2, RA, RD, CARG3
    | nop 2
    |>
    |<
    | subd 1, CARG3, 0x8, CARG3
    | std 2, CARG1, L->base, BASE
    |>
    |<
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    |<
    | ldd 0, STACK, SAVE_L, TMP0
    | ldd 2, RA, 0xfffffff0, RB
    | disp ctpr2, ->BC_CALLT_Z
    | nop 2
    |>
    |<
    | ldd 3, TMP0, L->base, BASE
    | addd 4, RD, 0x8, RD
    | nop 2
    |>
    | // This is fragile. L->base must not move, KBASE must always be defined.
    |<
    | cmpedb 3, KBASE, BASE, pred0
    | nop 2
    |>
    |<
    | andd 3, RB, U64x(0x00007fff,0xffffffff), RB, ~pred0
    | addd 4, RA, 0x0, BASE, ~pred0
    | ct ctpr2, pred0                       // Continue with CALLT if flag set.
    |>
    | ins_call                              // Otherwise call resolved metamethod.
    |
    |//-- Argument coercion for 'for' statement ------------------------------
    |
    |->vmeta_for:
    | disp ctpr1, extern lj_meta_for        // (lua_State *L, TValue *base)
    |<
    | ldd 0, STACK, SAVE_L, RB
    | addd 1, RA, 0x0, CARG2
    | ldwsm 2, PC, 0xfffffffc, TMP0
    | nop 2
    |>
    |<
    | andd 0, TMP0, 0xff, TMP1
    | addd 1, RB, 0x0, CARG1
    | std 2, RB, L->base, BASE
    | shrd 3, TMP0, 0x5, RA
    |>
    |<
    | shld 1, TMP1, 0x3, TMP1
    | std 2, STACK, SAVE_PC, PC
    | andd 3, RA, 0x7f8, RA
    | call ctpr1, wbs = 0x8
    |>
    | addd 0, DISPATCH, TMP1, TMP1
    |<
    | ldd 0, TMP1, GG_DISP2STATIC, TMP1
    | ldd 3, RB, L->base, BASE
    | nop 2
    |>
    | movtd 0, TMP1, ctpr1
    | ct ctpr1
    |
    |//-----------------------------------------------------------------------
    |//-- Fast functions -----------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |// Inlined GC threshold check.
    |.macro ffgccheck
    |<
    | ldd 0, DISPATCH, DISPATCH_GL(gc.total), TMP1
    | ldd 2, DISPATCH, DISPATCH_GL(gc.threshold), TMP0
    | disp ctpr2, >1
    |>
    | ldd 0, STACK, SAVE_L, CARG1
    | disp ctpr1, extern lj_gc_step         // (lua_State *L)
    |<
    | cmpbdb 0, TMP1, TMP0, pred0
    | disp ctpr3, ->fff_fallback
    | nop 2
    |>
    |<
    | ct ctpr2, pred0
    | std 2, STACK, SAVE_PC, PC, ~pred0
    | addd 3, BASE, RD, RD, ~pred0
    | addd 4, CARG1, 0x0, RB, ~pred0
    |>
    |<
    | std 2, CARG1, L->base, BASE
    | subd 3, RD, 0x8, RD
    |>
    |<
    | std 2, CARG1, L->top, RD
    | call ctpr1, wbs = 0x8
    |>
    |<
    | ldd 3, RB, L->base, BASE
    | ldd 5, RB, L->top, RD
    | disp ctpr3, ->fff_fallback
    | nop 2
    |>
    | subd 3, RD, BASE, RD
    | addd 3, RD, 0x8, RD
    |1:
    |.endmacro
    |
    |//-- Base library: checks -----------------------------------------------
    |
    |->ff_assert:
    |<
    | ldd 3, BASE, 0x0, ITYPE
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | addd 3, ITYPE, 0x0, RB
    | sard 4, ITYPE, 0x2f, ITYPE
    | disp ctpr2, ->fff_res
    |>
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISTRUECOND, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | ct ctpr1, ~pred0
    |>
    |<
    | stw 2, STACK, MULTRES, RD
    | subd 4, RD, 0x10, RD
    | std 5, BASE, 0xfffffff0, RB
    |>
    |<
    | cmpedb 3, RD, 0x0, pred0
    | disp ctpr1, >1
    | nop 2
    |>
    |<
    | addd 3, RD, 0x10, RD, pred0
    | addd 4, BASE, 0x8, RA
    | ct ctpr2, pred0
    |>
    |1:
    |<
    | ldd 3, RA, 0x0, RB
    | subd 4, RD, 0x8, RD
    |>
    |<
    | cmpedb 3, RD, 0x0, pred0
    | nop 2
    |>
    |<
    | addd 4, RA, 0x8, RA, ~pred0
    | std 5, RA, 0xfffffff0, RB
    | ct ctpr1, ~pred0
    |>
    |<
    | ldw 0, STACK, MULTRES, RD
    | ct ctpr2
    | nop 2
    |>
    |
    |->ff_type:
    |<
    | ldd 3, BASE, 0x0, RC
    | adds 4, 0x0, LJ_TISNUM, RB
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | sard 3, RC, 0x2f, RC
    | cmpbdb 4, RD, (1+1)*8, pred0
    |>
    |<
    | cmpbsb 4, RC, RB, pred1
    | nop 1
    |>
    |<
    | xors 3, RB, 0xffffffff, RC, pred1
    | xors 4, RC, 0xffffffff, RC, ~pred1
    | ct ctpr1, pred0
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | ldd 3, BASE, 0xfffffff0, RB
    | shls 4, RC, 0x3, RC
    | disp ctpr2, ->fff_res
    | nop 2
    |>
    |<
    | sxt 3, 0x6, RC, RC
    | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
    | addd 5, 0x0, LJ_TSTR, ITYPE
    |>
    |<
    | addd 3, RB, RC, TMP0
    | shld 4, ITYPE, 0x2f, ITYPE
    |>
    |<
    | ldd 3, TMP0, ((char *)(&((GCfuncC *)0)->upvalue)), RC
    | nop 2
    |>
    | ord 3, RC, ITYPE, RC
    |<
    | addd 4, 0x0, (1+1)*8, RD
    | std 5, BASE, 0xfffffff0, RC
    | ct ctpr2
    |>
    |
    |//-- Base library: getters and setters ---------------------------------
    |
    |->ff_getmetatable:
    |<
    | ldd 3, BASE, 0x0, RB
    | disp ctpr1, ->fff_fallback
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | cmpbdb 3, RD, (1+1)*8, pred0
    | disp ctpr2, >1
    | nop 1
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
    |>
    |<
    | cmpesb 3, ITYPE, LJ_TTAB, pred1
    | cmpesb 4, ITYPE, LJ_TUDATA, pred2
    | ct ctpr1, pred0
    |>
    | // Field metatable must be at same offset for GCtab and GCudata!
    |<
    | lddsm 3, RB, TAB->metatable, RB
    | cmpbesb 4, ITYPE, LJ_TISNUM, pred3
    | disp ctpr1, ->fff_res
    | nop 1
    |>
    |<
    | addd 3, 0x0, LJ_TISNUM, ITYPE, pred3
    | addd 4, 0x0, LJ_TTAB, RC
    | pass pred1, p0
    | pass pred2, p1
    | landp ~p0, ~p1, p4
    | pass p4, pred0
    |>
    |<
    | shld 3, RC, 0x2f, RC
    | xord 4, ITYPE, U64x(0xffffffff,0xffffffff), ITYPE
    | ct ctpr2, ~pred0
    |>
    | shld 0, ITYPE, 0x3, TMP0
    | addd 0, TMP0, DISPATCH_GL(gcroot[GCROOT_BASEMT]), TMP0
    |<
    | ldd 0, DISPATCH, TMP0, RB
    | nop 2
    |>
    |1:
    |<
    | lddsm 0, DISPATCH, DISPATCH_GL(gcroot)+8*(GCROOT_MMNAME+MM_metatable), TMP1
    | cmpedb 3, RB, 0x0, pred0
    | addd 4, 0x0, LJ_TNIL, TMP0
    | ord 5, RC, RB, RC
    |>
    |<
    | ldwsm 3, RB, TAB->hmask, RA
    | lddsm 5, RB, TAB->node, CARG1
    |>
    |<
    | addd 0, 0x0, LJ_TSTR, ITYPE
    | std 5, BASE, 0xfffffff0, RC, ~pred0   // Store metatable as default result.
    |>
    |<
    | shld 0, ITYPE, 0x2f, ITYPE
    | addd 4, 0x0, (1+1)*8, RD
    | std 5, BASE, 0xfffffff0, TMP0, pred0
    | ct ctpr1, pred0
    |>
    |<
    | ldw 0, TMP1, STR->sid, TMP0
    | nop 2
    |>
    |<
    | andd 0, RA, TMP0, RA
    | ord 1, TMP1, ITYPE, TMP1
    | disp ctpr2, >3
    |>
    |<
    | smulx 0, RA, #NODE, RA
    | nop 5
    |>
    | addd 0, RA, CARG1, RA
    |2: // Rearranged logic, because we expect _not_ to find the key.
    |<
    | ldd 0, RA, NODE->key, TMP0
    | disp ctpr3, <2
    | nop 2
    |>
    |<
    | cmpedb 0, TMP0, TMP1, pred0
    | nop 2
    |>
    |<
    | ldd 0, RA, NODE->next, RA, ~pred0
    | ct ctpr2, pred0
    | nop 2
    |>
    |<
    | cmpedb 0, RA, 0x0, pred0
    | nop 2
    |>
    | ct ctpr3, ~pred0
    |<
    | addd 3, 0x0, (1+1)*8, RD
    | ct ctpr1                              // Not found, keep default result.
    |>
    |3:
    |<
    | ldd 0, RA, NODE->val, RB
    | addd 3, 0x0, (1+1)*8, RD
    | nop 2
    |>
    |<
    | cmpedb 0, RB, LJ_TNIL, pred0
    | nop 1
    |>
    |<
    | std 5, BASE, 0xfffffff0, RB, ~pred0   // Return value of mt.__metatable.
    | ct ctpr1
    |>
    |
    |->ff_setmetatable:
    |<
    | ldd 3, BASE, 0x0, RB
    | disp ctpr1, ->fff_fallback
    |>
    |<
    | ldd 0, BASE, 0x8, RA
    | nop 1
    |>
    |<
    | addd 3, RB, 0x0, TMP1
    | sard 4, RB, 0x2f, ITYPE
    | andd 5, RB, U64x(0x00007fff,0xffffffff), RB
    |>
    |<
    | cmpbdb 3, RD, (2+1)*8, pred0
    | cmpesb 4, ITYPE, LJ_TTAB, pred1
    | lddsm 5, RB, TAB->metatable, TMP0
    |>
    |<
    | sard 3, RA, 0x2f, ITYPE
    | andd 4, RA, U64x(0x00007fff,0xffffffff), RA
    |>
    |<
    | cmpesb 0, ITYPE, LJ_TTAB, pred2
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | cmpedbsm 3, TMP0, 0x0, pred1
    | ct ctpr1, ~pred0
    | nop 1
    |>
    |<
    | pass pred1, p0
    | pass pred2, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC, pred0
    | lddsm 2, DISPATCH, DISPATCH_GL(gc.grayagain), CARG1
    | ldbsm 3, RB, TAB->marked, TMP0
    | ct ctpr1, ~pred0
    |>
    | // Fast path: no mt for table yet and not clearing the mt.
    |<
    | std 2, RB, TAB->metatable, RA
    | std 5, BASE, 0xfffffff0, TMP1            // Return original table.
    | disp ctpr1, ->fff_res
    | nop 1
    |>
    |<
    | cmpandedb 3, TMP0, LJ_GC_BLACK, pred0    // isblack(table)
    | andd 4, TMP0, ~LJ_GC_BLACK, TMP0         // black2gray(tab)
    | nop 2
    |>
    |<
    | addd 3, 0x0, (1+1)*8, RD, pred0
    | stb 5, RB, TAB->marked, TMP0, ~pred0
    | ct ctpr1, pred0
    |>
    | // Possible write barrier. Table is black, but skip iswhite(mt) check.
    |<
    | std 2, DISPATCH, DISPATCH_GL(gc.grayagain), RB
    | std 5, RB, TAB->gclist, CARG1
    | ct ctpr1
    |>
    |
    |->ff_rawget:
    |<
    | ldd 2, STACK, SAVE_L, CARG1
    | ldd 3, BASE, 0x0, CARG2
    | disp ctpr2, ->fff_fallback
    | nop 1
    |>
    | disp ctpr1, extern lj_tab_get         // (lua_State *L, GCtab *t, cTValue *key)
    |<
    | sard 3, CARG2, 0x2f, ITYPE
    | andd 4, CARG2, U64x(0x00007fff,0xffffffff), CARG2
    |>
    |<
    | cmpbdb 3, RD, (2+1)*8, pred0
    | cmpesb 4, ITYPE, LJ_TTAB, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr2, ~pred0
    |<
    | addd 3, BASE, 0x8, CARG3
    | call ctpr1, wbs = 0x8
    |>
    | // cTValue * returned.
    |<
    | ldd 0, CRET1, 0x0, RB
    | ldd 2, BASE, 0xfffffff8, PC
    | disp ctpr2, ->fff_res
    | nop 4
    |>
    |<
    | addd 4, 0x0, (1+1)*8, RD
    | std 5, BASE, 0xfffffff0, RB
    | ct ctpr2
    |>
    |
    |//-- Base library: conversions ------------------------------------------
    |
    |->ff_tonumber:
    | // Only handles the number case inline (without a base argument).
    |<
    | ldd 3, BASE, 0x0, RB
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | disp ctpr2, ->fff_res
    |>
    |<
    | cmpedb 3, RD, (1+1)*8, pred0          // Exactly one argument.
    | cmpbesb 4, ITYPE, LJ_TISNUM, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC, pred0
    | ct ctpr1, ~pred0
    |>
    |<
    | addd 4, 0x0, (1+1)*8, RD
    | std 5, BASE, 0xfffffff0, RB
    | ct ctpr2
    |>
    |
    |->ff_tostring:
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | ldd 2, DISPATCH, DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM]), TMP0
    | ldd 3, BASE, 0x0, RB
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | cmpedb 3, TMP0, 0x0, pred3
    | cmpbdb 4, RD, (1+1)*8, pred0
    | sard 5, RB, 0x2f, ITYPE
    | disp ctpr2, ->fff_res
    |>
    |<
    | cmpesb 3, ITYPE, LJ_TSTR, pred1
    | cmpbesb 4, ITYPE, LJ_TISNUM, pred2
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred2, p1
    | pass pred3, p2
    | landp ~p0, p1, p4
    | landp p4, p2, p5
    | pass p5, pred0
    |>
    |<
    | addd 3, 0x0, (1+1)*8, RD, ~pred2
    | ct ctpr1, ~pred0
    |>
    | // Only handles the string or number case inline.
    | // A __tostring method in the string base metatable is ignored.
    |<
    | addd 4, 0x0, (1+1)*8, RD, pred1
    | std 5, BASE, 0xfffffff0, RB, pred1
    | ct ctpr2, pred1
    |>
    | // Handle numbers inline, unless a number base metatable is present.
    | ffgccheck
    | disp ctpr1, extern lj_strfmt_num      // (lua_State *L, lua_Number *np)
    |<
    | ldd 3, STACK, SAVE_L, RB
    | nop 3
    |>
    |<
    | addd 1, BASE, 0x0, CARG2
    | std 2, STACK, SAVE_PC, PC             // Redundant (but a defined value).
    | addd 3, RB, 0x0, CARG1
    | std 5, RB, L->base, BASE              // Add frame since C call can throw.
    | call ctpr1, wbs = 0x8
    |>
    | // GCstr returned.
    |<
    | addd 2, 0x0, LJ_TSTR, TMP1
    | ldd 3, RB, L->base, BASE
    | disp ctpr2, ->fff_res
    |>
    | shld 0, TMP1, 0x2f, TMP1
    | ord 0, TMP1, CRET1, TMP1
    | std 2, BASE, 0xfffffff0, TMP1
    | addd 3, 0x0, (1+1)*8, RD
    | ct ctpr2
    |
    |//-- Base library: iterators -------------------------------------------
    |
    |->ff_next:
    |<
    | lddsm 2, STACK, SAVE_L, RB
    | lddsm 3, BASE, 0x0, CARG2
    | disp ctpr2, ->fff_fallback
    |>
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpedb 4, RD, (1+1)*8, pred1          // Missing 2nd arg?
    | nop 1
    |>
    |<
    | sardsm 3, CARG2, 0x2f, ITYPE
    | anddsm 4, CARG2, U64x(0x00007fff,0xffffffff), CARG2
    |>
    |<
    | addd 0, 0x0, LJ_TNIL, TMP0
    | cmpesbsm 3, ITYPE, LJ_TTAB, pred2
    |>
    | disp ctpr1, extern lj_tab_next        // (lua_State *L, GCtab *t, TValue *key)
    |<
    | std 5, BASE, 0x8, TMP0, pred1         // Set missing 2nd arg to nil
    | pass pred0, p0
    | pass pred2, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC, pred0
    | ct ctpr2, ~pred0
    |>
    |<
    | std 2, RB, L->base, BASE
    | std 5, RB, L->top, BASE
    | nop 1
    |>
    |<
    | addd 0, BASE, 0x8, CARG3
    | addd 1, RB, 0x0, CARG1
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    | // Flag returned.
    |<
    | cmpedb 0, CRET1, 0x0, pred0
    | ldd 3, RB, L->base, BASE
    | lddsm 5, BASE, 0x8, TMP1
    | disp ctpr2, ->fff_res
    |>
    |<
    | lddsm 0, BASE, 0x10, CARG2
    | addd 1, 0x0, LJ_TNIL, TMP0
    | nop 3
    |>
    |<
    | addd 4, 0x0, (1+1)*8, RD, pred0
    | std 5, BASE, 0xfffffff0, TMP0, pred0  // End of traversal: return nil.
    | ct ctpr2, pred0
    |>
    | // Copy key and value to results.
    |<
    | std 2, BASE, 0xfffffff0, TMP1
    | addd 4, 0x0, (1+2)*8, RD
    | std 5, BASE, 0xfffffff8, CARG2
    | ct ctpr2
    |>
    |
    |->ff_pairs:
    |<
    | ldd 3, BASE, 0x0, RB
    | lddsm 5, BASE, 0xfffffff0, CARG1
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | addd 3, RB, 0x0, TMP1
    | sard 4, RB, 0x2f, ITYPE
    | andd 5, RB, U64x(0x00007fff,0xffffffff), RB
    |>
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpesb 4, ITYPE, LJ_TTAB, pred1
    | lddsm 5, RB, TAB->metatable, TMP0
    |>
    |<
    | addd 3, 0x0, LJ_TFUNC, ITYPE
    | anddsm 4, CARG1, U64x(0x00007fff,0xffffffff), CARG1
    | disp ctpr2, ->fff_res
    |>
    |<
    | lddsm 3, CARG1, CFUNC->upvalue[0], CARG2
    | shld 4, ITYPE, 0x2f, ITYPE
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr1, ~pred0
#if LJ_52
    |<
    | cmpedb 3, TMP0, 0x0, pred0
    | nop 2
    |>
    | ct ctpr1, ~pred0
#endif
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | addd 1, 0x0, LJ_TNIL, TMP0
    | ord 3, CARG2, ITYPE, CARG2
    |>
    |<
    | std 2, BASE, 0xfffffff0, CARG2
    | std 5, BASE, 0xfffffff8, TMP1
    |>
    |<
    | addd 4, 0x0, (1+3)*8, RD
    | std 5, BASE, 0x0, TMP0
    | ct ctpr2
    |>
    |
    |->ff_ipairs_aux:
    |<
    | lddsm 3, BASE, 0x0, RB
    | cmpbdb 4, RD, (2+1)*8, pred0
    | ldd 5, BASE, 0x8, TMP0
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | sard 3, TMP0, 0x2f, TMP1
    | faddd 4, TMP0, U64x(0x3ff00000,0x00000000), TMP0   // +1.0e0
    | disp ctpr2, >1
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
    | ct ctpr1, pred0
    |>
    |<
    | cmpesb 3, ITYPE, LJ_TTAB, pred0
    | cmpbsb 4, TMP1, LJ_TISNUM, pred1
    | ldw 5, RB, TAB->asize, CARG3
    | disp ctpr3, ->fff_res
    | nop 1
    |>
    |<
    | ldwsm 3, RB, TAB->hmask, CARG4
    | pass pred0, p0
    | pass pred1, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | ldd 3, BASE, 0xfffffff8, PC, pred0
    | ct ctpr1, ~pred0
    |>
    |<
    | lddsm 3, RB, TAB->array, RD
    | fdtoistr 4, TMP0, CARG2
    | std 5, BASE, 0xfffffff0, TMP0
    |>
    |<
    | cmpbsb 3, CARG2, CARG3, pred0
    | sxt 4, 0x2, CARG2, CARG2
    | nop 1
    |>
    | shld 3, CARG2, 0x3, CARG2
    |<
    | addd 3, RD, CARG2, RD, pred0
    | ct ctpr2, ~pred0                      // Not in array part?
    |>
    |<
    | ldw 3, RD, 0x0, TMP0
    | lddsm 5, RD, 0x0, RB
    | nop 2
    |>
    |<
    | cmpesb 3, TMP0, LJ_TNIL, pred0
    | nop 1
    |>
    |<
    | addd 3, 0x0, (0+1)*8, RD, pred0
    | ct ctpr3, pred0
    |>
    | // Copy array slot.
    |<
    | addd 3, 0x0, (1+2)*8, RD
    | std 5, BASE, 0xfffffff8, RB
    | ct ctpr3
    |>
    |1: // Check for empty hash part first. Otherwise call C function.
    | disp ctpr1, extern lj_tab_getinth     // (GCtab *t, int32_t key)
    |<
    | cmpedb 3, CARG4, 0x0, pred0
    | addd 4, RB, 0x0, CARG1
    | addd 5, RA, 0x0, CARG2
    | nop 2
    |>
    |<
    | addd 3, 0x0, (0+1)*8, RD, pred0
    | ct ctpr3, pred0
    |>
    | call ctpr1, wbs = 0x8
    | // cTValue * or NULL returned.
    |<
    | lddsm 0, CRET1, 0x0, RB
    | cmpedb 1, CRET1, 0x0, pred0
    | ldwsm 2, CRET1, 0x0, TMP0
    | disp ctpr3, ->fff_res
    | nop 2
    |>
    |<
    | cmpesbsm 1, TMP0, LJ_TNIL, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, ~p1, p4
    | pass p4, pred0
    |>
    |<
    | addd 3, 0x0, (0+1)*8, RD, pred0
    | ct ctpr3, pred0
    |>
    | // Copy array slot.
    |<
    | addd 3, 0x0, (1+2)*8, RD
    | std 5, BASE, 0xfffffff8, RB
    | ct ctpr3
    |>
    |
    |->ff_ipairs:
    |<
    | ldd 3, BASE, 0x0, RB
    | addd 4, 0x0, U64x(0x00007fff,0xffffffff), CARG2
    | lddsm 5, BASE, 0xfffffff0, CARG1
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | andd 2, CARG1, CARG2, CARG1
    | addd 3, RB, 0x0, TMP1
    | sard 4, RB, 0x2f, ITYPE
    | andd 5, RB, CARG2, RB
    |>
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpesb 4, ITYPE, LJ_TTAB, pred1
    | lddsm 5, RB, TAB->metatable, TMP0
    |>
    |<
    | lddsm 0, CARG1, CFUNC->upvalue[0], CARG2
    | addd 1, 0x0, LJ_TFUNC, ITYPE
    |>
    |<
    | shld 0, ITYPE, 0x2f, ITYPE
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr1, ~pred0
#if LJ_52
    |<
    | cmpedb 3, TMP0, 0x0, pred0
    | nop 2
    |>
    | ct ctpr1, ~pred0
#endif
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | ord 1, CARG2, ITYPE, CARG2
    | disp ctpr1, ->fff_res
    |>
    |<
    | addd 1, 0x0, 0x0, TMP0
    | std 2, BASE, 0xfffffff8, TMP1
    | std 5, BASE, 0xfffffff0, CARG2
    |>
    |<
    | addd 4, 0x0, (1+3)*8, RD
    | std 5, BASE, 0x0, TMP0
    | ct ctpr1
    |>
    |
    |//-- Base library: catch errors ----------------------------------------
    |
    |->ff_pcall:
    |<
    | ldbsm 2, DISPATCH, DISPATCH_GL(hookmask), RB
    | cmpbdb 3, RD, (1+1)*8, pred0
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | shrdsm 0, RB, HOOK_ACTIVE_SHIFT, RB
    | addd 3, BASE, 0x10, RA
    | disp ctpr2, >1
    |>
    | anddsm 0, RB, 0x1, RB
    |<
    | addd 0, 0x0, 16+FRAME_PCALL, PC, ~pred0
    | subd 3, RD, 0x8, RD, ~pred0
    | ct ctpr1, pred0
    |>
    |<
    | addd 0, PC, RB, PC                    // Remember active hook before pcall.
    | subd 3, RD, 0x8, KBASE
    | addd 4, RA, RD, TMP0
    |>
    | // Note: this does a (harmless) copy of the function to the PC slot, too.
    |1:
    |<
    | ldd 3, TMP0, 0xffffffe8, RB
    | cmpbedb 4, KBASE, 0x0, pred0
    | nop 2
    |>
    |<
    | addd 3, RA, KBASE, TMP0, ~pred0
    | subd 4, KBASE, 0x8, KBASE, ~pred0
    | std 5, TMP0, 0xfffffff0, RB
    | ct ctpr2, ~pred0
    |>
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    |<
    | ldd 3, RA, 0xfffffff0, RB
    | disp ctpr1, ->vmeta_call
    | nop 2
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
    |>
    |<
    | lddsm 3, RB, LFUNC->pc, CARG1
    | cmpesb 4, ITYPE, LJ_TFUNC, pred0
    | nop 2
    |>
    |<
    | ldwsm 3, CARG1, 0x0, TMP0
    | addd 4, RA, 0x0, BASE, pred0
    | ldbsm 5, CARG1, 0x0, TMP1
    | ct ctpr1, ~pred0
    |>
    |<
    | std 5, BASE, 0xfffffff8, PC
    | nop 1
    |>
    |<
    | shld 0, TMP1, 0x3, TMP1               // jmp to [DISPATCH+OP*8]
    | addd 1, CARG1, 0x4, PC
    | shrd 3, TMP0, 0x5, RA
    |>
    |<
    | ldd 0, TMP1, DISPATCH, TMP1
    | andd 3, RA, 0x7f8, RA
    | nop 2
    |>
    | movtd 0, TMP1, ctpr1
    | ct ctpr1
    |
    |->ff_xpcall:
    |<
    | ldd 3, BASE, 0x8, RA
    | ldd 5, BASE, 0x0, RB
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    | sard 3, RA, 0x2f, ITYPE
    |<
    | cmpbdb 3, RD, (2+1)*8, pred0
    | cmpesb 4, ITYPE, LJ_TFUNC, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | addd 1, 0x0, 0x18+FRAME_PCALL, PC, pred0
    | std 2, BASE, 0x0, RA, pred0           // Swap function and traceback.
    | std 5, BASE, 0x8, RB, pred0
    | ct ctpr1, ~pred0
    |>
    |<
    | ldb 0, DISPATCH, DISPATCH_GL(hookmask), RB
    | disp ctpr2, >1
    | nop 1
    |>
    |<
    | addd 3, BASE, 0x18, RA
    | subd 4, RD, 0x10, RD
    |>
    |<
    | shrd 0, RB, HOOK_ACTIVE_SHIFT, RB
    | addd 3, RD, 0x0, KBASE
    |>
    |<
    | andd 0, RB, 0x1, RB
    | addd 3, RA, KBASE, TMP0
    |>
    |<
    | addd 0, PC, RB, PC                    // Remember active hook before pcall.
    | subd 3, KBASE, 0x8, KBASE
    |>
    | // Note: this does a (harmless) copy of the function to the PC slot, too.
    |1:
    |<
    | ldd 3, TMP0, 0xffffffe8, RB
    | cmpbedb 4, KBASE, 0x0, pred0
    | nop 2
    |>
    |<
    | addd 3, RA, KBASE, TMP0, ~pred0
    | subd 4, KBASE, 0x8, KBASE, ~pred0
    | std 5, TMP0, 0xfffffff0, RB
    | ct ctpr2, ~pred0
    |>
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    |<
    | ldd 3, RA, 0xfffffff0, RB
    | disp ctpr1, ->vmeta_call
    | nop 2
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
    |>
    |<
    | lddsm 3, RB, LFUNC->pc, CARG1
    | cmpesb 4, ITYPE, LJ_TFUNC, pred0
    | nop 2
    |>
    |<
    | ldwsm 3, CARG1, 0x0, TMP0
    | addd 4, RA, 0x0, BASE, pred0
    | ldbsm 5, CARG1, 0x0, TMP1
    | ct ctpr1, ~pred0
    |>
    |<
    | std 5, BASE, 0xfffffff8, PC
    | nop 1
    |>
    |<
    | shld 0, TMP1, 0x3, TMP1               // jmp to [DISPATCH+OP*8]
    | addd 1, CARG1, 0x4, PC
    | shrd 3, TMP0, 0x5, RA
    |>
    |<
    | ldd 0, TMP1, DISPATCH, TMP1
    | andd 3, RA, 0x7f8, RA
    | nop 2
    |>
    | movtd 0, TMP1, ctpr1
    | ct ctpr1
    |
    |//-- Coroutine library --------------------------------------------------
    |
    |.macro coroutine_resume_wrap, resume
    |.if resume
    |->ff_coroutine_resume:
    |<
    | ldd 3, BASE, 0xfffffff8, PC
    | ldd 5, BASE, 0x0, RB
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
    |>
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpesb 4, ITYPE, LJ_TTHREAD, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | std 2, STACK, SAVE_PC, PC, pred0
    | ct ctpr1, ~pred0
    |>
    |.else
    |->ff_coroutine_wrap_aux:
    |<
    | ldd 3, BASE, 0xfffffff0, RB
    | ldd 5, BASE, 0xfffffff8, PC
    | nop 2
    |>
    | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
    |<
    | ldd 3, RB, CFUNC->upvalue[0].gcr, RB
    | nop 2
    |>
    |<
    | std 2, STACK, SAVE_PC, PC
    | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
    |>
    |.endif
    |<
    | ldd 3, RB, L->cframe, TMP0
    | addd 4, RB, 0x0, TMP1
    | ldbsm 5, RB, L->status, CARG1
    |>
    |<
    | lddsm 3, RB, L->top, RA
    | disp ctpr1, ->fff_fallback
    | nop 1
    |>
    |<
    | cmpedb 3, TMP0, 0x0, pred0
    | cmpbedbsm 4, CARG1, LUA_YIELD, pred1
    | lddsm 5, RB, L->base, TMP0
    |>
    | cmpedb 3, CARG1, LUA_YIELD, pred2
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | cmpbedb 3, RA, TMP0, pred1            // Check for presence of initial func.
    | ct ctpr1, ~pred0
    | nop 1
    |>
    |<
    | lddsm 0, RB, L->maxstack, TMP0
    | pass pred1, p0
    | pass pred2, p1
    | landp p0, ~p1, p4
    | landp ~p0, ~p1, p5
    | pass p4, pred0
    | pass p5, pred1                        // Status != LUA_YIELD (i.e. 0)?
    |>
    |<
    | ldd 3, RA, 0xfffffff8, PC, pred1      // Move initial function up.
    | ct ctpr1, pred0
    | nop 2
    |>
    |<
    | addd 4, RA, 0x8, RA, pred1
    | std 5, RA, 0x0, PC, pred1
    |>
    |.if resume
    | addd 3, RA, RD, PC                       // Check stack space (-1-thread).
    | subd 0, PC, 0x10, PC
    |.else
    | addd 3, RA, RD, PC                       // Check stack space (-1).
    | subd 0, PC, 0x8, PC
    |.endif
    |<
    | cmpbedb 0, PC, TMP0, pred0
    | ldd 2, STACK, SAVE_L, CARG1
    | disp ctpr2, >2
    | nop 2
    |>
    |<
    | std 2, CARG1, L->base, BASE, pred0
    | std 5, RB, L->top, PC, pred0
    | ct ctpr1, ~pred0
    |>
    |.if resume
    | addd 3, BASE, 0x8, BASE                  // Keep resumed thread in stack for GC.
    |.endif
    |<
    | std 2, CARG1, L->top, BASE
    | disp ctpr3, >1
    |>
    |.if resume
    | addd 3, BASE, RD, RB                     // RB = end of source for stack move.
    | subd 3, RB, 0x18, RB
    |.else
    | addd 3, BASE, RD, RB                     // RB = end of source for stack move.
    | subd 3, RB, 0x10, RB
    |.endif
    |<
    | cmpedb 0, PC, RA, pred0
    | subd 3, RB, PC, RB                       // Relative to PC.
    | disp ctpr1, ->vm_resume               // (lua_State *L, TValue *base, 0, 0)
    | nop 2
    |>
    | ct ctpr2, pred0
    |1: // Move args to coroutine.
    |<
    | ldd 0, PC, RB, RC
    | nop 2
    |>
    |<
    | subd 1, PC, 0x8, PC
    | std 2, PC, 0xfffffff8, RC
    |>
    |<
    | cmpedb 0, PC, RA, pred0
    | nop 2
    |>
    | ct ctpr3, ~pred0
    |2:
    |<
    | addd 0, RA, 0x0, CARG2
    | addd 1, TMP1, 0x0, CARG1
    | call ctpr1, wbs = 0x8
    |>
    |<
    | ldd 0, STACK, SAVE_L, RB
    | addd 1, TMP1, 0x0, PC
    | addd 2, 0x0, ~LJ_VMST_INTERP, TMP0
    | disp ctpr2, >7
    | nop 2
    |>
    |<
    | ldd 3, RB, L->base, BASE
    | nop 2
    |>
    |<
    | cmpbedb 0, CRET1, LUA_YIELD, pred0
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), TMP0
    | std 5, DISPATCH, DISPATCH_GL(cur_L), RB
    | nop 2
    |>
    | ct ctpr2, ~pred0
    |3:
    |<
    | ldd 0, PC, L->base, RA
    | ldd 2, PC, L->top, KBASE
    | lddsm 3, RB, L->maxstack, TMP0
    | disp ctpr1, >5
    | nop 2
    |>
    |<
    | std 2, PC, L->top, RA                 // Clear coroutine stack.
    | subd 3, KBASE, RA, PC
    | disp ctpr2, >8
    |>
    |<
    | cmpedb 3, PC, 0x0, pred0
    | disp ctpr3, >4
    | nop 2
    |>
    |<
    | addd 3, BASE, PC, RD, ~pred0
    | ct ctpr1, pred0                       // No results?
    |>
    |<
    | cmpbedb 3, RD, TMP0, pred0
    | addd 4, BASE, 0x0, CARG1
    | nop 2
    |>
    |<
    | subd 3, CARG1, RA, RB, pred0
    | ct ctpr2, ~pred0                      // Need to grow stack?
    |>
    |4: // Move results from coroutine.
    |<
    | ldd 3, RA, 0x0, RD
    | nop 2
    |>
    |<
    | addd 4, RA, 0x8, RA
    | std 5, RA, RB, RD
    |>
    |<
    | cmpedb 3, RA, KBASE, pred0
    | nop 2
    |>
    | ct ctpr3, ~pred0
    |5:
    |.if resume
    |<
    | addd 3, PC, (1+1)*8, RD               // (nresults+1)*8 = (1 + true)*8 + results*8.
    | addd 4, 0x0, U64x(0xfffeffff,0xffffffff), ITYPE
    |>
    | std 5, BASE, 0xfffffff8, ITYPE        // Prepend true to results.
    |.else
    | addd 3, PC, 1*8, RD                   // (nresults+1)*8 = 8 + results*8.
    |.endif
    |6:
    |<
    | ldd 0, STACK, SAVE_PC, PC
    | disp ctpr1, ->BC_RET_Z
    |>
    |<
    | stw 2, STACK, MULTRES, RD
    | disp ctpr2, ->vm_return
    |>
    |.if resume
    | subd 3, 0x0, 0x8, RA
    |.else
    | addd 3, 0x0, 0x0, RA
    |.endif
    |<
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | nop 2
    |>
    | ct ctpr1, pred0
    | ct ctpr2
    |7: // Coroutine returned with error (at co->top-1).
    |.if resume
    |<
    | ldd 0, PC, L->top, RA
    | addd 1, 0x0, U64x(0xffff7fff,0xffffffff), ITYPE
    | disp ctpr1, <6
    | nop 1
    |>
    | std 5, BASE, 0xfffffff8, ITYPE        // Prepend false to results.
    | subd 0, RA, 0x8, RA
    | std 2, PC, L->top, RA                 // Clear error from coroutine stack.
    | // Copy error message.
    |<
    | ldd 0, RA, 0x0, RD
    | nop 2
    |>
    |<
    | addd 4, 0x0, (1+2)*8, RD              // (nresults+1)*8 = (1 + false + error)*8.
    | std 5, BASE, 0x0, RD
    | ct ctpr1
    |>
    |.else
    | disp ctpr1, extern lj_ffh_coroutine_wrap_err // (lua_State *L, lua_State *co)
    |<
    | addd 0, PC, 0x0, CARG2
    | addd 1, RB, 0x0, CARG1
    | nop 3
    |>
    | call ctpr1, wbs = 0x8
    | // Error function does not return.
    |.endif
    |8:  // Handle stack expansion on return from yield.
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    |<
    | addd 0, TMP1, 0x0, RA
    | shrd 1, PC, 0x3, PC
    | nop 3
    |>
    |<
    | addd 0, PC, 0x0, CARG2
    | addd 1, RB, 0x0, CARG1
    | std 2, RA, L->top, KBASE              // Undo coroutine stack clearing.
    | call ctpr1, wbs = 0x8
    |>
    |<
    | ldd 3, RB, L->base, BASE
    | disp ctpr2, <3                        // Retry the stack move.
    | nop 4
    |>
    |<
    | addd 0, TMP1, 0x0, PC
    | ct ctpr2
    |>
    |.endmacro
    |
    | coroutine_resume_wrap 1        // coroutine.resume
    | coroutine_resume_wrap 0        // coroutine.wrap
    |
    |->ff_coroutine_yield:
    |<
    | ldd 0, STACK, SAVE_L, RB
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | ldd 0, RB, L->cframe, TMP0
    | addd 3, BASE, RD, TMP1
    | return ctpr3
    | nop 2
    |>
    |<
    | cmpandedb 0, TMP0, CFRAME_RESUME, pred0
    | nop 2
    |>
    | ct ctpr1, pred0
    |<
    | std 2, RB, L->base, BASE
    | subd 3, TMP1, 0x8, RD
    |>
    |<
    | std 2, RB, L->top, RD
    | addd 3, 0x0, 0x0, RD
    |>
    |<
    | addd 0, 0x0, LUA_YIELD, RRET1
    | std 2, RB, L->cframe, RD
    |>
    |<
    | stb 2, RB, L->status, RRET1
    | ct ctpr3
    |>
    |
    |//-- Math library -------------------------------------------------------
    |
    |->ff_math_abs:
    |<
    | ldd 3, BASE, 0x0, RB
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | shld 4, RB, 0x1, RB
    |>
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
    | shrd 5, RB, 0x1, RB
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr1, ~pred0
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | disp ctpr1, ->fff_res
    | nop 4
    |>
    |<
    | addd 3, 0x0, (1+1)*8, RD
    | std 5, BASE, 0xfffffff0, RB
    | ct ctpr1
    |>
    |
    |->ff_math_sqrt:
    |<
    | ldd 3, BASE, 0x0, CARG1
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | sard 3, CARG1, 0x2f, ITYPE
    | fsqrtid 5, CARG1, TMP1
    |>
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr1, ~pred0
    | fsqrttd 5, CARG1, TMP1, TMP0
    | // fallthrough
    |
    |->fff_resb:
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | nop 2
    |>
    |<
    | addd 3, 0x0, (1+1)*8, RD
    | std 5, BASE, 0xfffffff0, TMP0
    |>
    | // fallthrough
    |
    |->fff_res:
    |<
    | cmpandedb 0, PC, FRAME_TYPE, pred0
    | ldbsm 2, PC, 0x0, CARG4
    | addd 3, 0x0, LJ_TNIL, TMP1
    | stw 5, STACK, MULTRES, RD
    | disp ctpr1, ->vm_return
    |>
    |<
    | ldb 3, PC, PC_RB, RB, pred0
    | ldw 5, PC, 0x0, CARG3, pred0
    | disp ctpr2, >2
    | nop 1
    |>
    | ldb 3, PC, PC_RA, RA, pred0
    |<
    | shld 0, CARG4, 0x3, CARG4, pred0
    | addd 1, PC, 0x4, PC, pred0
    | subd 3, 0x0, 0x10, RA, ~pred0         // Results start at BASE+RA = BASE-16
    | shld 4, RB, 0x3, RB, pred0
    | disp ctpr3, >1
    |>
    |<
    | ldd 0, CARG4, DISPATCH, CARG4, pred0
    | cmpbedbsm 3, RB, RD, pred1            // More results expected?
    | ct ctpr1, ~pred0                      // Non-standard return case.
    |>
    |<
    | shld 3, RA, 0x3, CARG5
    | ct ctpr2, pred1
    |>
    |1:                                     // Fill up results with nil.
    |<
    | subd 3, RD, 0x18, TMP0
    | addd 4, RD, 0x8, RD
    |>
    |<
    | cmpbedb 3, RB, RD, pred1
    | std 5, BASE, TMP0, TMP1
    |>
    | ct ctpr3, ~pred1
    |2:
    |<
    | movtd 0, CARG4, ctpr1
    | subd 3, BASE, 0x10, BASE
    |>
    |<
    | shrd 3, CARG3, 0x5, RA
    | shrd 4, CARG3, 0x15, RB
    | shrd 5, CARG3, 0xd, RD
    |>
    |<
    | subd 3, BASE, CARG5, BASE                   // base = base - (RA+2)*8
    | andd 4, RD, 0x7fff8, RD
    | andd 5, RA, 0x7f8, RA
    |>
    |<
    | andd 3, RB, 0x7f8, RB
    | andd 4, RD, 0x7f8, RC
    | ct ctpr1
    |>
    |
    |.macro math_round, func
    |->ff_math_ .. func:
    |<
    | ldd 3, BASE, 0x0, CARG1
    | disp ctpr2, ->fff_fallback
    | nop 1
    |>
    | disp ctpr1, ->vm_ .. func
    | sard 3, CARG1, 0x2f, ITYPE
    |<
    | cmpbsb 0, ITYPE, LJ_TISNUM, pred0
    | nop 2
    |>
    | ct ctpr2, ~pred0
    | call ctpr1, wbs = 0x8
    |<
    | addd 0, CRET1, 0x0, TMP0
    | disp ctpr1, ->fff_resb
    | nop 4
    |>
    | ct ctpr1
    |.endmacro
    |
    | math_round floor
    | math_round ceil
    |
    |->ff_math_log:
    |<
    | ldd 3, BASE, 0x0, CARG1
    | disp ctpr2, ->fff_fallback
    | nop 1
    |>
    | disp ctpr1, extern log
    | sard 3, CARG1, 0x2f, ITYPE
    |<
    | cmpedb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr2, ~pred0
    | call ctpr1, wbs = 0x8
    |<
    | addd 0, CRET1, 0x0, TMP0
    | disp ctpr2, ->fff_resb
    | nop 4
    |>
    | ct ctpr2
    |
    |.macro math_extern, func
    |->ff_math_ .. func:
    |<
    | ldd 3, BASE, 0x0, CARG1
    | disp ctpr2, ->fff_fallback
    | nop 1
    |>
    | disp ctpr1, extern func
    | sard 3, CARG1, 0x2f, ITYPE
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr2, ~pred0
    | call ctpr1, wbs = 0x8
    |<
    | addd 0, CRET1, 0x0, TMP0
    | disp ctpr2, ->fff_resb
    | nop 4
    |>
    | ct ctpr2
    |.endmacro
    |
    |.macro math_extern2, func
    |->ff_math_ .. func:
    |<
    | ldd 3, BASE, 0x0, CARG1
    | addd 4, 0x0, 0x2f, TMP0
    | ldd 5, BASE, 0x8, CARG2
    | disp ctpr2, ->fff_fallback
    | nop 1
    |>
    | disp ctpr1, extern func
    |<
    | cmpbdb 3, RD, (2+1)*8, pred0
    | sard 4, CARG1, TMP0, ITYPE
    | sard 5, CARG2, TMP0, TMP1
    |>
    |<
    | cmpbsb 3, ITYPE, LJ_TISNUM, pred1
    | cmpbsb 4, TMP1, LJ_TISNUM, pred2
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | pass pred2, p2
    | landp ~p0, p1, p4
    | landp p4, p2, p5
    | pass p5, pred0
    |>
    | ct ctpr2, ~pred0
    | call ctpr1, wbs = 0x8
    |<
    | addd 3, CRET1, 0x0, TMP0
    | disp ctpr1, ->fff_resb
    |>
    | ct ctpr1
    |.endmacro
    |
    | math_extern log10
    | math_extern exp
    | math_extern sin
    | math_extern cos
    | math_extern tan
    | math_extern asin
    | math_extern acos
    | math_extern atan
    | math_extern sinh
    | math_extern cosh
    | math_extern tanh
    | math_extern2 pow
    | math_extern2 atan2
    | math_extern2 fmod
    |
    |->ff_math_ldexp:
    |<
    | ldd 3, BASE, 0x0, TMP0
    | addd 4, 0x0, 0x2f, CARG2
    | ldd 5, BASE, 0x8, TMP1
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | cmpbdb 3, RD, (2+1)*8, pred0
    | sard 4, TMP0, CARG2, ITYPE
    | sard 5, TMP1, CARG2, CARG1
    | disp ctpr2, ->fff_res
    |>
    |<
    | cmpbsb 3, ITYPE, LJ_TISNUM, pred1
    | cmpbsb 4, CARG1, LJ_TISNUM, pred2
    |>
    | fdtoidtr 3, TMP1, TMP1
    |<
    | pass pred0, p0
    | pass pred1, p1
    | pass pred2, p2
    | landp ~p0, p1, p4
    | landp p4, p2, p5
    | pass p5, pred0
    |>
    |<
    | fscaled 4, TMP0, TMP1, TMP0
    | ct ctpr1, ~pred0
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | nop 2
    |>
    |<
    | addd 3, 0x0, (1+1)*8, RD
    | std 5, BASE, 0xfffffff0, TMP0
    | ct ctpr2
    |>
    |
    |->ff_math_frexp:
    |<
    | ldd 3, BASE, 0x0, CARG1
    | disp ctpr2, ->fff_fallback
    | nop 1
    |>
    | disp ctpr1, extern frexp
    | sard 3, CARG1, 0x2f, ITYPE
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr2, ~pred0
    |<
    | addd 0, STACK, STACK_TMP, CARG2
    | call ctpr1, wbs = 0x8
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | ldw 2, STACK, STACK_TMP, TMP0
    | disp ctpr1, ->fff_res
    | nop 2
    |>
    |<
    | istofd 0, TMP0, TMP0
    | std 5, BASE, 0xfffffff0, CRET1
    |>
    |<
    | addd 3, 0x0, (1+2)*8, RD
    | std 5, BASE, 0xfffffff8, TMP0
    | ct ctpr1
    |>
    |
    |->ff_math_modf:
    |<
    | ldd 3, BASE, 0x0, CARG1
    | disp ctpr2, ->fff_fallback
    | nop 1
    |>
    | disp ctpr1, extern modf
    | sard 3, CARG1, 0x2f, ITYPE
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr2, ~pred0
    |<
    | subd 3, BASE, 0x10, CARG2
    | call ctpr1, wbs = 0x8
    |>
    |<
    | ldd 0, BASE, 0xfffffff8, PC
    | disp ctpr2, ->fff_res
    | nop 2
    |>
    |<
    | addd 4, 0x0, (1+2)*8, RD
    | std 5, BASE, 0xfffffff8, CRET1
    | ct ctpr2
    |>
    |
    |.macro math_minmax, name, ins
    |->ff_ .. name:
    |<
    | ldd 3, BASE, 0x0, TMP0
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | sard 3, TMP0, 0x2f, ITYPE
    | disp ctpr2, ->fff_resb
    |>
    |<
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
    | disp ctpr3, >1
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | addd 3, 0x0, 0x10, RA
    | ct ctpr1, ~pred0
    |>
    |1: //  Handle numbers or integers.
    |<
    | cmpbsb 3, RA, RD, pred0
    | addd 4, BASE, RA, TMP1
    |>
    |<
    | lddsm 3, TMP1, 0xfffffff8, TMP1
    | nop 1
    |>
    | ct ctpr2, ~pred0
    | sard 3, TMP1, 0x2f, ITYPE
    |<
    | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
    | nop 2
    |>
    | ct ctpr1, ~pred0
    |<
    | ins 3, TMP0, TMP1, TMP0
    | addd 4, RA, 0x8, RA
    | ct ctpr3
    |>
    |.endmacro
    |
    | math_minmax math_min, fmind
    | math_minmax math_max, fmaxd
    |
    |//-- String library -----------------------------------------------------
    |
    |->ff_string_byte:
    |<
    | ldd 3, BASE, 0x0, RB
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
    | disp ctpr2, ->fff_res
    |>
    |<
    | cmpedb 3, RD, (1+1)*8, pred0
    | cmpesb 4, ITYPE, LJ_TSTR, pred1
    | disp ctpr3, ->fff_resb
    |>
    | ldwsm 3, RB, STR->len, TMP0
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    | ct ctpr1, ~pred0
    |<
    | ldd 2, BASE, 0xfffffff8, PC
    | ldbsm 3, RB, STR[1], RB
    | cmpbsbsm 4, TMP0, 0x1, pred1
    | nop 2
    |>
    |<
    | addd 2, 0x0, (0+1)*8, RD, pred1
    | istofd 3, RB, TMP0
    | ct ctpr2, pred1                       // Return no results for empty string.
    |>
    | ct ctpr3
    |
    |->ff_string_char:
    | ffgccheck
    |<
    | ldd 3, BASE, 0x0, TMP0
    | addd 4, 0x0, 0x1, TMP1
    | nop 2
    |>
    |<
    | sard 3, TMP0, 0x2f, ITYPE
    | fdtoistr 4, TMP0, RB
    |>
    |<
    | cmpedb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
    |>
    |<
    | pass pred0, p0                        // *Exactly* 1 arg.
    | pass pred1, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | cmpbesb 3, RB, 255, pred1
    | ct ctpr3, ~pred0
    | nop 2
    |>
    |<
    | stw 2, STACK, STACK_TMP, RB, pred1
    | addd 3, STACK, STACK_TMP, RD, pred1   // Points to stack. Little-endian.
    | ct ctpr3, ~pred1
    |>
    | // Fall through
    |
    |->fff_newstr:
    | disp ctpr1, extern lj_str_new         // (lua_State *L, char *str, size_t l)
    |<
    | ldd 0, STACK, SAVE_L, RB
    | sxt 1, 0x2, TMP1, CARG3               // Zero-extended to size_t.
    | nop 2
    |>
    |<
    | addd 0, RD, 0x0, CARG2
    | addd 1, RB, 0x0, CARG1
    | std 2, RB, L->base, BASE
    |>
    |<
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    | // GStr * returned.
    |<
    | addd 2, 0x0, LJ_TSTR, ITYPE
    | ldd 3, RB, L->base, BASE
    | disp ctpr1, ->fff_res
    | nop 2
    |>
    | shld 0, ITYPE, 0x2f, ITYPE
    |<
    | ord 2, CRET1, ITYPE, CRET1
    | ldd 3, BASE, 0xfffffff8, PC
    |>
    |<
    | addd 0, 0x0, (1+1)*8, RD
    | std 5, BASE, 0xfffffff0, CRET1
    | ct ctpr1
    |>
    |
    |->ff_string_sub:
    | ffgccheck
    |<
    | lddsm 3, BASE, 0x10, TMP0
    | addd 4, 0x0, 0x0, RA
    | adds 5, 0x0, 0xffffffff, TMP1
    | nop 1
    |>
    |<
    | cmpbdb 3, RD, (1+2)*8, pred0
    | cmpbedb 4, RD, (1+2)*8, pred1
    |>
    | sardsm 5, TMP0, 0x2f, ITYPE
    |<
    | cmpbsbsm 3, ITYPE, LJ_TISNUM, pred2
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | pass pred2, p2
    | landp ~p0, p2, p4
    | landp ~p1, p2, p5
    | pass p4, pred0
    | pass p5, pred1
    |>
    |<
    | fdtoistr 3, TMP0, TMP1, pred1
    | ct ctpr3, ~pred0
    |>
    |<
    | ldd 3, BASE, 0x0, RB
    | addd 4, 0x0, U64x(0x00007fff,0xffffffff), CARG1
    | ldd 5, BASE, 0x8, TMP0
    | nop 2
    |>
    |<
    | sard 3, RB, 0x2f, ITYPE
    | andd 4, RB, CARG1, RB
    | sard 5, TMP0, 0x2f, CARG1
    |>
    |<
    | cmpesb 3, ITYPE, LJ_TSTR, pred0
    | cmpbsb 4, CARG1, LJ_TISNUM, pred1
    | ldwsm 5, RB, STR->len, RC
    | disp ctpr1, >2
    | nop 1
    |>
    |<
    | fdtoistr 3, TMP0, RA
    | pass pred0, p0
    | pass pred1, p1
    | landp p0, p1, p4
    | pass p4, pred0
    | disp ctpr2, >2
    |>
    |<
    | cmpbsbsm 3, RC, TMP1, pred1
    | cmplsbsm 4, RC, TMP1, pred2
    | adds 5, TMP1, 0x1, CARG1
    | ct ctpr3, ~pred0
    |>
    |<
    | cmplesb 3, RA, 0x0, pred3
    | cmpesb 4, RA, 0x0, pred4
    | disp ctpr2, ->fff_newstr
    |>
    |<
    | pass pred1, p0
    | pass pred2, p1
    | landp p0, p1, p4
    | landp p0, ~p1, p5
    | pass p4, pred0
    | pass p5, pred1
    |>
    |<
    | pass pred3, p0
    | pass pred4, p1
    | landp p0, ~p1, p4
    | pass p4, pred2
    |>
    |<
    | adds 3, CARG1, RC, TMP1, pred1        // end = end+(len+1)
    | adds 4, RC, 0x0, TMP1, pred0          // end = len
    | adds 5, 0x0, 0x1, RA, pred4           // start = 1
    | ct ctpr1, ~pred2                      // start > 0?
    |>
    | // Negative start or underflow.
    | adds 3, RA, RC, RA                    // start = start+(len+1)
    | adds 3, RA, 0x1, RA
    | cmplesb 3, RA, 0x0, pred0
    | adds 3, 0x0, 0x1, RA, pred0           // start = 1
    |2:
    |<
    | subs 3, TMP1, RA, TMP1
    | addd 4, RB, RA, CARG1
    |>
    |<
    | cmplsb 3, TMP1, 0x0, pred0
    | nop 1
    |>
    |<
    | xors 3, TMP1, TMP1, TMP1, pred0       // Zero length. Any ptr in RD is ok.
    | adds 4, TMP1, 0x1, TMP1, ~pred0
    | addd 5, CARG1, #STR-1, RD, ~pred0
    | ct ctpr2
    |>
    |
    |.macro ffstring_op, name
    |->ff_string_..name:
    |<
    | lddsm 0, DISPATCH, DISPATCH_GL(gc.total), RB
    | lddsm 2, DISPATCH, DISPATCH_GL(gc.threshold), TMP0
    | disp ctpr1, ->fff_fallback
    |>
    |<
    | ldd 0, STACK, SAVE_L, CARG1
    | cmpbdb 3, RD, (1+1)*8, pred0
    | disp ctpr2, >1
    | nop 2
    |>
    | ct ctpr1, pred0
    |<
    | cmpbdbsm 0, RB, TMP0, pred1
    | nop 1
    |>
    | disp ctpr1, extern lj_gc_step         // (lua_State *L)
    |<
    | ct ctpr2, pred1
    | std 2, CARG1, L->base, BASE, ~pred1
    | addd 3, BASE, RD, RD, ~pred1
    | std 5, STACK, SAVE_PC, PC, ~pred1
    |>
    |<
    | subd 3, RD, 0x8, RD
    | nop 2
    |>
    |<
    | addd 3, CARG1, 0x0, RB 
    | std 5, CARG1, L->top, RD
    | call ctpr1, wbs = 0x8
    |>
    |<
    | ldd 3, RB, L->base, BASE
    | ldd 5, RB, L->top, RD
    | nop 2
    |>
    | subd 3, RD, BASE, RD
    | addd 3, RD, 0x8, RD
    |1:
    |<
    | addd 0, DISPATCH, DISPATCH_GL(tmpbuf), CARG1
    | ldd 3, BASE, 0x0, CARG2
    | ldd 5, STACK, SAVE_L, RB
    | disp ctpr2, ->fff_fallback
    |>
    | ldd 0, CARG1, SBUF->b, RC
    | disp ctpr1, extern lj_buf_putstr_ .. name
    |<
    | sard 3, CARG2, 0x2f, ITYPE
    | andd 4, CARG2, U64x(0x00007fff,0xffffffff), CARG2
    |>
    |<
    | cmpesb 3, ITYPE, LJ_TSTR, pred0
    | nop 2
    |>
    | ct ctpr2, ~pred0
    |<
    | std 2, CARG1, SBUF->L, RB
    | std 5, RB, L->base, BASE
    |>
    |<
    | std 2, CARG1, SBUF->p, RC
    | std 5, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    |>
    | disp ctpr1, extern lj_buf_tostr
    |<
    | addd 0, CRET1, 0x0, CARG1
    | call ctpr1, wbs = 0x8
    |>
    | // GStr * returned.
    |<
    | addd 0, 0x0, LJ_TSTR, ITYPE
    | ldd 3, RB, L->base, BASE
    | disp ctpr1, ->fff_res
    |>
    | shld 0, ITYPE, 0x2f, ITYPE
    | ord 0, CRET1, ITYPE, CRET1
    | ldd 3, BASE, 0xfffffff8, PC
    |<
    | addd 3, 0x0, (1+1)*8, RD
    | std 5, BASE, 0xfffffff0, CRET1
    | ct ctpr1
    |>
    |.endmacro
    |
    | ffstring_op reverse
    | ffstring_op lower
    | ffstring_op upper
    |
    |//-- Bit library --------------------------------------------------------
    |
    |.macro .ffunc_bit, name
    |->ff_bit_..name:
    |<
    | lddsm 3, BASE, 0x0, TMP0
    | cmpbdb 4, RD, (1+1)*8, pred0
    | disp ctpr1, ->fff_fallback
    | nop 2
    |>
    |<
    | sardsm 3, TMP0, 0x2f, ITYPE
    | fadddsm 4, TMP0, U64x(0x43380000,0x00000000), TMP0
    | disp ctpr2, ->fff_resb
    |>
    |<
    | cmpbsbsm 3, ITYPE, LJ_TISNUM, pred1
    | nop 3
    |>
    | ct ctpr1, pred0
    |<
    | adds 3, TMP0, 0x0, RB, pred1
    | ct ctpr1, ~pred1
    |>
    |.endmacro
    |
    |.macro .ffunc_bit_op, name, ins
    | .ffunc_bit name
    |<
    | addd 3, RD, 0x0, TMP1                 // Save for fallback.
    | addd 4, BASE, RD, RD
    | disp ctpr1, ->fff_fallback
    |>
    | subd 3, RD, 0x10, RD
    |1:
    |<
    | istofd 3, RB, TMP0
    | cmpbedb 4, RD, BASE, pred0
    | lddsm 5, RD, 0x0, CARG1
    | disp ctpr3, <1
    | nop 2
    |>
    |<
    | sardsm 3, CARG1, 0x2f, ITYPE
    | fadddsm 4, CARG1, U64x(0x43380000,0x00000000), CARG1
    | ct ctpr2, pred0
    |>
    |<
    | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
    | nop 2
    |>
    |<
    | addd 3, TMP1, 0x0, RD, ~pred0         // Restore for fallback
    | ct ctpr1, ~pred0
    |>
    |<
    | adds 3, CARG1, 0x0, RA
    | subd 4, RD, 0x8, RD
    |>
    |<
    | ins 3, RB, RA, RB
    | ct ctpr3
    |>
    |.endmacro
    |
    |.ffunc_bit_op band, ands
    |.ffunc_bit_op bor, ors
    |.ffunc_bit_op bxor, xors
    |
    |.ffunc_bit tobit
    |<
    | istofd 3, RB, TMP0
    | ct ctpr2
    |>
    |
    |.ffunc_bit bswap
    |<
    | sxt 3, 0x6, RB, RB
    | addd 4, 0x0, U64x(0x80808080,0x00010203), TMP0
    |>
    |<
    | pshufb 3, RB, RB, TMP0, RB
    | nop 3
    |>
    |<
    | istofd 3, RB, TMP0
    | ct ctpr2
    |>
    |
    |.ffunc_bit bnot
    |<
    | xors 3, RB, 0xffffffff, RB
    |>
    |<
    | istofd 3, RB, TMP0
    | ct ctpr2
    |>
    |
    |.macro .ffunc_bit_sh, name, ins
    |->ff_..bit_..name:
    |<
    | lddsm 3, BASE, 0x0, CARG1
    | cmpbdb 4, RD, (2+1)*8, pred0
    | lddsm 5, BASE, 0x8, CARG2
    | disp ctpr1, ->fff_fallback
    |>
    |<
    | addd 3, 0x0, U64x(0x43380000,0x00000000), TMP1
    | disp ctpr2, ->fff_resb
    | nop 1
    |>
    |<
    | sardsm 3, CARG1, 0x2f, TMP0
    | sardsm 4, CARG2, 0x2f, ITYPE
    |>
    |<
    | fadddsm 3, CARG1, TMP1, CARG1
    | fadddsm 4, CARG2, TMP1, CARG2
    |>
    |<
    | cmpbsbsm 3, TMP0, LJ_TISNUM, pred1
    | cmpbsbsm 4, ITYPE, LJ_TISNUM, pred2
    | ct ctpr1, pred0
    | nop 1
    |>
    |<
    | pass pred1, p0
    | pass pred2, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    |<
    | adds 3, CARG1, 0x0, RB, pred0
    | ands 4, CARG2, 0xff, RA, pred0
    | ct ctpr1, ~pred0
    |>
    | ins 3, RB, RA, RB
    |<
    | istofd 3, RB, TMP0
    | ct ctpr2
    |>
    |.endmacro
    |
    |.ffunc_bit_sh lshift, shls
    |.ffunc_bit_sh rshift, shrs
    |.ffunc_bit_sh arshift, sars
    |.ffunc_bit_sh rol, scls
    |.ffunc_bit_sh ror, scrs
    |
    |//-----------------------------------------------------------------------
    |
    |->fff_fallback:                        // Call fast function fallback handler.
    | // BASE = new base, RD = (nargs+1)*8
    |<
    | ldd 0, STACK, SAVE_L, RB
    | ldd 3, BASE, 0xfffffff8, PC           // Fallback may overwrite PC.
    | addd 4, BASE, RD, RD
    | ldd 5, BASE, 0xfffffff0, TMP1
    | disp ctpr2, >5
    | nop 2
    |>
    |<
    | andd 2, TMP1, U64x(0x00007fff,0xffffffff), TMP1
    | ldd 3, RB, L->maxstack, TMP0
    |>
    |<
    | lddsm 0, TMP1, CFUNC->f, ITYPE
    | subd 3, RD, 0x8, RD
    |>
    |<
    | addd 3, RD, 8*LUA_MINSTACK, RA        // Ensure enough space for handler.
    | std 5, RB, L->top, RD
    |>
    |<
    | std 2, STACK, SAVE_PC, PC             // Redundant (but a defined value).
    | cmpbedb 3, RA, TMP0, pred0
    | addd 4, RB, 0x0, CARG1
    | std 5, RB, L->base, BASE
    | nop 1
    |>
    | movtdsm 0, ITYPE, ctpr1
    | ct ctpr2, ~pred0                      // Need to grow stack.
    | call ctpr1, wbs = 0x8                 // (lua_State *L)
    | // Either throws an error, or recovers and returns -1, 0 or nresults+1.
    |<
    | ldd 3, RB, L->base, BASE
    | shld 4, CRET1, 0x3, RD
    | disp ctpr2, ->fff_res
    |>
    |<
    | cmpledb 3, CRET1, 0x0, pred0
    | nop 2
    |>
    | ct ctpr2, ~pred0                      // Returned nresults+1?
    |1:
    |<
    | ldd 3, RB, L->top, RA
    | cmpedb 4, CRET1, 0x0, pred0
    | ldd 5, BASE, 0xfffffff0, RB
    | disp ctpr1, ->vm_call_tail
    | nop 2
    |>
    |<
    | subd 3, RA, BASE, RA
    | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
    |>
    |<
    | addd 3, RA, 0x8, RD
    | ct ctpr1, ~pred0                      // Returned -1?
    |>
    | ins_callt                             // Returned 0: retry fast path.
    |
    |// Reconstruct previous base for vmeta_call during tailcall.
    |->vm_call_tail:
    |<
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | ldbsm 2, PC, PC_RA, RB
    | addd 3, BASE, 0x0, RA
    | disp ctpr1, >3
    | nop 2
    |>
    |<
    | lddsm 3, RA, 0xfffffff0, TMP1
    | subdsm 4, 0x0, RB, RB
    | disp ctpr2, ->vmeta_call
    | nop 1
    |>
    |<
    | shldsm 3, RB, 0x3, TMP0
    | ct ctpr1, ~pred0
    |>
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    |<
    | addd 3, BASE, TMP0, BASE
    | sard 4, TMP1, 0x2f, ITYPE
    |>
    |<
    | cmpesb 3, ITYPE, LJ_TFUNC, pred0
    | nop 1
    |>
    |<
    | subd 3, BASE, 0x10, BASE              // base = base - (RB+2)*8
    | andd 4, TMP1, U64x(0x00007fff,0xffffffff), RB
    |>
    |<
    | addd 3, RA, 0x0, BASE, pred0
    | ct ctpr2, ~pred0
    |>
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |3:
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    |<
    | ldd 3, RA, 0xfffffff0, TMP1
    | addd 4, PC, 0x0, RB
    | nop 2
    |>
    |<
    | andd 3, RB, 0xfffffff8, RB
    | sard 4, TMP1, 0x2f, ITYPE
    |>
    |<
    | cmpesb 3, ITYPE, LJ_TFUNC, pred0
    | subd 4, BASE, RB, BASE
    | andd 5, TMP1, U64x(0x00007fff,0xffffffff), RB
    | nop 2
    |>
    |<
    | addd 3, RA, 0x0, BASE, pred0
    | ct ctpr2, ~pred0
    |>
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |5: // Grow stack for fallback handler.
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    |<
    | addd 0, 0x0, LUA_MINSTACK, CARG2
    | addd 3, RB, 0x0, CARG1
    | nop 3
    |>
    | call ctpr1, wbs = 0x8
    |<
    | addd 2, 0x0, 0x0, CRET1               // Simulate a return 0.
    | ldd 3, RB, L->base, BASE
    | disp ctpr2, <1                        // Dumb retry (goes through ff first).
    | nop 4
    |>
    | ct ctpr2
    |
    |//-----------------------------------------------------------------------
    |//-- Special dispatch targets -------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_record:                           // Dispatch target for recording phase.
    | do_fault
    |
    |->vm_rethook:                          // Dispatch target for return hooks.
    | ldb 0, DISPATCH, DISPATCH_GL(hookmask), RD
    | cmpandedb 0, RD, HOOK_ACTIVE, pred0
    | disp ctpr1, >5                        // Hook already active?
    | ct ctpr1, ~pred0
    | disp ctpr1, >1
    | ct ctpr1
    |
    |->vm_inshook:                          // Dispatch target for instr/line hooks.
    | ldb 0, DISPATCH, DISPATCH_GL(hookmask), RD
    | cmpandedb 0, RD, HOOK_ACTIVE, pred0
    | disp ctpr1, >5                        // Hook already active?
    | ct ctpr1, ~pred0
    | cmpandedb 0, RD, LUA_MASKLINE|LUA_MASKCOUNT, pred0
    | disp ctpr1, >5
    | ct ctpr1, pred0
    | ldw 0, DISPATCH, DISPATCH_GL(hookcount), TMP0
    | subd 0, TMP0, 0x1, TMP0
    | stw 2, DISPATCH, DISPATCH_GL(hookcount), TMP0
    | cmpedb 0, TMP0, 0x0, pred0
    | disp ctpr1, >1
    | ct ctpr1, pred0
    | cmpandedb 0, RD, LUA_MASKLINE, pred0
    | disp ctpr1, >5
    | ct ctpr1, pred0
    |1:
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | addd 0, PC, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
    | disp ctpr1, extern lj_dispatch_ins    // (lua_State *L, const BCIns *pc)
    | call ctpr1, wbs = 0x8
    |3:
    | ldd 0, RB, L->base, BASE
    |4:
    | ldb 0, PC, PC_RA, RA
    | shld 0, RA, 0x3, RA
    |5:
    | ldb 0, PC, PC_OP, TMP1
    | shld 0, TMP1, 0x3, TMP1
    | ldh 0, PC, PC_RD, RD
    | shrd 0, RD, 0x5, RB
    | shld 0, RD, 0x3, RD
    | andd 0, RB, 0x7f8, RB
    | andd 0, RD, 0x7f8, RC
    | addd 0, DISPATCH, TMP1, TMP1
    | ldd 0, TMP1, GG_DISP2STATIC, TMP1
    | movtd 0, TMP1, ctpr1
    | ct ctpr1
    |
    |->cont_hook:                           // Continue from hook yield.
    | do_fault
    |
    |->vm_callhook:                         // Dispatch target for call hooks.
    | std 2, STACK, SAVE_PC, PC
    |
    |->vm_hotcall:                          // Hot call counter underflow.
    | addd 0, BASE, RD, RD
    | subd 0, RD, 0x8, RD
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | std 2, RB, L->top, RD
    | addd 0, PC, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_dispatch_call   // (lua_State *L, const BCIns *pc)
    | call ctpr1, wbs = 0x8
    | // ASMFunction returned.
    | addd 0, 0x0, 0x0, TMP0
    | std 2, STACK, SAVE_PC, TMP0              // Invalidate for subsequent line hook.
    | ldd 0, RB, L->base, BASE
    | addd 0, CRET1, 0x0, RA
    | ldd 0, RB, L->top, RD
    | subd 0, RD, BASE, RD
    | movtd 0, RA, ctpr1
    | ldb 0, PC, PC_RA, RA
    | shld 0, RA, 0x3, RA
    | addd 0, RD, 0x8, RD
    | ct ctpr1
    |
    |->vm_profhook:                         // Dispatch target for profiler hook.
#if LJ_HASPROFILE
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | addd 0, PC, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_dispatch_profile // (lua_State *L, const BCIns *pc)
    | call ctpr1, wbs = 0x8
    | ldd 0, RB, L->base, BASE
    | // HOOK_PROFILE is off again, so re-dispatch to dynamic instruction.
    | subd 0, PC, 0x4, PC
    | ins_next
#endif
    |
    |//-----------------------------------------------------------------------
    |//-- Trace exit handler -------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    | // Unsupported
    |
    |//-----------------------------------------------------------------------
    |//-- Math helper functions ----------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |// FP value rounding. Called by math.floor/math.ceil fast functions.
    |.macro vm_round, name, mode
    |->name:
    |<
    | setwd wsz = 0x4, nfx = 0x1, dbl = 0x0
    | andd 0, RARG1, U64x(0x7fffffff,0xffffffff), RARG3 // |x|
    | disp ctpr1, >3
    |>
    |<
    | andd 0, RARG1, U64x(0x80000000,0x00000000), RARG2 // Isolate sign bit.
    | nop 2
    |>
    |<
    | fcmpnltdb 0, RARG3, U64x(0x43300000,0x00000000), pred1 // No truncation if |x| >= 2^52.
    | return ctpr3
    | nop 4
    |>
    | ct ctpr1, pred1
    |.if mode == 2                          // trunc(x)?
    |<
    | faddd 0, RARG3, U64x(0x43300000,0x00000000), RARG4 // (|x| + 2^52) - 2^52
    | nop 3
    |>
    |<
    | fsubd 0, RARG4, U64x(0x43300000,0x00000000), RARG4
    | nop 3
    |>
    |<
    | fcmpltdb 0, RARG3, RARG4, pred0       // |x| < result?
    | nop 3
    |>
    |<
    | fsubd 0, RARG4, U64x(0x3ff00000,0x00000000), RARG4, pred0 // if yes, substruct -1.
    | nop 3
    |>
    |<
    | ord 0, RARG4, RARG2, RARG4            // Merge sign bit back in.
    | nop 3
    |>
    |.else
    |<
    | faddd 0, RARG3, U64x(0x43300000,0x00000000), RARG4 // (|x| + 2^52) - 2^52
    | nop 3
    |>
    |<
    | fsubd 0, RARG4, U64x(0x43300000,0x00000000), RARG4
    | nop 3
    |>
    |<
    | ord 0, RARG4, RARG2, RARG4            // Merge sign bit back in.
    | nop 3
    |>
    | .if mode == 1                         // ceil(x)?
    |  addd 0, 0x0, U64x(0xbff00000,0x00000000), RARG2
    |<
    |  fcmpnledb 0, RARG1, RARG4, pred0     // x > result?
    |  nop 3
    |>
    | .else                                 // floor(x)?
    |  addd 0, 0x0, U64x(0x3ff00000,0x00000000), RARG2
    |<
    |  fcmpltdb 0, RARG1, RARG4, pred0      // x < result?
    |  nop 3
    |>
    | .endif
    |<
    | fsubd 0, RARG4, RARG2, RARG4, pred0   // If yes, substruct +-1.
    | nop 3
    |>
    |.endif
    |3:
    |<
    | addd 0, RARG4, 0x0, RRET1, ~pred1
    | ct ctpr3
    |>
    |.endmacro
    |
    | vm_round vm_floor, 0
    | vm_round vm_ceil,  1
    | vm_round vm_trunc, 2
    |
    |// modulo x%y. Called by BC_MOD* and vm_arith.
    |->vm_mod:
    | setwd wsz = 0x4, nfx = 0x1, dbl = 0x0
    | fdivd 5, RARG1, RARG2, RARG3
    | andd 0, RARG3, U64x(0x7fffffff,0xffffffff), RARG4 // |x/y|
    | fcmpnltdb 0, RARG4, U64x(0x43300000,0x00000000), pred0 // |x/y| >= 2^52
    | disp ctpr1, >2
    | ct ctpr1, pred0
    | andd 0, RARG3, U64x(0x80000000,0x00000000), RARG5 // Isolate sign bit.
    | faddd 0, RARG4, U64x(0x43300000,0x00000000), RARG4 // (|x/y| + 2^52) - 2^52
    | fsubd 0, RARG4, U64x(0x43300000,0x00000000), RARG4
    | ord 0, RARG4, RARG5, RARG4               // Merge sign bit back in.
    | fcmpltdb 0, RARG3, RARG4, pred0
    | disp ctpr1, >1                        // x/y < result?
    | ct ctpr1, ~pred0
    | fsubd 0, RARG4, U64x(0x3ff00000,0x00000000), RARG4 // If yes, subtract 1.0.
    |1:
    | fmuld 0, RARG2, RARG4, RARG2
    | fsubd 0, RARG1, RARG2, RRET1
    | return ctpr3
    | ct ctpr3
    |2:
    | fmuld 0, RARG2, RARG3, RARG2
    | fsubd 0, RARG1, RARG2, RRET1
    | return ctpr3
    | ct ctpr3
    |
    |//-----------------------------------------------------------------------
    |//-- Miscellaneous functions --------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |//-----------------------------------------------------------------------
    |//-- Assertions ---------------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->assert_bad_for_arg_type:
    | disp ctpr1, extern raise              // sigtrap
    | addd 0, 0x5, 0x0, CARG1
    | call ctpr1, wbs = 0x8
    |
    |//-----------------------------------------------------------------------
    |//-- FFI helper functions -----------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |// Handler for callback functions.
    |->vm_ffi_callback:
    |.if FFI
    | do_fault
    |.endif
    |
    |->cont_ffi_callback:                   // Return from FFI callback.
    |.if FFI
    | .type CTSTATE, CTState
    | disp ctpr1, extern lj_ccallback_leave // (CTState *cts, TValue *o)
    |<
    | ldd 0, STACK, SAVE_L, RA
    | addd 1, CRET1, 0x0, CARG2
    | ldd 2, DISPATCH, DISPATCH_GL(ctype_state), PC
    | nop 2
    |>
    |<
    | std 2, RA, L->base, BASE
    | std 5, PC, CTSTATE->L, RA
    |>
    |<
    | addd 1, PC, 0x0, CARG1
    | std 2, RA, L->top, RB
    | call ctpr1, wbs = 0x8
    |>
    |<
    | ldd 0, PC, CTSTATE->cb.gpr[0], RRET1
    | return ctpr3
    |>
    | ct ctpr3
    |.endif
    |
    |->vm_ffi_call:                         // Call C function via FFI.
    |.if FFI
    | .type CCSTATE, CCallState
    |<
    | setwd wsz = 0x8, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x4, rcur = 0x0
    | disp ctpr1, >2
    |>
    |<
    | ldw 0, RARG1, CCSTATE->spadj, RARG3
    | ldb 2, RARG1, CCSTATE->nsp, RARG5
    | disp ctpr2, >1
    | nop 2
    |>
    |<
    | subd 0, 0x0, RARG3, RARG3
    | subd 1, RARG5, 0x1, RARG5
    |>
    |<
    | getsp 0, RARG3, RARG4                 // allocate stack for parameters and return value
    | cmpldb 1, RARG5, 0x0, pred0
    | nop 2
    |>
    | // Copy stack slots.
    |<
    | shld 0, RARG5, 0x3, RARG5, ~pred0
    | ct ctpr1, pred0
    |>
    |1:
    |<
    | addd 0, RARG5, 0x40, RARG2
    | addd 1, RARG1, offsetof(CCallState, stack), RARG6
    |>
    |<
    | ldd 0, RARG6, RARG5, RARG6            // read stack parameters
    | subd 1, RARG5, 0x8, RARG5
    |>
    |<
    | cmpldb 0, RARG5, 0x0, pred0
    | nop 2
    |>
    |<
    | std 2, RARG4, RARG2, RARG6            // write to allocated stack
    | ct ctpr2, ~pred0
    |>
    |2: // wrire register parameters on stack too
    |<
    | ldd 0, RARG1, CCSTATE->gpr[0], CARG1
    | ldd 2, RARG1, CCSTATE->func, RARG2
    | ldd 3, RARG1, CCSTATE->gpr[1], CARG2
    | ldd 5, RARG1, CCSTATE->gpr[2], CARG3
    |>
    |<
    | ldd 0, RARG1, CCSTATE->gpr[3], CARG4
    | ldd 2, RARG1, CCSTATE->gpr[4], CARG5
    | ldd 3, RARG1, CCSTATE->gpr[5], CARG6
    |>
    |<
    | ldd 0, RARG1, CCSTATE->gpr[7], CARG8
    | ldd 2, RARG1, CCSTATE->gpr[6], CARG7
    |>
    |<
    | movtd 0, RARG2, ctpr1
    | std 2, RARG4, 0x0, CARG1
    | std 5, RARG4, 0x8, CARG2
    |>
    |<
    | std 2, RARG4, 0x10, CARG3
    | std 5, RARG4, 0x18, CARG4
    |>
    |<
    | std 2, RARG4, 0x20, CARG5
    | std 5, RARG4, 0x28, CARG6
    |>
    |<
    | std 2, RARG4, 0x30, CARG7
    | std 5, RARG4, 0x38, CARG8
    | call ctpr1, wbs = 0x4
    |>
    | // speculatively write from return regs, if result > 8*8 bytes, read all from stack
    |<
    | ldw 0, RARG1, CCSTATE->ret_size, RARG2
    | disp ctpr2, >3
    | nop 1
    |>
    | disp ctpr1, extern memcpy
    |<
    | cmpedb 0, RARG2, 0x0, pred0
    | nop 2
    |>
    |<
    | ldd 0, RARG1, CCSTATE->ret_stack, CARG1, ~pred0
    | addd 1, RARG2, 0x0, CARG3, ~pred0
    | addd 2, RARG4, 0x0, CARG2, ~pred0
    | ct ctpr2, pred0
    |>
    | call ctpr1, wbs = 0x4
    | return ctpr3
    | ct ctpr3
    |3:
    |<
    | stdsm 2, RARG1, CCSTATE->gpr[0], CRET1
    | stdsm 5, RARG1, CCSTATE->gpr[1], CRET2
    | return ctpr3
    |>
    |<
    | stdsm 2, RARG1, CCSTATE->gpr[2], CRET3
    | stdsm 5, RARG1, CCSTATE->gpr[3], CRET4
    |>
    |<
    | stdsm 2, RARG1, CCSTATE->gpr[4], CRET5
    | stdsm 5, RARG1, CCSTATE->gpr[5], CRET6
    |>
    |<
    | stdsm 2, RARG1, CCSTATE->gpr[6], CRET7
    | stdsm 5, RARG1, CCSTATE->gpr[7], CRET8
    | ct ctpr3
    |>
    |.endif
    |//-----------------------------------------------------------------------
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
    int vk = 0;
    |=>defop:

    switch (op) {

    /* -- Comparison ops ---------------------------------------------------- */

    /* Remember: all ops branch for a true comparison, fall through otherwise. */

    case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
        | // ins_AD RA = src1*8, RD = src2*8, JMP with RD = target
        | // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
        |<
        | addd 0, PC, 0x4, CARG3
        | ldd 3, BASE, RA, RA
        | ldd 5, BASE, RD, RD
        | disp ctpr1, ->vmeta_comp
        | nop 1
        |>
        |<
        | ldh 0, CARG3, PC_RD, CARG2
        | subd 1, CARG3, BCBIAS_J*4, CARG1
        |>
        switch (op) {
        case BC_ISLT:
        |<
        | fcmpltdb 3, RA, RD, pred2
        | sard 4, RA, 0x2f, ITYPE
        | sard 5, RD, 0x2f, RB
        |>
          break;
        case BC_ISGE:
        |<
        | fcmpnltdb 3, RA, RD, pred2
        | sard 4, RA, 0x2f, ITYPE
        | sard 5, RD, 0x2f, RB
        |>
          break;
        case BC_ISLE:
        |<
        | fcmpledb 3, RA, RD, pred2
        | sard 4, RA, 0x2f, ITYPE
        | sard 5, RD, 0x2f, RB
        |>
          break;
        case BC_ISGT:
        |<
        | fcmpnledb 3, RA, RD, pred2
        | sard 4, RA, 0x2f, ITYPE
        | sard 5, RD, 0x2f, RB
        |>
          break;
        default: break;
        }
        |<
        | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
        | cmpbsb 4, RB, LJ_TISNUM, pred1
        | nop 2
        |>
        |<
        | shld 0, CARG2, 0x2, CARG2
        | pass pred0, p0
        | pass pred1, p1
        | pass pred2, p2
        | landp p0, p1, p4
        | pass p4, pred0
        | landp p4, p2, p5
        | landp p4, ~p2, p6
        | pass p5, pred1
        | pass p6, pred2
        |>
        |<
        | addd 0, CARG3, 0x0, PC, pred2
        | addd 1, CARG1, CARG2, PC, pred1
        | ct ctpr1, ~pred0
        |>
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        break;

    case BC_ISEQV: case BC_ISNEV:
        vk = op == BC_ISEQV;
        | // ins_AD RA = src1*8, RD = src2*8, JMP with RD = target
        |<
        | addd 0, PC, 0x4, PC
        | ldd 3, BASE, RD, RD
        | ldd 5, BASE, RA, RA
        | disp ctpr1, >3
        | nop 1
        |>
        |<
        | ldh 0, PC, PC_RD, CARG1
        | subd 2, PC, BCBIAS_J*4, CARG2
        |>
        |<
        | fcmpuoddb 3, RA, RD, pred2
        | fcmpeqdb 4, RA, RD, pred3
        | disp ctpr2, >2
        |>
        |<
        | sard 4, RA, 0x2f, ITYPE
        | sard 5, RD, 0x2f, RB
        | disp ctpr3, >1
        |>
        |<
        | shld 0, CARG1, 0x2, CARG1
        | cmpbsb 3, RB, LJ_TISNUM, pred0
        | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp p0, p1, p4
        | pass p4, pred0
        |>
        |<
        | pass pred2, p0
        | pass pred3, p1
        | landp ~p0, p1, p4
        | pass p4, pred1
        | ct ctpr1, ~pred0
        |>
        if (vk) {
        | ct ctpr2, ~pred1
        |1: // EQ: Branch to the target.
        | addd 0, CARG2, CARG1, PC
        |2: // NE: Fallthrough to next instruction.
        } else {
        | ct ctpr3, pred1
        |2: // NE: Branch to the target.
        | addd 0, CARG2, CARG1, PC
        |1: // EQ: Fallthrough to next instruction.
        }
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        |3: // Either or both types are not numbers.
        |.if FFI
        | disp ctpr1, ->vmeta_equal_cd
        |<
        | cmpesb 3, RB, LJ_TCDATA, pred0
        | cmpesb 4, ITYPE, LJ_TCDATA, pred1
        | nop 2
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred0
        |>
        | ct ctpr1, ~pred0
        |.endif
        |<
        | cmpbesb 1, RB, LJ_TISTABUD, pred2
        | cmpedb 3, RA, RD, pred0
        | cmpesb 4, RB, ITYPE, pred1
        | andd 5, RA, U64x(0x00007fff,0xffffffff), RA
        | disp ctpr1, ->vmeta_equal
        |>
        |<
        | lddsm 3, RA, TAB->metatable, RB
        | nop 1
        |>
        |<
        | pass pred1, p0
        | pass pred2, p1
        | landp p0, p1, p4
        | pass p4, pred1
        | ct ctpr3, pred0                   // Same GCobjs or pvalues?
        |>
        |<
        | ldbsm 3, RB, TAB->nomm, TMP0
        | cmpedbsm 4, RB, 0x0, pred0
        | ct ctpr2, ~pred1                  // Not the same type? or Different objects and not table/ud?
        |>
        | // Different tables or userdatas. Need to check __eq metamethod.
        | // Field metatable must be at same offset for GCtab and GCudata!
        |<
        | ct ctpr2, pred0                   // No metatable?
        | nop 1
        |>
        |<
        | cmpandedb 3, TMP0, 1<<MM_eq, pred0
        | nop 2
        |>
        | ct ctpr2, ~pred0                  //  Or 'no __eq' flag set?
        if (vk) {
        |<
        | addd 3, 0x0, 0x0, RB              // ne = 0
        | ct ctpr1                          // Handle __eq metamethod.
        |>
        } else {
        |<
        | addd 3, 0x0, 0x1, RB              // ne = 1
        | ct ctpr1                          // Handle __eq metamethod.
        |>
        }
        break;

    case BC_ISEQS: case BC_ISNES:
        vk = op == BC_ISEQS;
        | // ins_AND RA = src*8, RD = str_const*8, JMP with RD = target
        |<
        | addd 0, PC, 0x4, PC
        | ldd 3, BASE, RA, RA
        | subd 4, KBASE, RD, RD
        | disp ctpr1, >3
        |>
        |<
        | ldh 0, PC, PC_RD, CARG1
        | ldd 3, RD, 0xfffffff8, RD
        | disp ctpr2, >2
        |>
        |<
        | subd 0, PC, BCBIAS_J*4, CARG2
        | disp ctpr3, >1
        |>
        |<
        | sard 3, RA, 0x2f, ITYPE
        | andd 4, RA, U64x(0x00007fff,0xffffffff), RA
        |>
        |<
        | cmpesb 3, ITYPE, LJ_TSTR, pred1
        | cmpedb 4, RA, RD, pred0
        | nop 2
        |>
        |<
        | shld 0, CARG1, 0x2, CARG1
        | ct ctpr1, ~pred1
        |>
        if (vk) {
        | ct ctpr2, ~pred0
        |1: // EQ: Branch to the target.
        | addd 0, CARG2, CARG1, PC
        |2: // NE: Fallthrough to next instruction.
        |.if not FFI
        |3:
        |.endif
        } else {
        | ct ctpr3, pred0
        |.if not FFI
        |3:
        |.endif
        |2: // NE: Branch to the target.
        | addd 0, CARG2, CARG1, PC
        |1: // EQ: Fallthrough to next instruction.
        }
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        |.if FFI
        |3:
        |<
        | cmpesb 3, ITYPE, LJ_TCDATA, pred0
        | disp ctpr1, ->vmeta_equal_cd
        | nop 2
        |>
        | ct ctpr2, ~pred0
        | ct ctpr1
        |.endif
        break;

    case BC_ISEQN: case BC_ISNEN:
        vk = op == BC_ISEQN;
        | // ins_AD RA = src*8, RD = num_const*8, JMP with RD = target
        |<
        | addd 0, PC, 0x4, PC
        | ldd 3, BASE, RA, RA
        | ldd 5, KBASE, RD, RD
        | disp ctpr1, >3
        |>
        |<
        | ldh 0, PC, PC_RD, CARG1
        | subd 1, PC, BCBIAS_J*4, CARG2
        | disp ctpr3, >1
        |>
        |<
        | disp ctpr2, >2
        |>
        |<
        | fcmpuoddb 3, RD, RA, pred2
        | fcmpeqdb 4, RD, RA, pred3
        | sard 5, RA, 0x2f, ITYPE
        |>
        |<
        | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
        | nop 2
        |>
        |<
        | shld 0, CARG1, 0x2, CARG1
        | ct ctpr1, ~pred0
        | pass pred2, p0
        | pass pred3, p1
        | landp ~p0, p1, p4
        | pass p4, pred1
        |>
        if (vk) {
        | ct ctpr2, ~pred1
        |1: // EQ: Branch to the target.
        | addd 0, CARG2, CARG1, PC
        |2: // NE: Fallthrough to next instruction.
        |.if not FFI
        |3:
        |.endif
        } else {
        | ct ctpr3, pred1
        |.if not FFI
        |3:
        |.endif
        |2: // NE: Branch to the target.
        | addd 0, CARG2, CARG1, PC
        |1: // EQ: Fallthrough to next instruction.
        }
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        |.if FFI
        |3:
        |<
        | cmpesb 3, ITYPE, LJ_TCDATA, pred0
        | disp ctpr1, ->vmeta_equal_cd
        | nop 2
        |>
        | ct ctpr2, ~pred0
        | ct ctpr1
        |.endif
        break;

    case BC_ISEQP: case BC_ISNEP:
        vk = op == BC_ISEQP;
        | // ins_AND RA = src*8, RD = primitive_type*8 (~), JMP with RD = target
        |<
        | addd 0, PC, 0x4, PC
        | ldd 3, BASE, RA, RA
        | shrd 4, RD, 0x3, RD
        | disp ctpr1, ->vmeta_equal_cd
        |>
        |<
        | ldh 0, PC, PC_RD, CARG1
        | subd 1, PC, BCBIAS_J*4, CARG2
        | nop 1
        |>
        |<
        | xord 3, RD, 0xffffffff, RD
        | sard 4, RA, 0x2f, RA
        |>
        |<
        | shld 0, CARG1, 0x2, CARG1
        | cmpesb 3, RA, RD, pred0
        | cmpesb 4, RA, LJ_TCDATA, pred1
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, p1, p4
        | landp ~p0, ~p1, p5
        | pass p4, pred2
        | pass p5, pred1
        |>
        if (vk) {
        |<
        | ct ctpr1, pred2
        | addd 0, CARG2, CARG1, PC, pred0
        |>
        } else {
        |<
        | ct ctpr1, pred2
        | addd 0, CARG2, CARG1, PC, pred1
        |>
        }
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        break;

    /* -- Unary test and copy ops ------------------------------------------- */

    case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
        | // ins_AD RA = dst*8 or unused, RD = src*8, JMP with RD = target
        |<
        | addd 0, PC, 0x4, PC
        | ldd 3, BASE, RD, RD
        |>
        |<
        | ldh 0, PC, PC_RD, CARG1
        | subd 1, PC, BCBIAS_J*4, CARG2
        | nop 1
        |>
        |<
        | sard 3, RD, 0x2f, ITYPE
        |>
        |<
        | shld 0, CARG1, 0x2, CARG1
        | cmpbsb 3, ITYPE, LJ_TISTRUECOND, pred0
        | nop 1
        |>
        if (op == BC_IST || op == BC_ISTC) {
        | addd 0, CARG2, CARG1, PC, pred0
        } else {
        | addd 0, CARG2, CARG1, PC, ~pred0
        }
        if (op == BC_ISTC || op == BC_ISFC) {
        | std 5, BASE, RA, RD
        }
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        break;

    case BC_ISTYPE:
        | // ins_AD RA = src*8, RD = -type*8
        |<
        | ldwsm 0, PC, 0x0, TMP0
        | ldbsm 2, PC, 0x0, TMP1
        | ldd 3, BASE, RA, RB
        | disp ctpr1, ->vmeta_istype
        | nop 2
        |>
        |<
        | shldsm 2, TMP1, 0x3, TMP1
        | sard 3, RB, 0x2c, RB
        |>
        |<
        | lddsm 2, TMP1, DISPATCH, TMP1
        | andd 3, RB, U64x(0xffffffff,0xfffffff8), RB
        |>
        | addd 3, RB, RD, RB
        | cmpedb 3, RB, 0x0, pred0
        |<
        | movtdsm 0, TMP1, ctpr2
        | nop 1
        |>
        |<
        | addd 1, PC, 0x4, PC, pred0
        | shrd 3, TMP0, 0xd, RD, pred0
        | shrd 4, TMP0, 0x15, RB, pred0
        | shrd 5, TMP0, 0x5, RA, pred0
        | ct ctpr1, ~pred0
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr2
        |>
        break;

    case BC_ISNUM:
        | // ins_AD RA = src*8, RD = -(TISNUM-1)*8
        |<
        | ldwsm 0, PC, 0x0, TMP0
        | ldbsm 2, PC, 0x0, TMP1
        | ldd 3, BASE, RA, CARG1
        | disp ctpr2, ->vmeta_istype
        | nop 2
        |>
        |<
        | shldsm 2, TMP1, 0x3, TMP1
        | sard 3, CARG1, 0x2f, ITYPE
        |>
        |<
        | lddsm 2, TMP1, DISPATCH, TMP1
        | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
        | nop 2
        |>
        |<
        | movtdsm 0, TMP1, ctpr1
        | shrd 3, TMP0, 0xd, RD, pred0
        | shrd 4, TMP0, 0x15, RB, pred0
        | shrd 5, TMP0, 0x5, RA, pred0
        | ct ctpr2, ~pred0
        |>
        |<
        | addd 1, PC, 0x4, PC
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        break;

    /* -- Unary ops --------------------------------------------------------- */

    case BC_MOV:
        | // ins_AD RA = dst*8, RD = src*8
        |<
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, RD, CARG1
        | ldw 5, PC, 0x0, TMP0
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x5, RA
        | std 5, BASE, RA, CARG1
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | shrd 4, TMP0, 0x15, RB
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        |<
        | andd 3, RA, 0x7f8, RA
        | ct ctpr1
        |>
        break;

    case BC_NOT:
        | // ins_AD RA = dst*8, RD = src*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, RD, CARG2
        | addd 4, 0x0, 0x2, CARG1
        | addd 5, RA, 0x0, CARG3
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | sard 3, CARG2, 0x2f, CARG2
        | shrd 4, TMP0, 0xd, RD
        | shrd 5, TMP0, 0x15, RB
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | cmpbsb 3, CARG2, LJ_TISTRUECOND, pred0
        | shrd 4, TMP0, 0x5, RA
        | andd 5, RD, 0x7fff8, RD
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | subd 3, CARG1, 0x1, CARG1, pred0
        | andd 4, RB, 0x7f8, RB
        |>
        |<
        | shld 3, CARG1, 0x2f, CARG1
        | andd 4, RD, 0x7f8, RC
        |>
        |<
        | xord 3, CARG1, 0xffffffff, CARG1
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | std 5, BASE, CARG3, CARG1
        | ct ctpr1
        |>
        break;

    case BC_UNM:
        | // ins_AD RA = dst*8, RD = src*8
        |<
        | ldwsm 0, PC, 0x0, TMP0
        | ldbsm 2, PC, 0x0, TMP1
        | ldd 3, BASE, RD, CARG1
        | disp ctpr1, ->vmeta_unm
        | nop 2
        |>
        |<
        | shldsm 2, TMP1, 0x3, TMP1
        | sard 3, CARG1, 0x2f, ITYPE
        | xord 4, CARG1, U64x(0x80000000,0x00000000), CARG1
        | addd 5, RA, 0x0, CARG2
        |>
        |<
        | lddsm 2, TMP1, DISPATCH, TMP1
        | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
        | nop 2
        |>
        |<
        | movtdsm 0, TMP1, ctpr2
        | ct ctpr1, ~pred0
        |>
        |<
        | addd 1, PC, 0x4, PC
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | std 5, BASE, CARG2, CARG1
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr2
        |>
        break;

    case BC_LEN:
        | // ins_AD RA = dst*8, RD = src*8
        |<
        | ldd 3, BASE, RD, RD
        | ldwsm 0, PC, 0x0, TMP0
        | ldbsm 2, PC, 0x0, TMP1
        | disp ctpr1, >2
        |>
        |<
        | disp ctpr2, ->vmeta_len
        | nop 1
        |>
        |<
        | shldsm 2, TMP1, 0x3, TMP1
        | sard 3, RD, 0x2f, ITYPE
        | andd 4, RD, U64x(0x00007fff,0xffffffff), RD
        | addd 5, RA, 0x0, CARG4
        |>
        |<
        | ldwsm 0, RD, STR->len, CARG2
        | lddsm 2, TMP1, DISPATCH, TMP1
        | cmpesb 3, ITYPE, LJ_TSTR, pred0
        | cmpedb 4, ITYPE, LJ_TTAB, pred1
        | addd 5, RD, 0x0, CARG1
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred2
        |>
        | ct ctpr2, pred2
        |<
        | istofd 3, CARG2, CARG3
        | ct ctpr1, ~pred0
        |>
        |1:
        |<
        | movtd 0, TMP1, ctpr1
        | addd 1, PC, 0x4, PC
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | std 5, BASE, CARG4, CARG3
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        |2:
#if LJ_52
        |<
        | disp ctpr1, >4
        | ldd 3, RD, TAB->metatable, RB
        | nop 2
        |>
        |<
        | cmpedb 3, RB, 0x0, pred0
        | nop 2
        |>
        | ct ctpr1, ~pred0
        |3:
#endif
        |->BC_LEN_Z:
        |<
        | disp ctpr1, extern lj_tab_len     // (GCtab *t)
        | nop 4
        |>
        | call ctpr1, wbs = 0x8
        | // Length of table returned.
        |<
        | ldw 0, PC, 0x0, TMP0
        | istofd 1, CRET1, CARG3
        | ldb 2, PC, 0x0, TMP1
        | disp ctpr2, <1
        | nop 2
        |>
        |<
        | ldb 0, PC, PC_RA, CARG4
        | shld 1, TMP1, 0x3, TMP1
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | nop 1
        |>
        |<
        | shld 3, CARG4, 0x3, CARG4
        | ct ctpr2
        |>
#if LJ_52
        |4: // Check for __len.
        |<
        | ldb 3, RB, TAB->nomm, CARG5
        | disp ctpr1, <3
        | nop 2
        |>
        |<
        | cmpandedb 0, CARG5, 1<<MM_len, pred0
        | nop 2
        |>
        | ct ctpr1, ~pred0
        | ct ctpr2                          // 'no __len' flag NOT set: check.
#endif
        break;

    /* -- Binary ops -------------------------------------------------------- */

    |.macro ins_arith_opt, ins, ch
    || vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    || switch (vk) {
    ||  case 0:
    |<
    | ldbsm 2, PC, 0x0, CARG3
    | ldd 3, KBASE, RC, TMP1
    | addd 4, RA, 0x0, CARG1
    | ldd 5, BASE, RB, TMP0
    | disp ctpr1, ->vmeta_arith_vn
    |>
    | addd 3, PC, 0x0, CARG2
    | ldwsm 5, CARG2, 0x0, CARG5
    |<
    | shld 2, CARG3, 0x3, CARG3
    | sard 3, TMP0, 0x2f, ITYPE
    | ins ch, TMP0, TMP1, CARG2
    |>
    |<
    | lddsm 2, CARG3, DISPATCH, CARG3
    | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
    | nop 2
    |>
    ||   break;
    ||  case 1:
    |<
    | ldbsm 2, PC, 0x0, CARG3
    | ldd 3, KBASE, RC, TMP1
    | addd 4, RA, 0x0, CARG1
    | ldd 5, BASE, RB, TMP0
    | disp ctpr1, ->vmeta_arith_nv
    |>
    | addd 3, PC, 0x0, CARG2
    | ldwsm 5, CARG2, 0x0, CARG5
    |<
    | shld 2, CARG3, 0x3, CARG3
    | sard 3, TMP0, 0x2f, ITYPE
    | ins ch, TMP1, TMP0, CARG2
    |>
    |<
    | lddsm 2, CARG3, DISPATCH, CARG3
    | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
    | nop 2
    |>
    ||   break;
    ||  default:
    |<
    | ldbsm 2, PC, 0x0, CARG3
    | ldd 3, BASE, RC, TMP1
    | addd 4, RA, 0x0, CARG1
    | ldd 5, BASE, RB, TMP0
    | disp ctpr1, ->vmeta_arith_vv
    |>
    | addd 3, PC, 0x0, CARG2
    | ldwsm 5, CARG2, 0x0, CARG5
    |<
    | shld 0, CARG3, 0x3, CARG3
    | sard 3, TMP0, 0x2f, ITYPE
    | ins ch, TMP0, TMP1, CARG2
    |>
    |<
    | lddsm 2, CARG3, DISPATCH, CARG3
    | sard 3, TMP1, 0x2f, CARG4
    |>
    |<
    | cmpbsb 3, CARG4, LJ_TISNUM, pred1
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred0
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    ||  break;
    || }
    |<
    | movtd 0, CARG3, ctpr2
    | addd 1, PC, 0x4, PC, pred0
    |>
    |<
    | shrd 3, CARG5, 0xd, RD, pred0
    | shrd 4, CARG5, 0x15, RB, pred0
    | shrd 5, CARG5, 0x5, RA, pred0
    | ct ctpr1, ~pred0
    |>
    |<
    | andd 3, RD, 0x7fff8, RD
    | andd 4, RA, 0x7f8, RA
    |>
    |<
    | andd 3, RB, 0x7f8, RB
    | andd 4, RD, 0x7f8, RC
    | std 5, BASE, CARG1, CARG2
    | ct ctpr2
    |>
    |.endmacro

    case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        | ins_arith_opt faddd, 4
        break;

    case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        | ins_arith_opt fsubd, 4
        break;

    case BC_MULVN: case BC_MULNV: case BC_MULVV:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        | ins_arith_opt fmuld, 4
        break;

    case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        | ins_arith_opt fdivd, 5
        break;

    case BC_MODVN: case BC_MODNV: case BC_MODVV:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        switch (op) {
        case BC_MODVN:
        |<
        | ldwsm 0, PC, 0x0, TMP0
        | ldbsm 2, PC, 0x0, TMP1
        | ldd 3, BASE, RB, CARG1
        | ldd 5, KBASE, RC, CARG2
        | disp ctpr1, ->vmeta_arith_vn
        | nop 2
        |>
        |<
        | shldsm 2, TMP1, 0x3, TMP1
        | sard 3, CARG1, 0x2f, ITYPE
        | disp ctpr2, ->vm_mod
        |>
        |<
        | lddsm 2, TMP1, DISPATCH, TMP1
        | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
        | nop 2
        |>
        |<
        | ct ctpr1, ~pred0
        |>
          break;
        case BC_MODNV:
        |<
        | ldwsm 0, PC, 0x0, TMP0
        | ldbsm 2, PC, 0x0, TMP1
        | ldd 3, KBASE, RC, CARG1
        | ldd 5, BASE, RB, CARG2
        | disp ctpr1, ->vmeta_arith_nv
        | nop 2
        |>
        |<
        | shldsm 2, TMP1, 0x3, TMP1
        | sard 3, CARG2, 0x2f, ITYPE
        | disp ctpr2, ->vm_mod
        |>
        |<
        | lddsm 2, TMP1, DISPATCH, TMP1
        | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
        | nop 2
        |>
        | ct ctpr1, ~pred0
          break;
        case BC_MODVV:
        |<
        | ldwsm 0, PC, 0x0, TMP0
        | ldbsm 2, PC, 0x0, TMP1
        | ldd 3, BASE, RB, CARG1
        | ldd 5, BASE, RC, CARG2
        | disp ctpr1, ->vmeta_arith_vv
        | nop 2
        |>
        |<
        | shldsm 2, TMP1, 0x3, TMP1
        | sard 3, CARG1, 0x2f, ITYPE
        | sard 4, CARG2, 0x2f, CARG3
        | disp ctpr2, ->vm_mod
        |>
        |<
        | lddsm 2, TMP1, DISPATCH, TMP1
        | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
        | cmpbsb 4, CARG3, LJ_TISNUM, pred1
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp p0, p1, p4
        | pass p4, pred0
        |>
        | ct ctpr1, ~pred0
          break;
        default:
          break;
        }
        | call ctpr2, wbs = 0x8
        |<
        | movtd 0, TMP1, ctpr1
        | std 5, BASE, RA, CRET1
        |>
        |<
        | addd 1, PC, 0x4, PC
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        break;

    case BC_POW:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, RB, CARG1
        | ldd 5, BASE, RC, CARG2
        | disp ctpr2, ->vmeta_arith_vv
        | nop 1
        |>
        | disp ctpr1, extern pow
        |<
        | shld 2, TMP1, 0x3, TMP1
        | sard 3, CARG1, 0x2f, CARG3
        | sard 4, CARG2, 0x2f, ITYPE
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | cmpbsb 3, CARG3, LJ_TISNUM, pred0
        | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp p0, p1, p4
        | pass p4, pred0
        |>
        | ct ctpr2, ~pred0
        | call ctpr1, wbs = 0x8
        |<
        | movtd 0, TMP1, ctpr1
        | ldb 2, PC, PC_RA, CARG2
        |>
        |<
        | addd 1, PC, 0x4, PC
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | shld 0, CARG2, 0x3, CARG2
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        |<
        | std 5, BASE, CARG2, CRET1
        | ct ctpr1
        |>
        break;

    case BC_CAT:
        | // ins_ABC // RA = dst*8, RB = src_start*8, RC = src_end*8
        |<
        | ldd 0, STACK, SAVE_L, CARG1
        | addd 3, BASE, RC, CARG2
        | addd 4, RC, 0x0, CARG3
        |>
        | subd 3, CARG3, RB, CARG3
        |<
        | shrd 0, CARG3, 0x3, CARG3
        | std 2, CARG1, L->base, BASE
        |>
        |->BC_CAT_Z:
        | disp ctpr1, extern lj_meta_cat    // (lua_State *L, TValue *top, int left)
        |<
        | std 2, STACK, SAVE_PC, PC
        | addd 3, CARG1, 0x0, RB
        | nop 3
        |>
        | call ctpr1, wbs = 0x8
        | // NULL (finished) or TValue * (metamethod) returned.
        |<
        | ldwsm 0, PC, 0x0, TMP0
        | ldbsm 2, PC, 0x0, TMP1
        | ldb 3, PC, PC_RB, CARG2
        | ldb 5, PC, PC_RA, CARG3
        | disp ctpr2, ->vmeta_binop
        | nop 2
        |>
        |<
        | cmpedb 0, CRET1, 0x0, pred0
        | shldsm 2, TMP1, 0x3, TMP1
        | ldd 3, RB, L->base, BASE
        | shld 4, CARG2, 0x3, CARG2
        | shld 5, CARG3, 0x3, CARG3
        | nop 1
        |>
        |<
        | lddsm 2, TMP1, DISPATCH, TMP1
        | ct ctpr2, ~pred0
        |>
        |<
        | addd 1, PC, 0x4, PC
        | ldd 3, BASE, CARG2, CARG4
        | nop 1
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, BASE, CARG3, CARG4            // Copy result to Stk[RA] from Stk[RB].
        | ct ctpr1
        |>
        break;

    /* -- Constant ops ------------------------------------------------------ */

    case BC_KSTR:
        | // ins_AND RA = dst*8, RD = str_const*8 (~)
        |<
        | ldb 0, PC, 0x0, CARG2
        | addd 2, PC, 0x4, PC
        | ldw 3, PC, 0x0, CARG1
        | subd 4, KBASE, RD, TMP0
        | addd 5, RA, 0x0, CARG3
        | nop 1
        |>
        |<
        | ldd 3, TMP0, 0xfffffff8, TMP1
        | addd 4, 0x0, LJ_TSTR, ITYPE
        |>
        |<
        | shld 2, CARG2, 0x3, CARG2
        | shrd 3, CARG1, 0xd, RD
        | shrd 4, CARG1, 0x15, RB
        | shrd 5, CARG1, 0x5, RA
        |>
        |<
        | ldd 2, CARG2, DISPATCH, CARG2
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        | shld 3, ITYPE, 0x2f, ITYPE
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ord 5, TMP1, ITYPE, TMP1
        |>
        |<
        | movtd 0, CARG2, ctpr1
        | std 5, BASE, CARG3, TMP1
        |>
        | ct ctpr1
        break;

    case BC_KCDATA:
        |.if FFI
        | // ins_AND RA = dst*8, RD = cdata_const*8 (~)
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | subd 3, KBASE, RD, CARG1
        | addd 4, 0x0, LJ_TCDATA, ITYPE
        | addd 5, RA, 0x0, CARG2
        |>
        |<
        | ldd 3, CARG1, 0xfffffff8, CARG1
        | shld 4, ITYPE, 0x2f, ITYPE
        | nop 1
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | ord 3, CARG1, ITYPE, CARG1
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | std 5, BASE, CARG2, CARG1
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        |.endif
        break;

    case BC_KSHORT:
        | // ins_AD RA = dst*8, RD = int16_literal*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | shrd 3, RD, 0x3, CARG1
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | sxt 3, 0x1, CARG1, CARG1          // Sign-extend literal.
        | shrd 4, TMP0, 0xd, RD
        | addd 5, RA, 0x0, CARG2
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | idtofd 3, CARG1, CARG1
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        |<
        | std 5, BASE, CARG2, CARG1
        | ct ctpr1
        |>
        break;

    case BC_KNUM:
        | // ins_AD RA = dst*8, RD = num_const*8
        |<
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, KBASE, RD, CARG1
        | addd 4, RA, 0x0, CARG2
        | ldw 5, PC, 0x0, TMP0
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        |<
        | std 5, BASE, CARG2, CARG1
        | ct ctpr1
        |>
        break;

    case BC_KPRI:
        | // ins_AD RA = dst*8, RD = primitive_type*8 (~)
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | shld 3, RD, 0x2c, CARG1
        | addd 4, RA, 0x0, CARG2
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | xord 5, CARG1, 0xffffffff, CARG1
        |>
        |<
        | std 5, BASE, CARG2, CARG1
        | ct ctpr1
        |>
        break;

    case BC_KNIL:
        | // ins_AD RA = dst_start*8, RD = dst_end*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | addd 3, BASE, RA, RA
        | addd 4, BASE, RD, RD
        | addd 5, 0x0, LJ_TNIL, RB
        | disp ctpr1, >1
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | addd 3, RA, 0x8, RA
        |>
        | ldd 2, TMP1, DISPATCH, TMP1
        | std 5, RA, 0xfffffff8, RB         // Sets minimum 2 slots
        |1:
        |<
        | addd 3, RA, 0x8, RA
        | std 5, RA, 0x0, RB
        |>
        |<
        | cmpbedb 3, RA, RD, pred0
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr2
        | ct ctpr1, pred0
        |>
        |<
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr2
        |>
        break;

    /* -- Upvalue and function ops ------------------------------------------ */

    case BC_UGET:
        | // ins_AD RA = dst*8, RD = upvalue*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, 0xfffffff0, RB
        | addd 4, RA, 0x0, CARG4
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
        | shrd 4, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | addd 3, RB, RD, CARG1
        | shrd 4, TMP0, 0xd, RD
        | shrd 5, TMP0, 0x15, RB
        |>
        |<
        | ldd 3, CARG1, offsetof(GCfuncL, uvptr), CARG2
        | andd 4, RD, 0x7fff8, RD
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | ldd 3, CARG2, UPVAL->v, CARG1
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | ldd 3, CARG1, 0x0, CARG2
        | andd 4, RB, 0x7f8, RB
        | andd 5, RD, 0x7f8, RC
        | nop 2
        |>
        |<
        | std 5, BASE, CARG4, CARG2
        | ct ctpr1
        |>
        break;

    case BC_USETV:
#define TV2MARKOFS \
 ((int32_t)offsetof(GCupval, marked)-(int32_t)offsetof(GCupval, tv))
        | // ins_AD RA = upvalue*8, RD = src*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, 0xfffffff0, RB
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | ldd 3, BASE, RD, CARG5
        | addd 4, RB, RA, CARG2
        | shrd 5, TMP0, 0xd, RD
        |>
        |<
        | ldd 3, CARG2, offsetof(GCfuncL, uvptr), CARG6
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        | nop 2
        |>
        |<
        | ldb 3, CARG6, UPVAL->closed, CARG2
        | andd 4, RD, 0x7fff8, RD
        | ldd 5, CARG6, UPVAL->v, CARG6
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr3
        | ldbsm 3, CARG6, TV2MARKOFS, CARG1
        | cmpedb 4, CARG2, 0x0, pred0
        | andd 5, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | cmpandedbsm 3, CARG1, LJ_GC_BLACK, pred1
        | std 5, CARG6, 0x0, CARG5
        | nop 1
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred0
        |>
        |<
        | addd 2, DISPATCH, GG_DISP2G, CARG1
        | sard 3, CARG5, 0x2f, CARG4
        | andd 4, CARG5, U64x(0x00007fff,0xffffffff), CARG5
        | addd 5, CARG6, 0x0, CARG2
        | ct ctpr3, ~pred0                  // isblack(uv)?
        |>
        |<
        | ldbsm 3, CARG5, GCOBJ->gch.marked, CARG3
        | subs 4, CARG4, LJ_TISGCV, CARG4
        | nop 1
        |>
        | disp ctpr1, extern lj_gc_barrieruv // (global_State *g, TValue *tv)
        |<
        | cmpbesb 3, CARG4, LJ_TNUMX - LJ_TISGCV, pred0
        | cmpandedbsm 4, CARG3, LJ_GC_WHITES, pred1
        | nop 1
        |>
        |<
        | pass pred0, p0                    // tvisgcv(v)
        | pass pred1, p1                    // iswhite(v)
        | landp ~p0, ~p1, p4
        | pass p4, pred0
        |>
        | ct ctpr3, ~pred0
        | // Crossed a write barrier. Move the barrier forward.
        | call ctpr1, wbs = 0x8
        | movtd 0, TMP1, ctpr3
        | ct ctpr3
        break;
#undef TV2MARKOFS

    case BC_USETS:
        | // ins_AND RA = upvalue*8, RD = str_const*8 (~)
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, 0xfffffff0, CARG4
        | subd 4, KBASE, RD, CARG2
        | addd 5, 0x0, LJ_TSTR, ITYPE
        |>
        |<
        | ldd 3, CARG2, 0xfffffff8, CARG3
        | shld 4, ITYPE, 0x2f, ITYPE
        | nop 1
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | andd 3, CARG4, U64x(0x00007fff,0xffffffff), CARG4
        | shrd 4, TMP0, 0xd, RD
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | addd 3, CARG4, RA, CARG1
        | shrd 4, TMP0, 0x5, RA
        | shrd 5, TMP0, 0x15, RB
        |>
        |<
        | ldd 3, CARG1, offsetof(GCfuncL, uvptr), CARG4
        | ord 4, ITYPE, CARG3, ITYPE
        | andd 5, RD, 0x7fff8, RD
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr3
        | ldd 3, CARG4, UPVAL->v, CARG5
        | andd 4, RA, 0x7f8, RA
        | ldb 5, CARG4, UPVAL->marked, CARG6
        | nop 1
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        |<
        | cmpandedb 3, CARG6, LJ_GC_BLACK, pred0
        | std 5, CARG5, 0x0, ITYPE
        |>
        |1:
        | ct ctpr3, pred0                   // isblack(uv)?
        |// Check if string is white and ensure upvalue is closed.
        |<
        | addd 2, DISPATCH, GG_DISP2G, CARG1
        | ldb 3, CARG3, GCOBJ->gch.marked, CARG3
        | addd 4, CARG5, 0x0, CARG2
        | ldbsm 5, CARG4, UPVAL->closed, CARG6
        | nop 1
        |>
        | disp ctpr1, extern lj_gc_barrieruv // (global_State *g, TValue *tv)
        |<
        | cmpandedb 3, CARG3, LJ_GC_WHITES, pred0
        | cmpedbsm 4, CARG6, 0x0, pred1
        | nop 1
        |>
        |<
        | pass pred0, p0                    // iswhite(str)?
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred0
        |>
        | ct ctpr3, ~pred0
        | // Crossed a write barrier. Move the barrier forward.
        | call ctpr1, wbs = 0x8
        | movtd 0, TMP1, ctpr3
        | ct ctpr3
        break;

    case BC_USETN:
        | // ins_AD RA = upvalue*8, RD = num_const*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, 0xfffffff0, CARG2
        | ldd 5, KBASE, RD, CARG1
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | andd 3, CARG2, U64x(0x00007fff,0xffffffff), CARG2
        | shrd 4, TMP0, 0xd, RD
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | addd 3, CARG2, RA, CARG3
        | shrd 4, TMP0, 0x5, RA
        | andd 5, RD, 0x7fff8, RD
        |>
        |<
        | ldd 3, CARG3, offsetof(GCfuncL, uvptr), CARG2
        | andd 4, RA, 0x7f8, RA
        | nop 1
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | shrd 3, TMP0, 0x15, RB
        |>
        |<
        | ldd 3, CARG2, UPVAL->v, CARG3
        | nop 2
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, CARG3, 0x0, CARG1
        | ct ctpr1
        |>
        break;

    case BC_USETP:
        | // ins_AD RA = upvalue*8, RD = primitive_type*8 (~)
        |<
        | ldw 0, PC, 0x0, TMP0
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, 0xfffffff0, CARG1
        | shld 4, RD, 0x2c, CARG3
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | andd 3, CARG1, U64x(0x00007fff,0xffffffff), CARG1
        | xord 4, CARG3, 0xffffffff, CARG3
        | shrd 5, TMP0, 0xd, RD
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | addd 3, CARG1, RA, CARG2
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 3, CARG2, offsetof(GCfuncL, uvptr), CARG1
        | andd 4, RD, 0x7fff8, RD
        | nop 1
        |>
        | movtd 0, TMP1, ctpr1
        |<
        | ldd 3, CARG1, UPVAL->v, CARG2
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, CARG2, 0x0, CARG3
        | ct ctpr1
        |>
        break;

    case BC_UCLO:
        | // ins_AD RA = level*8, RD = target*8
        |<
        | subd 0, PC, BCBIAS_J*4, PC
        | shrd 1, RD, 0x1, RD
        | ldd 2, STACK, SAVE_L, RB
        | addd 3, BASE, RA, CARG2
        | disp ctpr2, >1
        |>
        | disp ctpr1, extern lj_func_closeuv // (lua_State *L, TValue *level)
        |<
        | ldw 0, PC, RD, TMP0
        | addd 1, PC, RD, PC
        | ldb 2, PC, RD, TMP1
        |>
        |<
        | ldd 0, RB, L->openupval, CARG3
        | addd 1, RB, 0x0, CARG1
        | addd 2, PC, 0x4, PC
        | nop 1
        |>
        |<
        | shld 1, TMP1, 0x3, TMP1
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | cmpedb 0, CARG3, 0x0, pred0
        | nop 2
        |>
        |<
        | ct ctpr2, pred0
        | std 2, RB, L->base, BASE
        |>
        | call ctpr1, wbs = 0x8
        | ldd 0, RB, L->base, BASE
        |1:
        |<
        | movtd 0, TMP1, ctpr2
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr2
        |>
        break;

    case BC_FNEW:
        | // ins_AND RA = dst*8, RD = proto_const*8 (~) (holding function prototype)
        | disp ctpr1, extern lj_func_newL_gc // (lua_State *L, GCproto *pt, GCfuncL *parent)
        |<
        | ldd 0, STACK, SAVE_L, RB
        | ldd 3, BASE, 0xfffffff0, CARG3
        | subd 4, KBASE, RD, TMP0
        | nop 1
        |>
        | ldd 3, TMP0, 0xfffffff8, CARG2       // Fetch GCproto *.
        |<
        | addd 0, RB, 0x0, CARG1
        | std 2, RB, L->base, BASE
        |>
        |<
        | std 2, STACK, SAVE_PC, PC
        | andd 3, CARG3, U64x(0x00007fff,0xffffffff), CARG3
        | call ctpr1, wbs = 0x8
        |>
        | // GCfuncL * returned.
        |<
        | ldb 0, PC, PC_RA, RA
        | ldb 2, PC, 0x0, TMP1
        | ldw 3, PC, 0x0, TMP0
        | ldd 5, RB, L->base, BASE
        | nop 2
        |>
        |<
        | shld 0, TMP1, 0x3, TMP1
        | shld 1, RA, 0x3, RA
        | addd 2, 0x0, LJ_TFUNC, ITYPE
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        |>
        |<
        | ldd 0, TMP1, DISPATCH, TMP1
        | shld 1, ITYPE, 0x2f, ITYPE
        | addd 2, PC, 0x4, PC
        | andd 3, RD, 0x7fff8, RD
        |>
        |<
        | ord 0, CRET1, ITYPE, CRET1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        |<
        | std 2, BASE, RA, CRET1
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 4, RA, 0x7f8, RA
        |>
        | ct ctpr1
        break;

    /* -- Table ops --------------------------------------------------------- */

    case BC_TNEW:
        | // ins_AD RA = dst*8, RD = (hbits|asize)*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, STACK, SAVE_L, RB
        | disp ctpr2, >1
        |>
        |<
        | ldd 0, DISPATCH, DISPATCH_GL(gc.total), CARG4
        | ldd 2, DISPATCH, DISPATCH_GL(gc.threshold), CARG5
        | nop 1
        |>
        | disp ctpr1, extern lj_gc_step_fixtop // (lua_State *L)
        |<
        | cmpbdb 0, CARG4, CARG5, pred0
        | shld 1, TMP1, 0x3, TMP1
        | std 2, STACK, SAVE_PC, PC
        | addd 3, RB, 0x0, CARG1
        | std 5, RB, L->base, BASE
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | nop 1
        |>
        |<
        | shrd 3, RD, 0x3, RD, pred0
        | ct ctpr2, pred0
        |>
        | call ctpr1, wbs = 0x8
        |<
        | ldh 3, PC, PC_RD, RD
        | nop 2
        |>
        |1:
        | disp ctpr1, extern lj_tab_new     // (lua_State *L, int32_t asize, uint32_t hbits)
        |<
        | shrd 3, RD, 0xb, CARG3
        | andd 4, RD, 0x7ff, CARG2
        | addd 5, RB, 0x0, CARG1
        |>
        |<
        | cmpedb 3, CARG2, 0x7ff, pred0
        | nop 1
        |>
        | addd 3, 0x0, 0x801, CARG2, pred0 // Turn 0x7ff into 0x801.
        | call ctpr1, wbs = 0x8
        | // Table * returned.
        |<
        | movtd 0, TMP1, ctpr3
        | addd 1, 0x0, LJ_TTAB, ITYPE
        | ldb 2, PC, PC_RA, CARG2
        | ldd 3, RB, L->base, BASE
        | shrd 4, TMP0, 0xd, RD
        | shrd 5, TMP0, 0x5, RA
        | nop 2
        |>
        |<
        | shld 0, CARG2, 0x3, CARG2
        | shld 1, ITYPE, 0x2f, ITYPE
        | addd 2, PC, 0x4, PC
        | shrd 3, TMP0, 0x15, RB
        |>
        |<
        | ord 0, CRET1, ITYPE, CRET1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, BASE, CARG2, CRET1
        | ct ctpr3
        |>
        break;

    case BC_TDUP:
        | // ins_AND RA = dst*8, RD = table_const*8 (~)
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, STACK, SAVE_L, RB
        | disp ctpr2, >1
        |>
        |<
        | ldd 0, DISPATCH, DISPATCH_GL(gc.total), CARG3
        | ldd 2, DISPATCH, DISPATCH_GL(gc.threshold), CARG4
        | nop 1
        |>
        | disp ctpr1, extern lj_gc_step_fixtop // (lua_State *L)
        |<
        | shld 1, TMP1, 0x3, TMP1
        | std 2, STACK, SAVE_PC, PC
        | addd 3, RB, 0x0, CARG1
        | std 5, RB, L->base, BASE
        |>
        |<
        | cmpbdb 0, CARG3, CARG4, pred0
        | ldd 2, TMP1, DISPATCH, TMP1
        | nop 2
        |>
        | ct ctpr2, pred0
        | call ctpr1, wbs = 0x8
        |<
        | ldh 3, PC, PC_RD, RD
        | nop 3
        |>
        | shld 3, RD, 0x3, RD
        |1:
        | disp ctpr1, extern lj_tab_dup     // (lua_State *L, Table *kt)
        |<
        | subd 3, KBASE, RD, CARG3
        | addd 4, RB, 0x0, CARG1
        |>
        |<
        | ldd 3, CARG3, 0xfffffff8, CARG2
        | nop 2
        |>
        | call ctpr1, wbs = 0x8
        |<
        | movtd 0, TMP1, ctpr3
        | addd 2, PC, 0x4, PC
        | ldd 3, RB, L->base, BASE
        | addd 4, 0x0, LJ_TTAB, ITYPE
        | ldb 5, PC, PC_RA, CARG2
        | nop 2
        |>
        |<
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | shld 3, CARG2, 0x3, CARG2
        | shld 4, ITYPE, 0x2f, ITYPE
        |>
        |<
        | ord 3, CRET1, ITYPE, CRET1
        | andd 4, RD, 0x7fff8, RD
        | andd 5, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, BASE, CARG2, CRET1
        | ct ctpr3
        |>
        break;

    case BC_GGET:
        | // ins_AND RA = dst*8, RD = str_const*8 (~)
        |<
        | ldb 2, PC, 0x0, CARG4
        | ldd 3, BASE, 0xfffffff0, RB
        | addd 4, 0x0, LJ_TSTR, CARG1
        | subd 5, KBASE, RD, TMP0
        | nop 1
        |>
        | ldw 3, PC, 0x0, CARG3
        |<
        | ldd 3, TMP0, 0xfffffff8, RC
        | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
        |>
        |<
        | shld 0, CARG4, 0x3, CARG4
        | ldd 3, RB, LFUNC->env, RB
        | shld 4, CARG1, 0x2f, CARG1
        | nop 2
        |>
        |<
        | ldw 3, RB, TAB->hmask, TMP0       // RB = GCtab *, RC = GCstr *
        | ldw 5, RC, STR->sid, TMP1
        |>
        |<
        | ldd 2, CARG4, DISPATCH, CARG4
        | ldd 3, RB, TAB->node, CARG2
        | nop 1
        |>
        |<
        | andd 4, TMP0, TMP1, TMP1          // idx = str->sid & tab->hmask
        |>
        |<
        | movtd 0, CARG4, ctpr3
        | shld 3, TMP1, 0x5, TMP0
        | shld 4, TMP1, 0x3, TMP1
        |>
        | subd 3, TMP0, TMP1, TMP1
        |<
        | addd 3, CARG2, TMP1, TMP0         // node = tab->node + (idx*32-idx*8)
        | ord 4, RC, CARG1, ITYPE
        |>
        |<
        | ldd 3, TMP0, NODE->key, TMP1
        | lddsm 5, TMP0, NODE->next, CARG5
        | nop 2
        |>
        |1:
        |<
        | disp ctpr2, <1
        | cmpedbsm 3, CARG5, 0x0, pred2
        | cmpedb 4, TMP1, ITYPE, pred3
        | lddsm 5, TMP0, NODE->val, CARG4    // Get node value.
        | nop 1
        |>
        |<
        | disp ctpr1, >2
        | pass pred3, p0
        | pass pred2, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred4
        | landp ~p0, p1, p5
        | pass p5, pred2
        |>
        |<
        | addd 3, CARG5, 0x0, TMP0, ~pred3   // Follow hash chain.
        | addd 4, CARG4, 0x0, ITYPE, pred3
        |>
        |<
        | ldd 3, TMP0, NODE->key, TMP1, pred4
        | cmpedbsm 4, ITYPE, LJ_TNIL, pred1
        | lddsm 5, TMP0, NODE->next, CARG5, pred4
        | nop 1
        |>
        | ct ctpr2, pred4
        |<
        | addd 3, 0x0, LJ_TNIL, ITYPE, pred2 // End of hash chain: key not found, nil result.
        | ct ctpr1, pred2
        |>
        |<
        | addd 2, PC, 0x4, PC, ~pred1
        | shrd 3, CARG3, 0xd, RD, ~pred1
        | shrd 4, CARG3, 0x15, RB, ~pred1
        | std 5, BASE, RA, ITYPE, ~pred1
        | ct ctpr1, pred1
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RB, 0x7f8, RB
        | shrd 5, CARG3, 0x5, RA
        |>
        |<
        | andd 4, RD, 0x7f8, RC
        | andd 5, RA, 0x7f8, RA
        | ct ctpr3
        |>
        |2:
        |<
        | disp ctpr1, ->vmeta_tgets
        | ldd 3, RB, TAB->metatable, TMP0   //  Check for __index if table value is nil
        | nop 2
        |>
        |<
        | ldbsm 3, TMP0, TAB->nomm, TMP1
        | cmpedb 4, TMP0, 0x0, pred0
        | nop 2
        |>
        | cmpandedbsm 4, TMP1, 1<<MM_index, pred1
        |<
        | pass pred0, p0                    // No metatable: done
        | pass pred1, p1                    // 'no __index' flag set: done.
        | landp ~p0, p1, p4
        | pass p4, pred0
        |>
        |<
        | addd 0, PC, 0x4, PC, ~pred0
        | shrd 3, CARG3, 0xd, RD, ~pred0
        | shrd 4, CARG3, 0x15, RB, ~pred0
        | std 5, BASE, RA, ITYPE, ~pred0
        | ct ctpr1, pred0
        |>
        |<
        | shrd 3, CARG3, 0x5, RA
        | andd 4, RB, 0x7f8, RB
        | andd 5, RD, 0x7fff8, RD
        |>
        |<
        | andd 3, RA, 0x7f8, RA
        | andd 4, RD, 0x7f8, RC
        | ct ctpr3
        |>
        break;

    case BC_GSET:
        | // ins_AND RA = src*8, RD = str_const*8 (~)
        |<
        | ldwsm 0, PC, 0x0, CARG5
        | ldbsm 2, PC, 0x0, CARG6
        | ldd 3, BASE, 0xfffffff0, RB
        | subd 4, KBASE, RD, TMP0
        | disp ctpr1, ->BC_TSETS_Z
        | nop 2
        |>
        |<
        | shldsm 2, CARG6, 0x3, CARG6
        | ldd 3, TMP0, 0xfffffff8, RC
        | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
        |>
        |<
        | ldd 0, RB, LFUNC->env, RB
        | lddsm 2, CARG6, DISPATCH, CARG6
        | nop 1
        |>
        | ct ctpr1
        break;

    case BC_TGETV:
        | // ins_ABC RA = dst*8, RB = table*8, RC = key*8
        |<
        | ldw 0, PC, 0x0, CARG3
        | ldb 2, PC, 0x0, CARG4
        | ldd 3, BASE, RB, RB
        | ldd 5, BASE, RC, RC
        | disp ctpr1, ->vmeta_tgetv
        | nop 2
        |>
        |<
        | fdtoistr 3, RC, TMP0
        | disp ctpr3, >1
        |>
        |<
        | sard 3, RB, 0x2f, CARG1
        | sard 4, RC, 0x2f, ITYPE
        | andd 5, RB, U64x(0x00007fff,0xffffffff), RB
        | disp ctpr2, >2
        |>
        | istofd 3, TMP0, TMP1
        |<
        | shld 2, CARG4, 0x3, CARG4
        | ldwsm 3, RB, TAB->asize, CARG2
        | fcmpeqdb 4, RC, TMP1, pred2       // Convert number to int and back and compare.
        | ldd 5, RB, TAB->array, CARG5
        |>
        |<
        | ldd 2, CARG4, DISPATCH, CARG4
        | cmpesb 3, CARG1, LJ_TTAB, pred0
        | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
        | nop 2
        |>
        | ct ctpr1, ~pred0
        | ct ctpr2, ~pred1                  // Integer key?
        |<
        | sxt 3, 0x2, TMP0, RC, pred2
        | ct ctpr1, ~pred2                  // Generic numeric key? Use fallback.
        |>
        |<
        | cmpbsb 3, RC, CARG2, pred0
        | shld 4, RC, 0x3, TMP1
        | nop 2
        |>
        |<
        | addd 3, TMP1, CARG5, RC, pred0
        | ct ctpr1, ~pred0
        |>
        |<
        | ldd 3, RC, 0x0, ITYPE
        | nop 2
        |>
        |<
        | cmpedb 0, ITYPE, LJ_TNIL, pred0
        | nop 2
        |>
        | ct ctpr3, ~pred0
        | // Check for __index if table value is nil.
        |<
        | ldd 3, RB, TAB->metatable, TMP0
        | nop 2
        |>
        |<
        | cmpedb 3, TMP0, 0x0, pred0
        | ldbsm 5, TMP0, TAB->nomm, TMP0
        | nop 2
        |>
        |<
        | cmpandedbsm 0, TMP0, 1<<MM_index, pred1
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, p1, p4
        | pass p4, pred0
        |>
        | ct ctpr1, pred0                   // 'no __index' flag NOT set: check.
        |1:
        |<
        | movtd 0, CARG4, ctpr1
        | std 5, BASE, RA, ITYPE
        |>
        |<
        | addd 1, PC, 0x4, PC
        | shrd 3, CARG3, 0xd, RD
        | shrd 4, CARG3, 0x15, RB
        | shrd 5, CARG3, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        |2: // String key?
        |<
        | cmpesb 3, ITYPE, LJ_TSTR, pred0
        | addd 4, 0x0, LJ_TSTR, CARG1
        | disp ctpr2, ->BC_TGETS_Z
        | nop 1
        |>
        |<
        | ldd 3, RB, TAB->node, CARG2
        | andd 4, RC, U64x(0x00007fff,0xffffffff), RC, pred0
        |>
        |<
        | ldw 3, RB, TAB->hmask, TMP0, pred0 // RB = GCtab *, RC = GCstr *
        | shld 4, CARG1, 0x2f, CARG1
        | ldw 5, RC, STR->sid, TMP1, pred0
        | ct ctpr1, ~pred0
        | nop 2
        |>
        |<
        | andd 4, TMP0, TMP1, TMP1   // idx = str->sid & tab->hmask
        | ct ctpr2
        |>
        break;

    case BC_TGETS:
        | // ins_ABC RA = dst*8, RB = table*8, RC = str_const*8 (~)
        |<
        | ldb 2, PC, 0x0, CARG4
        | ldd 3, BASE, RB, RB
        | addd 4, 0x0, LJ_TSTR, CARG1
        | subd 5, KBASE, RC, TMP0
        | disp ctpr1, ->vmeta_tgets
        | nop 2
        |>
        |<
        | ldd 3, TMP0, 0xfffffff8, RC
        | sard 4, RB, 0x2f, ITYPE
        | andd 5, RB, U64x(0x00007fff,0xffffffff), RB
        | nop 1
        |>
        |<
        | shld 0, CARG4, 0x3, CARG4
        | cmpesb 3, ITYPE, LJ_TTAB, pred0
        | shld 4, CARG1, 0x2f, CARG1
        | ldw 5, PC, 0x0, CARG3
        |>
        |<
        | ldw 3, RB, TAB->hmask, TMP0, pred0 // RB = GCtab *, RC = GCstr *
        | ldw 5, RC, STR->sid, TMP1, pred0
        |>
        |<
        | ldd 2, CARG4, DISPATCH, CARG4
        | ldd 3, RB, TAB->node, CARG2, pred0
        | nop 1
        |>
        |<
        | andd 4, TMP0, TMP1, TMP1, pred0   // idx = str->sid & tab->hmask
        | ct ctpr1, ~pred0
        |>
        |->BC_TGETS_Z:
        |<
        | movtd 0, CARG4, ctpr3
        | shld 3, TMP1, 0x5, TMP0
        | shld 4, TMP1, 0x3, TMP1
        |>
        | subd 3, TMP0, TMP1, TMP1
        |<
        | addd 3, CARG2, TMP1, TMP0         // node = tab->node + (idx*32-idx*8)
        | ord 4, RC, CARG1, ITYPE
        |>
        |<
        | ldd 3, TMP0, NODE->key, TMP1
        | lddsm 5, TMP0, NODE->next, CARG5
        | nop 2
        |>
        |1:
        |<
        | disp ctpr2, <1
        | cmpedbsm 3, CARG5, 0x0, pred2
        | cmpedb 4, TMP1, ITYPE, pred3
        | lddsm 5, TMP0, NODE->val, CARG4    // Get node value.
        | nop 1
        |>
        |<
        | disp ctpr1, >2
        | pass pred3, p0
        | pass pred2, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred4
        | landp ~p0, p1, p5
        | pass p5, pred2
        |>
        |<
        | addd 3, CARG5, 0x0, TMP0, ~pred3   // Follow hash chain.
        | addd 4, CARG4, 0x0, ITYPE, pred3
        |>
        |<
        | ldd 3, TMP0, NODE->key, TMP1, pred4
        | cmpedbsm 4, ITYPE, LJ_TNIL, pred1
        | lddsm 5, TMP0, NODE->next, CARG5, pred4
        | nop 1
        |>
        | ct ctpr2, pred4
        |<
        | addd 3, 0x0, LJ_TNIL, ITYPE, pred2 // End of hash chain: key not found, nil result.
        | ct ctpr1, pred2
        |>
        |<
        | addd 0, PC, 0x4, PC, ~pred1
        | shrd 3, CARG3, 0xd, RD, ~pred1
        | shrd 4, CARG3, 0x15, RB, ~pred1
        | std 5, BASE, RA, ITYPE, ~pred1
        | ct ctpr1, pred1
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RB, 0x7f8, RB
        | shrd 5, CARG3, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7f8, RC
        | andd 4, RA, 0x7f8, RA
        | ct ctpr3
        |>
        |2:
        |<
        | disp ctpr1, ->vmeta_tgets
        | ldd 3, RB, TAB->metatable, TMP0   //  Check for __index if table value is nil
        | nop 2
        |>
        |<
        | ldbsm 3, TMP0, TAB->nomm, TMP1
        | cmpedb 4, TMP0, 0x0, pred0
        | nop 2
        |>
        | cmpandedbsm 4, TMP1, 1<<MM_index, pred1
        |<
        | pass pred0, p0                    // No metatable: done
        | pass pred1, p1                    // 'no __index' flag set: done.
        | landp ~p0, p1, p4
        | pass p4, pred0
        |>
        |<
        | addd 0, PC, 0x4, PC, ~pred0
        | shrd 3, CARG3, 0xd, RD, ~pred0
        | shrd 4, CARG3, 0x15, RB, ~pred0
        | std 5, BASE, RA, ITYPE, ~pred0
        | ct ctpr1, pred0
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | shrd 4, CARG3, 0x5, RA
        | andd 5, RB, 0x7f8, RB
        |>
        |<
        | andd 3, RA, 0x7f8, RA
        | andd 4, RD, 0x7f8, RC
        | ct ctpr3
        |>
        break;

    case BC_TGETB:
        | // ins_ABC RA = dst*8, RB = table*8, RC = index*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, RB, RB
        | sard 4, RC, 0x3, CARG2
        | disp ctpr1, ->vmeta_tgetb
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | sard 3, RB, 0x2f, ITYPE
        | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
        | addd 5, RA, 0x0, CARG6
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | ldwsm 3, RB, TAB->asize, CARG1
        | lddsm 5, RB, TAB->array, CARG3
        | nop 1
        |>
        |<
        | lddsm 3, RB, TAB->metatable, CARG4
        |>
        |<
        | cmpesb 3, ITYPE, LJ_TTAB, pred0
        | cmpbdbsm 4, CARG2, CARG1, pred1
        | nop 1
        |>
        |<
        | ldbsm 0, CARG4, TAB->nomm, CARG5
        | pass pred0, p0
        | pass pred1, p1
        | landp p0, p1, p4
        | pass p4, pred0
        |>
        |<
        | addd 3, RC, CARG3, RC, pred0
        | ct ctpr1, ~pred0
        |>
        | // Get array slot.
        |<
        | ldd 3, RC, 0x0, ITYPE
        | nop 1
        |>
        |<
        | movtd 0, TMP1, ctpr3
        | cmpedbsm 3, CARG4, 0x0, pred1     // Check for __index if table value is nil.
        |>
        |<
        | cmpedb 3, ITYPE, LJ_TNIL, pred0
        | cmpandedbsm 4, CARG5, 1<<MM_index, pred2
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | pass pred2, p2
        | landp p0, ~p1, p4
        | landp p4, p2, p5
        | pass p5, pred0
        |>
        |<
        | shrd 3, TMP0, 0xd, RD, ~pred0
        | shrd 4, TMP0, 0x15, RB, ~pred0
        | shrd 5, TMP0, 0x5, RA, ~pred0
        | ct ctpr1, pred0                   // 'no __index' flag NOT set: check.
        |>
        |<
        | addd 1, PC, 0x4, PC
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | std 5, BASE, CARG6, ITYPE
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr3
        |>
        break;

    case BC_TGETR:
        | // ins_ABC RA = dst*8, RB = table*8, RC = key*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, RB, RB
        | addd 4, RA, 0x0, CARG4
        | ldd 5, BASE, RC, RC
        | disp ctpr1, ->vmeta_tgetr
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
        | fdtoistr 4, RC, RC
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | ldw 3, RB, TAB->asize, CARG1
        | lddsm 5, RB, TAB->array, CARG2
        | nop 2
        |>
        |<
        | cmpbsb 3, RC, CARG1, pred0
        | nop 2
        |>
        |<
        | shls 3, RC, 0x3, CARG3, pred0
        | ct ctpr1, ~pred0                  // Not in array part? Use fallback.
        |>
        |<
        | movtd 0, TMP1, ctpr2
        | addd 1, PC, 0x4, PC
        | sxt 3, 0x2, CARG3, CARG3
        | shrd 4, TMP0, 0xd, RD
        | shrd 5, TMP0, 0x15, RB
        |>
        |<
        | addd 3, CARG2, CARG3, CARG3
        | shrd 4, TMP0, 0x5, RA
        |>
        |<
        | ldd 3, CARG3, 0x0, ITYPE          // Get array slot.
        | andd 4, RD, 0x7fff8, RD
        | andd 5, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, BASE, CARG4, ITYPE
        | ct ctpr2
        |>
        break;

    case BC_TSETV:
        | // ins_ABC RA = src*8, RB = table*8, RC = key*8
        |<
        | ldwsm 0, PC, 0x0, CARG5
        | ldbsm 2, PC, 0x0, CARG6
        | ldd 3, BASE, RB, RB
        | ldd 5, BASE, RC, RC
        | disp ctpr1, ->vmeta_tsetv
        | nop 2
        |>
        |<
        | sard 3, RB, 0x2f, CARG1
        | fdtoistr 4, RC, TMP0
        | andd 5, RB, U64x(0x00007fff,0xffffffff), RB
        | disp ctpr2, ->BC_TSETS_Z
        |>
        |<
        | cmpesb 3, CARG1, LJ_TTAB, pred0
        | istofd 4, TMP0, TMP1
        | sard 5, RC, 0x2f, ITYPE
        | disp ctpr3, >1
        |>
        |<
        | fcmpeqdb 3, RC, TMP1, pred2       // Integer key?  Convert number to int and back and compare.
        | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
        | ldwsm 5, RB, TAB->asize, CARG2
        | nop 1
        |>
        |<
        | lddsm 3, RB, TAB->array, CARG3
        | cmpesb 4, ITYPE, LJ_TSTR, pred3
        | lddsm 5, RB, TAB->metatable, TMP1
        | nop 1
        |>
        |<
        | shldsm 2, CARG6, 0x3, CARG6
        | pass pred0, p0
        | pass pred2, p1
        | pass pred3, p2
        | landp p0, p1, p4
        | landp p4, p2, p5
        | pass p5, pred0
        |>
        |<
        | lddsm 2, CARG6, DISPATCH, CARG6
        | ct ctpr1, ~pred0
        |>
        |<
        | andd 3, RC, U64x(0x00007fff,0xffffffff), RC, ~pred1
        | ct ctpr2, ~pred1                  // String key?
        | sxt 4, 0x2, TMP0, RC, pred2
        | ldbsm 5, RB, TAB->marked, CARG1
        |>
        |<
        | cmpbsb 3, RC, CARG2, pred0
        | shld 4, RC, 0x3, RC
        | ldbsm 5, TMP1, TAB->nomm, CARG4
        | disp ctpr2, >2
        | nop 2
        |>
        |<
        | cmpedbsm 3, TMP1, 0x0, pred1
        | cmpandedbsm 4, CARG4, 1<<MM_newindex, pred2 // 'no __newindex' flag NOT set: check.
        | addd 5, RC, CARG3, RC, pred0
        | ct ctpr1, ~pred0
        |>
        |<
        | ldw 3, RC, 0x0, TMP0
        | nop 2
        |>
        |<
        | cmpesb 3, TMP0, LJ_TNIL, pred0    // Previous value is nil?
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | pass pred2, p2
        | landp p0, ~p1, p4
        | landp p4, p2, p5
        | pass p5, pred0
        |>
        |<
        | cmpandedbsm 3, CARG1, LJ_GC_BLACK, pred1 // isblack(table)
        | ct ctpr1, pred0
        |>
        |<
        | movtd 0, CARG6, ctpr1
        | ct ctpr2, ~pred1
        |>
        |1:                                 // Set array slot
        |<
        | addd 1, PC, 0x4, PC
        | ldd 3, BASE, RA, CARG1
        | shrd 4, CARG5, 0xd, RD
        | shrd 5, CARG5, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | addd 3, RC, 0x0, CARG2
        | shrd 4, CARG5, 0x15, RB
        | andd 5, RD, 0x7f8, RC
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | std 5, CARG2, 0x0, CARG1
        | ct ctpr1
        |>
        |2: // Possible table write barrier for the value. Skip valiswhite check.
        |<
        | ldd 0, DISPATCH, DISPATCH_GL(gc.grayagain), TMP1
        | ldb 3, RB, TAB->marked, TMP0
        | nop 2
        |>
        |<
        | std 2, DISPATCH, DISPATCH_GL(gc.grayagain), RB
        | andd 3, TMP0, ~LJ_GC_BLACK, TMP0  // black2gray(tab)
        | std 5, RB, TAB->gclist, TMP1
        |>
        |<
        | stb 5, RB, TAB->marked, TMP0
        | ct ctpr3
        |>
        break;

    case BC_TSETS:
        | // ins_ABC  RA = src*8, RB = table*8, RC = str_const*8 (~)
        |<
        | ldwsm 0, PC, 0x0, CARG5
        | ldbsm 2, PC, 0x0, CARG6
        | ldd 3, BASE, RB, RB
        | subd 4, KBASE, RC, TMP0
        | disp ctpr1, ->vmeta_tsets
        |>
        |<
        | ldd 3, TMP0, 0xfffffff8, RC
        | nop 1
        |>
        |<
        | shldsm 2, CARG6, 0x3, CARG6
        | sard 3, RB, 0x2f, ITYPE
        | cmpesb 4, ITYPE, LJ_TTAB, pred0
        | nop 2
        |>
        |<
        | lddsm 2, CARG6, DISPATCH, CARG6
        | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
        | ct ctpr1, ~pred0
        |>
        |->BC_TSETS_Z:
        | // RB = GCtab *, RC = GCstr *
        |<
        | ldw 3, RB, TAB->hmask, TMP0
        | addd 4, 0x0, LJ_TSTR, ITYPE
        | ldw 5, RC, STR->sid, TMP1
        | disp ctpr1, >1
        |>
        |<
        | shld 4, ITYPE, 0x2f, ITYPE
        | ldd 5, RB, TAB->node, CARG2
        | disp ctpr2, >2
        | nop 1
        |>
        |<
        | andd 3, TMP0, TMP1, TMP1          // idx = str->sid & tab->hmask
        | ord 4, ITYPE, RC, ITYPE
        |>
        |<
        | smulx 3, TMP1, #NODE, TMP0
        | addd 4, 0x0, 0x0, CARG1
        | nop 3
        |>
        |<
        | addd 3, CARG2, TMP0, TMP0
        | stb 5, RB, TAB->nomm, CARG1       // Clear metamethod cache.
        | disp ctpr3, ->vmeta_tsets
        |>
        |<
        | ldd 3, TMP0, NODE->key, TMP1
        | lddsm 5, TMP0, NODE->next, CARG1
        | nop 2
        |>
        |1:
        |<
        | lddsm 0, DISPATCH, DISPATCH_GL(gc.grayagain), CARG7
        | cmpedb 3, TMP1, ITYPE, pred0
        | cmpedbsm 4, CARG1, 0x0, pred1
        | lddsm 5, RB, TAB->metatable, CARG3
        | nop 1
        |>
        |<
        | ldbsm 3, RB, TAB->marked, CARG2
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | landp ~p0, p1, p5
        | pass p4, pred2
        | pass p5, pred3
        |>
        |<
        | ldd 3, CARG1, NODE->key, TMP1, pred2
        | addd 4, CARG1, 0x0, TMP0, pred2
        | ldd 5, TMP0, 0x0, TMP1, ~pred2
        |>
        |<
        | ldbsm 3, CARG3, TAB->nomm, CARG4
        | lddsm 5, TMP0, NODE->next, CARG1, pred2
        | ct ctpr1, pred2
        | nop 2
        |>
        |<
        | cmpedb 3, TMP1, LJ_TNIL, pred0
        | cmpedb 4, CARG3, 0x0, pred1
        | anddsm 5, CARG2, ~LJ_GC_BLACK, CARG2 // black2gray(tab)
        | ct ctpr2, pred3
        |>
        |<
        | movtdsm 0, CARG6, ctpr1
        | cmpandedbsm 3, CARG4, 1<<MM_newindex, pred2
        | ldbsm 5, RB, TAB->marked, TMP1
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | pass pred2, p2
        | landp p0, ~p1, p4
        | landp p4, p2, p5
        | pass p5, pred0
        |>
        |// Possible table write barrier for the value. Skip valiswhite check.
        |<
        | cmpandedb 3, TMP1, LJ_GC_BLACK, pred1
        | ct ctpr3, pred0                   // 'no __newindex' flag NOT set: check.
        |>
        |<
        | ldd 0, BASE, RA, ITYPE
        | addd 1, PC, 0x4, PC
        | shrd 3, CARG5, 0xd, RD
        | shrd 4, CARG5, 0x5, RA
        | addd 5, RB, 0x0, TMP1
        |>
        |<
        | std 2, DISPATCH, DISPATCH_GL(gc.grayagain), TMP1, ~pred1
        | shrd 4, CARG5, 0x15, RB
        | stb 5, TMP1, TAB->marked, CARG2, ~pred1
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | std 5, TMP1, TAB->gclist, CARG7, ~pred1
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, TMP0, 0x0, ITYPE           // Set node value.
        | ct ctpr1
        |>
        |2:
        | // End of hash chain: key not found, add a new one.
        | // But check for __newindex first.
        |<
        | ldd 0, STACK, SAVE_L, CARG1
        | addd 1, DISPATCH, DISPATCH_GL(tmptv), CARG3
        | ldd 3, RB, TAB->metatable, TMP0
        | nop 1
        |>
        | disp ctpr1, extern lj_tab_newkey  // (lua_State *L, GCtab *t, TValue *k)
        |<
        | addd 0, RB, 0x0, CARG2
        | ldbsm 3, TMP0, TAB->nomm, TMP1
        | cmpedb 4, TMP0, 0x0, pred0
        | nop 2
        |>
        |<
        | cmpandedbsm 0, TMP1, 1<<MM_newindex, pred1
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, p1, p4
        | pass p4, pred0
        |>
        |<
        | ct ctpr3, pred0                   // 'no __newindex' flag NOT set: check.
        | std 2, CARG1, L->base, BASE
        |>
        |<
        | std 2, CARG3, 0x0, ITYPE
        | std 5, STACK, SAVE_PC, PC
        | call ctpr1, wbs = 0x8
        |>
        | // Handles write barrier for the new key. TValue * returned.
        |<
        | ldd 0, STACK, SAVE_L, TMP1
        | addd 1, CRET1, 0x0, TMP0
        | ldb 2, PC, 0x0, CARG6
        | ldw 3, PC, 0x0, CARG5
        | ldb 5, PC, PC_RA, RA
        | nop 2
        |>
        |<
        | ldbsm 0, RB, TAB->marked, CARG2
        | shld 2, CARG6, 0x3, CARG6
        | ldd 3, TMP1, L->base, BASE
        | ldb 5, RB, TAB->marked, CARG1     // Must check write barrier for value.
        | nop 1
        |>
        |<
        | ldd 0, DISPATCH, DISPATCH_GL(gc.grayagain), CARG3
        | addd 1, PC, 0x4, PC
        | ldd 2, CARG6, DISPATCH, CARG6
        | shld 3, RA, 0x3, RA
        |>
        |<
        | ldd 3, BASE, RA, ITYPE
        | cmpandedb 4, CARG1, LJ_GC_BLACK, pred0
        | shrd 5, CARG5, 0xd, RD
        | nop 2
        |>
        |<
        | movtd 0, CARG6, ctpr1
        | andd 1, CARG2, ~LJ_GC_BLACK, CARG2 // black2gray(tab)
        | std 2, DISPATCH, DISPATCH_GL(gc.grayagain), RB, ~pred0
        | shrd 3, CARG5, 0x5, RA
        |>
        |<
        | std 2, RB, TAB->gclist, CARG3, ~pred0
        | shrd 4, CARG5, 0x15, RB
        | stb 5, RB, TAB->marked, CARG2, ~pred0
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, TMP0, 0x0, ITYPE
        | ct ctpr1
        |>
        break;

    case BC_TSETB:
        | // ins_ABC RA = src*8, RB = table*8, RC = byte_literal*8
        |<
        | ldwsm 0, PC, 0x0, CARG5
        | ldbsm 2, PC, 0x0, CARG6
        | ldd 3, BASE, RB, RB
        | disp ctpr1, ->vmeta_tsetb
        | nop 2
        |>
        |<
        | sard 3, RB, 0x2f, ITYPE
        | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
        | disp ctpr2, >2
        |>
        |<
        | ldwsm 3, RB, TAB->asize, TMP1
        | cmpesb 4, ITYPE, LJ_TTAB, pred0
        | lddsm 5, RB, TAB->array, TMP0
        | disp ctpr3, >1
        | nop 1
        |>
        |<
        | lddsm 3, RB, TAB->metatable, CARG2
        | ldbsm 5, RB, TAB->marked, CARG4
        |>
        |<
        | shld 3, TMP1, 0x3, TMP1, pred0
        | ct ctpr1, ~pred0
        |>
        |<
        | cmpbdb 3, RC, TMP1, pred0
        | nop 2
        |>
        |<
        | shldsm 2, CARG6, 0x3, CARG6
        | cmpedbsm 3, CARG2, 0x0, pred1
        | addd 4, RC, TMP0, RC, pred0
        | ldbsm 5, CARG2, TAB->nomm, CARG3
        | ct ctpr1, ~pred0
        |>
        |<
        | lddsm 2, CARG6, DISPATCH, CARG6
        | ldd 3, RC, 0x0, TMP0
        | cmpandedbsm 4, CARG4, LJ_GC_BLACK, pred3
        | nop 2
        |>
        |<
        | cmpedb 3, TMP0, LJ_TNIL, pred0    // Previous value is nil?
        | cmpandedbsm 4, CARG3, 1<<MM_newindex, pred2 // 'no __newindex' flag NOT set: check.
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | pass pred2, p2
        | landp p0, ~p1, p4
        | landp p4, p2, p5
        | pass p5, pred0
        |>
        | ct ctpr1, pred0
        | ct ctpr2, ~pred3                  // isblack(table)?
        |1: // Set array slot.
        |<
        | movtd 0, CARG6, ctpr1
        | addd 1, PC, 0x4, PC
        | ldd 3, BASE, RA, ITYPE
        | shrd 4, CARG5, 0xd, RD
        | shrd 5, CARG5, 0x15, RB
        |>
        |<
        | shrd 3, CARG5, 0x5, RA
        | addd 4, RC, 0x0, CARG1
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, CARG1, 0x0, ITYPE
        | ct ctpr1
        |>
        |2: // Possible table write barrier for the value. Skip valiswhite check.
        |<
        | ldd 0, DISPATCH, DISPATCH_GL(gc.grayagain), TMP1
        | ldb 3, RB, TAB->marked, CARG1
        | nop 2
        |>
        |<
        | std 2, DISPATCH, DISPATCH_GL(gc.grayagain), RB
        | andd 3, CARG1, ~LJ_GC_BLACK, CARG1 // black2gray(tab)
        | std 5, RB, TAB->gclist, TMP1
        |>
        |<
        | stb 5, RB, TAB->marked, CARG1
        | ct ctpr3
        |>
        break;

    case BC_TSETR:
        | // ins_ABC RA = src*8, RB = table*8, RC = key*8
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, RB, RB
        | ldd 5, BASE, RC, RC
        | disp ctpr1, ->vmeta_tsetr
        | nop 2
        |>
        |<
        | ldd 0, DISPATCH, DISPATCH_GL(gc.grayagain), CARG3
        | shld 2, TMP1, 0x3, TMP1
        | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
        | fdtoistr 4, RC, RC
        | lddsm 5, RB, TAB->array, CARG5
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | ldb 3, RB, TAB->marked, CARG1
        | ldbsm 5, RB, TAB->marked, CARG2
        | nop 2
        |>
        |<
        | cmpandedb 3, CARG1, LJ_GC_BLACK, pred0
        | anddsm 4, CARG2, ~LJ_GC_BLACK, CARG2 // black2gray(tab)
        | ldwsm 5, RB, TAB->asize, CARG4
        | nop 1
        |>
        |<
        | movtd 0, TMP1, ctpr2
        | std 2, DISPATCH, DISPATCH_GL(gc.grayagain), RB, ~pred0
        | stb 5, RB, TAB->marked, CARG2, ~pred0
        |>
        |<
        | ldd 3, BASE, RA, ITYPE
        | cmpbsbsm 4, RC, CARG4, pred1
        | std 5, RB, TAB->gclist, CARG3, ~pred0
        |>
        |<
        | shls 3, RC, 0x3, CARG1
        | shrd 4, TMP0, 0x5, RA, pred1
        | ct ctpr1, ~pred1
        |>
        |<
        | addd 2, PC, 0x4, PC
        | sxt 3, 0x2, CARG1, CARG1
        | shrd 4, TMP0, 0xd, RD
        | andd 5, RA, 0x7f8, RA
        |>
        |<
        | addd 3, CARG5, CARG1, CARG1
        | shrd 4, TMP0, 0x15, RB
        | andd 5, RD, 0x7fff8, RD
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | std 5, CARG1, 0x0, ITYPE
        | ct ctpr2
        |>
        break;

    case BC_TSETM:
        | // ins_AD RA = base*8 (table at base-1), RD = num_const*8 (start_index)
        |1:
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | addd 3, BASE, RA, RA
        | disp ctpr1, >3
        |>
        |<
        | ldd 0, DISPATCH, DISPATCH_GL(gc.grayagain), CARG3
        | ldw 2, STACK, MULTRES, RD
        | ldw 3, KBASE, RD, CARG5           // Integer constant is in lo-word.
        | ldd 5, RA, 0xfffffff8, RB         // Guaranteed to be a table.
        | disp ctpr2, >4
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shld 3, CARG5, 0x3, CARG5
        | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
        | subd 5, RD, 0x8, RD
        | disp ctpr3, >2
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | ldb 3, RB, TAB->marked, CARG1
        | ldbsm 5, RB, TAB->marked, CARG2
        |>
        |<
        | ldwsm 3, RB, TAB->asize, CARG4
        | lddsm 5, RB, TAB->array, CARG6
        | nop 1
        |>
        |<
        | cmpandedb 3, CARG1, LJ_GC_BLACK, pred0
        | cmpedb 4, RD, 0x0, pred1
        | andd 5, CARG2, ~LJ_GC_BLACK, CARG2 // black2gray(tab)
        | nop 1
        |>
        |<
        | std 2, DISPATCH, DISPATCH_GL(gc.grayagain), RB, ~pred0
        | addd 3, RD, CARG5, RD              // Compute needed size.
        | shldsm 4, CARG4, 0x3, CARG4
        | stb 5, RB, TAB->marked, CARG2, ~pred0
        |>
        |<
        | cmpbedbsm 3, RD, CARG4, pred2
        | std 5, RB, TAB->gclist, CARG3, ~pred0
        | ct ctpr1, pred1                   // Nothing to copy?
        | nop 2
        |>
        |<
        | subd 3, RD, CARG5, RD, pred2
        | addd 4, CARG5, CARG6, CARG5, pred2
        | ct ctpr2, ~pred2                  // Doesn't fit into array part?
        |>
        |2: // Copy result slots to table.
        |<
        | ldd 3, RA, 0x0, RB
        | addd 4, RA, 0x8, RA
        | subd 5, RD, 0x8, RD
        |>
        |<
        | cmpedb 3, RD, 0x0, pred0
        | nop 2
        |>
        |<
        | addd 4, CARG5, 0x8, CARG5
        | std 5, CARG5, 0x0, RB
        | ct ctpr3, ~pred0
        |>
        |3:
        |<
        | movtd 0, TMP1, ctpr1
        | addd 1, PC, 0x4, PC
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        |4: // Need to resize array part.
        | disp ctpr1, extern lj_tab_reasize // (lua_State *L, GCtab *t, int nasize)
        |<
        | ldd 0, STACK, SAVE_L, CARG1
        | addd 1, RB, 0x0, CARG2
        | addd 2, RD, 0x0, CARG3
        | nop 2
        |>
        |<
        | shrd 0, CARG3, 0x3, CARG3
        | std 2, CARG1, L->base, BASE
        | addd 3, CARG1, 0x0, RB
        |>
        |<
        | std 2, STACK, SAVE_PC, PC
        | call ctpr1, wbs = 0x8
        |>
        |<
        | ldh 3, PC, PC_RD, RD              // Restore RD.
        | ldb 5, PC, PC_RA, RA              // Restore RA.
        | disp ctpr2, <1
        |>
        |<
        | ldd 3, RB, L->base, BASE
        | nop 2
        |>
        |<
        | shld 4, RA, 0x3, RA
        | shld 5, RD, 0x3, RD
        | ct ctpr2                          // Retry.
        |>
        break;

    /* -- Calls and vararg handling ----------------------------------------- */

    case BC_CALL: case BC_CALLM:
        | // ins_A_C  RA = base*8, (RB = (nresults+1)*8,) RD = (nargs+1)*8 | extra_nargs*8
        |<
        | ldw 2, STACK, MULTRES, TMP0
        | ldd 3, BASE, RA, RB
        | addd 4, RA, 0x10, RA
        | disp ctpr1, ->vmeta_call
        | nop 1
        |>
        | andd 4, RD, 0x7f8, RD
        if (op == BC_CALLM) {
          |<
          | sard 3, RB, 0x2f, ITYPE
          | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
          | addd 5, RD, TMP0, RD
          |>
        } else {
          |<
          | sard 3, RB, 0x2f, ITYPE
          | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
          |>
        }
        |<
        | cmpesb 3, ITYPE, LJ_TFUNC, pred0
        | addd 4, BASE, RA, CARG1
        | lddsm 5, RB, LFUNC->pc, CARG2
        | nop 1
        |>
        |<
        | addd 3, BASE, RA, BASE, pred0
        | addd 4, BASE, RA, RA, ~pred0
        |>
        |<
        | ldw 3, CARG2, 0x0, RA, pred0
        | addd 4, CARG2, 0x4, PC, pred0
        | std 5, CARG1, 0xfffffff8, PC, pred0
        | nop 1
        |>
        | ct ctpr1, ~pred0
        |<
        | andd 3, RA, 0xff, TMP0
        | shrd 4, RA, 0x5, RA
        |>
        |<
        | andd 3, RA, 0x7f8, RA
        | shld 4, TMP0, 0x3, TMP0                      // jmp to [DISPATCH+OP*8]
        |>
        |<
        | ldd 3, TMP0, DISPATCH, TMP0
        | nop 2
        |>
        | movtd 0, TMP0, ctpr1
        | ct ctpr1
        break;

    case BC_CALLMT:
        | // ins_AD RA = base*8, RD = extra_nargs*8
        |<
        | ldw 0, STACK, MULTRES, TMP0
        | nop 2
        |>
        | addd 3, RD, TMP0, RD
        | // Fall through. Assumes BC_CALLT follows and ins AD is a no-op.
        break;

    case BC_CALLT:
        | // ins_AD RA = base*8, RD = (nargs+1)*8
        |<
        | ldd 3, BASE, RA, RB
        | addd 4, BASE, RA, RA
        | addd 5, BASE, 0x0, KBASE          // Use KBASE for move + vmeta_call hint.
        | disp ctpr1, ->vmeta_call
        | nop 2
        |>
        |<
        | sard 3, RB, 0x2f, ITYPE
        | addd 4, RA, 0x10, RA
        |>
        |<
        | cmpesb 3, ITYPE, LJ_TFUNC, pred0
        | nop 2
        |>
        | ct ctpr1, ~pred0
        |->BC_CALLT_Z:
        |<
        | ldd 3, BASE, 0xfffffff8, PC
        | disp ctpr1, >3
        | nop 2
        |>
        |<
        | stw 2, STACK, MULTRES, RD
        | cmpandedb 3, PC, FRAME_TYPE, pred0
        | subd 4, RD, 0x8, RD
        | disp ctpr2, >2
        |>
        |<
        | subd 3, PC, FRAME_VARG, PC, ~pred0 // Tailcall from a vararg function.
        | cmpedb 4, RD, 0x0, pred2
        |>
        | cmpandedb 3, PC, FRAME_TYPEP, pred1
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | landp ~p0, p1, p5
        | pass p4, pred0                    // Vararg frame below?
        | pass p5, pred1
        |>
        |<
        | subd 3, BASE, PC, BASE, pred1     // Need to relocate BASE/KBASE down.
        | subd 4, BASE, PC, KBASE, pred1
        |>
        |<
        | ldd 3, BASE, 0xfffffff8, PC, pred1
        | addd 4, PC, FRAME_VARG, PC, pred0
        |>
        |<
        | std 5, BASE, 0xfffffff0, RB       // Copy func+tag down, reloaded below.
        | ct ctpr1, pred2
        |>
        |2: // Move args down.
        |<
        | ldd 3, RA, 0x0, RB
        | addd 4, RA, 0x8, RA
        | subd 5, RD, 0x8, RD
        |>
        |<
        | cmpedb 3, RD, 0x0, pred0
        | nop 1
        |>
        |<
        | addd 4, KBASE, 0x8, KBASE
        | std 5, KBASE, 0x0, RB
        | ct ctpr2, ~pred0
        |>
        |<
        | ldd 3, BASE, 0xfffffff0, RB
        | nop 2
        |>
        |3:
        |<
        | ldw 0, STACK, MULTRES, RD
        | cmpandedb 1, PC, FRAME_TYPE, pred1
        | ldbsm 2, PC, PC_RA, CARG1
        | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
        | disp ctpr1, >4
        |>
        |<
        | ldb 3, RB, LFUNC->ffid, TMP0
        | ldd 5, RB, LFUNC->pc, PC
        | nop 2
        |>
        |<
        | ldw 2, PC, 0x0, RA
        | cmpbedb 3, TMP0, 0x1, pred0       // (> FF_C) Calling a fast function?
        | shldsm 4, CARG1, 0x3, CARG1
        | nop 1
        |>
        |<
        | subdsm 3, BASE, CARG1, CARG2
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, p1, p4
        | pass p4, pred0
        |>
        | ct ctpr1, pred0
        | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, [BASE-8] = PC
        |<
        | andd 0, RA, 0xff, TMP0
        | shrd 1, RA, 0x5, RA
        | addd 2, PC, 0x4, PC
        |>
        |<
        | shld 2, TMP0, 0x3, TMP0           // jmp to [DISPATCH+OP*8]
        | andd 3, RA, 0x7f8, RA
        |>
        |<
        | ldd 0, TMP0, DISPATCH, TMP0
        | nop 2
        |>
        | movtd 0, TMP0, ctpr1
        | ct ctpr1
        |4: // Tailcall to a fast function.
        |<
        | addd 1, PC, 0x4, PC
        | andd 2, RA, 0xff, TMP0
        | ldd 3, CARG2, 0xffffffe0, KBASE   // Need to prepare KBASE.
        | shrd 4, RA, 0x5, RA
        |>
        |<
        | shld 0, TMP0, 0x3, TMP0           // jmp to [DISPATCH+OP*8]
        | andd 3, RA, 0x7f8, RA
        |>
        | ldd 0, TMP0, DISPATCH, TMP0
        | andd 3, KBASE, U64x(0x00007fff,0xffffffff), KBASE
        | ldd 3, KBASE, LFUNC->pc, KBASE
        |<
        | movtd 0, TMP0, ctpr1
        | nop 1
        |>
        | ldd 0, KBASE, PC2PROTO(k), KBASE
        | ct ctpr1
        break;

    case BC_ITERC:
        | // ins_A RA = base*8, (RB = nresults+1)*8, RD=(nargs+1)*8 (2+1)*8
        |<
        | addd 3, BASE, RA, RA              // fb = base+2
        | addd 0, 0x0, 0x18, RD             // Handle like a regular 2-arg call.
        | disp ctpr1, ->vmeta_call
        |>
        |<
        | addd 3, RA, 0x10, RA
        |>
        |<
        | ldd 3, RA, 0xffffffe0, RB         // Copy state. fb[0] = fb[-4].
        | ldd 5, RA, 0xffffffe8, RC         // Copy control var. fb[1] = fb[-3].
        | nop 1
        |>
        |<
        | ldd 3, RA, 0xffffffd8, CARG1            // Copy callable. fb[-2] = fb[-5]
        |>
        |<
        | std 5, RA, 0x0, RB
        |>
        |<
        | std 5, RA, 0x8, RC
        |>
        |<
        | sard 3, CARG1, 0x2f, ITYPE
        | andd 4, CARG1, U64x(0x00007fff,0xffffffff), CARG1
        | std 5, RA, 0xfffffff0, CARG1
        |>
        |<
        | cmpesb 3, ITYPE, LJ_TFUNC, pred0
        | nop 2
        |>
        |<
        | ldd 3, CARG1, LFUNC->pc, CARG2, pred0
        | addd 4, RA, 0x0, BASE, pred0
        | ct ctpr1, ~pred0
        |>
        |<
        | std 5, BASE, 0xfffffff8, PC
        | nop 1
        |>
        |<
        | ldw 3, CARG2, 0x0, RA
        | nop 2
        |>
        |<
        | addd 1, CARG2, 0x4, PC
        | andd 2, RA, 0xff, TMP0
        | shrd 3, RA, 0x5, RA
        |>
        |<
        | shld 2, TMP0, 0x3, TMP0           // jmp to [DISPATCH+OP*8]
        | andd 3, RA, 0x7f8, RA
        |>
        |<
        | ldd 0, TMP0, DISPATCH, TMP0
        | nop 2
        |>
        | movtd 0, TMP0, ctpr1
        | ct ctpr1
        break;

    case BC_ITERN:
        | // ins_A RA = base*8, (RB = (nresults+1)*8, RC = (nargs+1)*8 (2+1)*8)
        |<
        | addd 2, PC, 0x4, PC
        | addd 3, BASE, RA, TMP0
        | disp ctpr1, >3
        |>
        |<
        | ldd 3, TMP0, 0xfffffff0, RB
        | ldw 5, TMP0, 0xfffffff8, RC          // Get index from control var.
        | disp ctpr2, >1
        | nop 2
        |>
        |<
        | andd 3, RB, U64x(0x00007fff,0xffffffff), RB
        | disp ctpr3, >2
        |>
        |<
        | ldw 3, RB, TAB->asize, TMP1
        | shls 4, RC, 0x3, TMP0
        | ldd 5, RB, TAB->array, ITYPE
        | nop 1
        |>
        |1: // Traverse array part.
        |<
        | lddsm 3, ITYPE, TMP0, TMP0
        | cmpbsb 4, RC, TMP1, pred0
        | nop 2
        |>
        |<
        | subs 3, RC, TMP1, RC, ~pred0
        | cmpedbsm 4, TMP0, LJ_TNIL, pred1
        | ct ctpr1, ~pred0                  // Index points after array part?
        | nop 2
        |>
        |<
        | adds 0, RC, 0x1, RC, pred1        // Skip holes in array part.
        | shls 3, RC, 0x3, TMP0, pred1
        | ct ctpr2, pred1
        |>
        | // Copy array slot to returned value.
        | // Return array index as a numeric key
        |<
        | subd 1, PC, BCBIAS_J*4, PC
        | ldh 2, PC, PC_RD, RD                 // Get target from ITERL.
        | addd 3, TMP0, 0x0, RB
        | istofd 4, RC, TMP1
        | addd 5, BASE, RA, TMP0
        | nop 1
        |>
        |<
        | adds 4, RC, 0x1, RC
        | std 5, TMP0, 0x8, RB
        |>
        |<
        | shld 0, RD, 0x2, RD
        | std 5, TMP0, 0x0, TMP1
        |>
        |<
        | addd 0, PC, RD, PC
        | stw 2, TMP0, 0xfffffff8, RC          // Update control var.
        |>
        |2:
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        |3: // Traverse hash part.
        |<
        | ldw 3, RB, TAB->hmask, TMP0
        | smulx 4, RC, #NODE, ITYPE
        | lddsm 5, RB, TAB->node, CARG1
        | nop 2
        |>
        |<
        | cmpbesb 3, RC, TMP0, pred0
        | adds 4, RC, TMP1, TMP1
        | nop 2
        |>
        |<
        | adddsm 3, ITYPE, CARG1, ITYPE
        | adds 4, TMP1, 0x1, TMP1
        | ct ctpr3, ~pred0                  // End of iteration? Branch to ITERL+1.
        |>
        |<
        | ldd 3, ITYPE, NODE->val, TMP0
        | lddsm 5, ITYPE, NODE->key, CARG2
        | nop 2
        |>
        |<
        | cmpedb 3, TMP0, LJ_TNIL, pred0
        | lddsm 5, ITYPE, NODE->val, CARG3
        | nop 2
        |>
        |<
        | adds 3, RC, 0x1, RC, pred0        // Skip holes in hash part.
        | ct ctpr1, pred0
        |>
        | // Copy key and value from hash slot.
        |<
        | ldh 0, PC, PC_RD, RD                 // Get target from ITERL.
        | subd 1, PC, BCBIAS_J*4, PC
        | addd 3, BASE, RA, TMP0
        | nop 1
        |>
        |<
        | std 5, TMP0, 0x0, CARG2
        |>
        |<
        | shld 0, RD, 0x2, RD
        | std 5, TMP0, 0x8, CARG3
        |>
        |<
        | addd 0, PC, RD, PC
        | stw 5, TMP0, 0xfffffff8, TMP1
        | ct ctpr3
        |>
        break;

    case BC_ISNEXT:
        | // ins_AD RA = base*8, RD = target*8 (points to ITERN)
        |<
        | addd 0, 0x0, BC_JMP, CARG4
        | addd 1, PC, 0x0, CARG3 
        | subd 2, PC, BCBIAS_J*4, PC
        | shrd 3, RD, 0x1, RD
        | addd 4, BASE, RA, TMP0
        | disp ctpr1, >2
        |>
        |<
        | addd 1, PC, RD, PC
        | ldd 3, TMP0, 0xffffffe8, CARG1
        | ldd 5, TMP0, 0xfffffff0, TMP1
        |>
        |<
        | ldw 0, PC, 0x0, CARG7
        | ldb 2, PC, 0x0, CARG8
        |>
        |<
        | addd 2, 0x0, BC_ITERC, CARG5
        | addd 3, 0x0, 0x2f, CARG2
        |>
        |<
        | andd 3, CARG1, U64x(0x00007fff,0xffffffff), RB
        | sard 4, CARG1, CARG2, ITYPE
        | sard 5, TMP1, CARG2, TMP1
        |>
        |<
        | ldbsm 3, RB, CFUNC->ffid, CARG6
        | cmpedb 4, CARG1, LJ_TNIL, pred2
        |>
        |<
        | shld 2, CARG8, 0x3, CARG8
        | cmpesb 3, ITYPE, LJ_TFUNC, pred0
        | cmpesb 4, TMP1, LJ_TTAB, pred1
        | nop 1
        |>
        |<
        | cmpedbsm 3, CARG6, FF_next_N, pred3
        | pass pred0, p0
        | pass pred1, p1
        | pass pred2, p2
        | landp p0, p1, p4
        | landp p4, p2, p5
        | pass p5, pred0
        | nop 1
        |>
        |<
        | addd 0, 0x0, U64x(0xfffe7fff,0x00000000), TMP1
        | pass pred0, p0
        | pass pred3, p1
        | landp p0, p1, p4
        | pass p4, pred0
        |>
        | // Despecialize bytecode if any of the checks fail.
        |<
        | shld 1, CARG5, 0x3, CARG8, ~pred0
        | stb 2, PC, 0x0, CARG5, ~pred0
        | std 5, TMP0, 0xfffffff8, TMP1, pred0 // Initialize control var.
        |>
        |<
        | addd 1, PC, 0x4, PC
        | ldd 2, CARG8, DISPATCH, CARG8
        | shrd 3, CARG7, 0xd, RD
        | shrd 4, CARG7, 0x15, RB
        | shrd 5, CARG7, 0x5, RA
        |>
        |<
        | movtd 0, CARG8, ctpr1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        | stb 2, CARG3, PC_OP, CARG4, ~pred0
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        break;

    case BC_VARG:
        | // ins_ABC RA = base*8, RB = (nresults+1)*8, RC = numparams*8
        |<
        | ldw 0, PC, 0x0, RARG2
        | ldb 2, PC, 0x0, RARG3
        | addd 3, BASE, RC, TMP1
        | cmpedb 4, RB, 0x0, pred0
        | ldd 5, BASE, 0xfffffff8, TMP0
        | disp ctpr1, >5
        |>
        |<
        | addd 3, TMP1, FRAME_VARG+0x10, TMP1
        | addd 4, BASE, RA, RA
        | addd 5, 0x0, LJ_TNIL, CARG4
        | disp ctpr2, >2
        | nop 2
        |>
        |<
        | shld 2, RARG3, 0x3, RARG3
        | subd 3, TMP1, TMP0, TMP1          // TMP1 may now be even _above_ BASE if nargs was < numparams.
        | addd 4, RA, RB, CARG3
        | disp ctpr3, >3
        |>
        |<
        | ldd 2, RARG3, DISPATCH, RARG3
        | subd 3, CARG3, 0x8, RB, ~pred0
        | cmpbdb 4, TMP1, BASE, pred1
        | ct ctpr1, pred0                   // Copy all varargs?
        |>
        | ct ctpr2, ~pred1                  // No vrarg slots?
        |1: // Copy vararg slots to destination slots.
        |<
        | ldd 3, TMP1, 0xfffffff0, RC
        | addd 4, TMP1, 0x8, TMP1
        | addd 5, RA, 0x8, CARG3 
        | disp ctpr1, <1
        |>
        |<
        | cmpbdb 3, CARG3, RB, pred0
        | cmpbdb 4, TMP1, BASE, pred1
        | nop 1
        |>
        |<
        | addd 4, CARG3, 0x0, RA
        | std 5, RA, 0x0, RC
        |>
        | ct ctpr3, ~pred0                  // All destination slots filled?
        | ct ctpr1, pred1                   // No more vararg slots?
        |2: // Fill up remainder with nil.
        |<
        | addd 4, RA, 0x8, RA
        | std 5, RA, 0x0, CARG4
        |>
        |<
        | cmpbdb 3, RA, RB, pred0
        | nop 2
        |>
        | ct ctpr2, pred0
        |3:
        |<
        | movtd 0, RARG3, ctpr1
        | addd 1, PC, 0x4, PC
        | shrd 3, RARG2, 0xd, RD
        | shrd 4, RARG2, 0x15, RB
        | shrd 5, RARG2, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        |5: // Copy all varargs.
        |<
        | addd 0, 0x0, (0+1)*8, TMP0
        | ldd 2, STACK, SAVE_L, RB
        | addd 3, BASE, 0x0, RC
        | disp ctpr2, >6
        |>
        |<
        | stw 2, STACK, MULTRES, TMP0
        | cmpbedb 3, RC, TMP1, pred0
        | nop 1
        |>
        |<
        | lddsm 3, RB, L->maxstack, TMP0
        |>
        |<
        | subd 4, RC, TMP1, RC
        | ct ctpr3, pred0                   // No vararg slots?
        |>
        |<
        | addd 3, RC, 0x8, CARG3
        | addd 4, RC, RA, RC
        |>
        |<
        | cmpbedb 3, RC, TMP0, pred0
        | stw 2, STACK, MULTRES, CARG3      // (#varargs+1)*8
        | nop 2
        |>
        | ct ctpr2, pred0                   // Need to grow stack?
        | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
        | ldw 0, STACK, MULTRES, CARG2
        |<
        | std 2, STACK, SAVE_PC, PC
        | subd 3, TMP1, BASE, TMP1          // Need delta, because BASE may change.
        | std 5, RB, L->base, BASE
        | nop 1
        |>
        |<
        | subd 0, CARG2, 0x8, CARG2
        | std 5, RB, L->top, RA
        |>
        |<
        | shrd 0, CARG2, 0x3, CARG2
        | addd 3, RB, 0x0, CARG1
        | call ctpr1, wbs = 0x8
        |>
        |<
        | ldd 3, RB, L->base, BASE
        | ldd 5, RB, L->top, RA
        | disp ctpr2, >6
        | nop 2
        |>
        | addd 3, TMP1, BASE, TMP1
        |6: // Copy all vararg slots.
        |<
        | ldd 3, TMP1, 0xfffffff0, RC
        | addd 4, TMP1, 0x8, TMP1
        |>
        |<
        | cmpbdb 3, TMP1, BASE, pred0
        | nop 1
        |>
        |<
        | addd 4, RA, 0x8, RA
        | std 5, RA, 0x0, RC
        | ct ctpr2, pred0
        |>
        |<
        | movtd 0, RARG3, ctpr1
        | addd 1, PC, 0x4, PC
        | shrd 3, RARG2, 0xd, RD
        | shrd 4, RARG2, 0x15, RB
        | shrd 5, RARG2, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        break;

    /* -- Returns ----------------------------------------------------------- */

    case BC_RETM:
        | // ins_AD RA = results*8, RD = extra_nresults*8
        |<
        | ldw 0, STACK, MULTRES, TMP0
        | nop 2
        |>
        | addd 3, RD, TMP0, RD                 // MULTRES >=8, so RD >= 8
        | // Fall through. Assumes BC_RET follows and ins_AD is a no-op.
        break;

    case BC_RET:
        | // ins_AD RA = results*8, RD = (nresults+1)*8
        |1:
        |<
        | ldd 3, BASE, 0xfffffff8, PC
        | disp ctpr3, ->vm_return
        | nop 2
        |>
        |<
        | stw 2, STACK, MULTRES, RD            // Save (nresults+1)*8.
        | disp ctpr1, <1
        |>
        |<
        | cmpandedb 3, PC, FRAME_TYPE, pred0   // Check frame type marker.
        | subdsm 4, PC, FRAME_VARG, RB
        |>
        |<
        | cmpandedbsm 3, RB, FRAME_TYPEP, pred1
        | nop 1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred1
        |>
        | ct ctpr3, pred1
        |<
        | subd 3, BASE, RB, BASE, ~pred0    // Return from vararg function: relocate BASE down and RA up.
        | addd 4, RA, RB, RA, ~pred0
        | ct ctpr1, ~pred0
        |>
        |->BC_RET_Z:
        | // BASE = base, RA = resultptr, RD = (nresults+1)*8, PC = return
        |<
        | ldb 0, PC, PC_RB, CARG2
        | ldw 2, STACK, MULTRES, CARG1      // Note: MULTRES may be >255.
        | addd 3, BASE, 0x0, KBASE          // Use KBASE for result move.
        | subd 4, RD, 0x8, RD
        | ldb 5, PC, PC_RA, CARG3
        | disp ctpr1, >3
        |>
        |<
        | ldw 0, PC, 0x0, CARG4
        | ldb 2, PC, 0x0, CARG5
        | cmpedb 3, RD, 0x0, pred0
        | addd 4, 0x0, LJ_TNIL, TMP0
        | disp ctpr2, >2
        | nop 1
        |>
        |<
        | shld 0, CARG2, 0x3, CARG2
        | shld 3, CARG3, 0x3, CARG3
        | ct ctpr1, pred0
        |>
        |2:                                 // Move results down.
        |<
        | ldd 3, KBASE, RA, RB
        | subd 4, RD, 0x8, RD
        |>
        |<
        | cmpedb 3, RD, 0x0, pred0
        | nop 3
        |>
        |<
        | addd 4, KBASE, 0x8, KBASE
        | std 5, KBASE, 0xfffffff0, RB
        | ct ctpr2, ~pred0
        |>
        |3:
        |<
        | cmpbedb 0, CARG2, CARG1, pred0
        | disp ctpr2, >4
        | nop 2
        |>
        |<
        | shld 2, CARG5, 0x3, CARG5, pred0
        | subd 3, BASE, CARG3, BASE, pred0
        | shrd 4, CARG4, 0xd, RD, pred0
        | shrd 5, CARG4, 0x15, RB, pred0
        | ct ctpr2, ~pred0                  // More results expected?
        |>
        |<
        | subd 0, BASE, 0x10, BASE          // base = base - (RA+2)*8
        | addd 1, PC, 0x4, PC
        | ldd 2, CARG5, DISPATCH, CARG5
        | shrd 3, CARG4, 0x5, RA
        | andd 4, RD, 0x7fff8, RD
        |>
        |<
        | ldd 0, BASE, 0xfffffff0, KBASE
        | andd 3, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, CARG5, ctpr1
        | andd 3, KBASE, U64x(0x00007fff,0xffffffff), KBASE
        |>
        |<
        | ldd 3, KBASE, LFUNC->pc, KBASE
        | nop 2
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ldd 5, KBASE, PC2PROTO(k), KBASE
        | ct ctpr1
        |>
        |4:                                 // Fill up results with nil.
        |<
        | addd 0, CARG1, 0x8, CARG1
        | std 5, KBASE, 0xfffffff0, TMP0    // Note: relies on shifted base.
        | ct ctpr1
        |>
        break;

    case BC_RET0: case BC_RET1:
        | // ins_AD RA = results*8, RD = (nresults+1)*8
        |1:
        |<
        | ldd 0, BASE, 0xfffffff8, PC
        | disp ctpr3, ->vm_return
        | nop 2
        |>
        |<
        | stw 2, STACK, MULTRES, RD            // Save (nresults+1)*8.
        | disp ctpr1, <1
        |>
        |<
        | ldbsm 0, PC, 0x0, CARG2
        | cmpandedb 1, PC, FRAME_TYPE, pred0   // Check frame type marker.
        | ldwsm 3, PC, 0x0, CARG1
        | subdsm 4, PC, FRAME_VARG, RB
        | disp ctpr2, >3
        |>
        |<
        | cmpandedbsm 3, RB, FRAME_TYPEP, pred1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred1
        |>
        | ct ctpr3, pred1
        if (op == BC_RET1) {
          |<
          | shld 2, CARG2, 0x3, CARG2, pred0
          | subd 3, BASE, RB, BASE, ~pred0    // Return from vararg function: relocate BASE down and RA up.
          | addd 4, RA, RB, RA, ~pred0
          | ldd 5, BASE, RA, RB, pred0
          | ct ctpr1, ~pred0
          |>
        } else {
          |<
          | shld 2, CARG2, 0x3, CARG2, pred0
          | subd 3, BASE, RB, BASE, ~pred0    // Return from vararg function: relocate BASE down and RA up.
          | ct ctpr1, ~pred0
          |>
        }
        if (op == BC_RET1) {
          | std 5, BASE, 0xfffffff0, RB
        }
        |2:
        |<
        | ldb 0, PC, PC_RB, TMP0
        | ldb 3, PC, PC_RA, RA
        | disp ctpr1, <2
        | nop 1
        |>
        | andd 4, RD, 0x7f8, TMP1
        | shld 0, TMP0, 0x3, TMP0
        | cmpbedb 0, TMP0, TMP1, pred0
        |<
        | ldd 2, CARG2, DISPATCH, CARG2, pred0
        | shld 3, RA, 0x3, RA, pred0
        | subd 4, BASE, 0x10, BASE, pred0
        | ct ctpr2, ~pred0                  // More results expected?
        |>
        |<
        | addd 1, PC, 0x4, PC
        | subd 3, BASE, RA, BASE            // base = base - (RA+2)*8
        | shrd 4, CARG1, 0xd, RD
        | shrd 5, CARG1, 0x15, RB
        |>
        |<
        | ldd 3, BASE, 0xfffffff0, KBASE
        | shrd 4, CARG1, 0x5, RA
        | andd 5, RD, 0x7fff8, RD
        | nop 2
        |>
        |<
        | movtd 0, CARG2, ctpr1
        | andd 3, KBASE, U64x(0x00007fff,0xffffffff), KBASE
        |>
        |<
        | ldd 3, KBASE, LFUNC->pc, KBASE
        | andd 4, RB, 0x7f8, RB
        | nop 2
        |>
        | andd 5, RA, 0x7f8, RA
        |<
        | ldd 3, KBASE, PC2PROTO(k), KBASE
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        |3:                                 // Fill up results with nil.
        |<
        | subd 3, BASE, 0x18, TMP0
        | addd 4, 0x0, LJ_TNIL, TMP1
        |>
        |<
        | addd 3, RD, 0x8, RD
        | std 5, TMP0, RD, TMP1
        | ct ctpr1
        |>
        break;

    /* -- Loops and branches ------------------------------------------------ */

    case BC_FORL:
        | // Fall through. Assumes BC_IFORL follows and ins_AJ is a no-op.
        break;

    case BC_JFORI: case BC_JFORL:
        | // Unsupported
        break;

    case BC_IFORL:
        | // ins_AJ RA = base*8, RD = target*8 (after end of loop or start of loop)
        |<
        | subd 1, PC, BCBIAS_J*4, CARG3
        | addd 3, BASE, RA, RA
        | shrd 4, RD, 0x1, CARG2
        |>
        |<
        | addd 0, CARG3, CARG2, CARG4
        | ldd 3, RA, 0x10, RB
        | ldd 5, RA, 0x0, TMP0
        | nop 2
        |>
        |<
        | ldbsm 0, PC, 0x0, CARG1
        | ldbsm 2, CARG4, 0x0, CARG5
        | faddd 3, TMP0, RB, TMP0
        | fcmpltdb 4, RB, 0x0, pred2
        | ldd 5, RA, 0x8, TMP1
        | nop 2
        |>
        |<
        | shldsm 0, CARG1, 0x3, CARG1
        | shldsm 1, CARG5, 0x3, CARG5
        |>
        |<
        | lddsm 0, CARG1, DISPATCH, CARG1
        | lddsm 2, CARG5, DISPATCH, CARG5
        | fcmpltdb 3, TMP1, TMP0, pred0
        | fcmpltdb 4, TMP0, TMP1, pred1     // Invert comparison if step is negative.
        | nop 2
        |>
        |<
        | std 5, RA, 0x0, TMP0
        | pass pred0, p0
        | pass pred1, p1
        | pass pred2, p2
        | landp ~p0, ~p2, p4
        | landp ~p1, p2, p5
        | landp ~p4, ~p5, p6
        | pass p6, pred0
        |>
        |<
        | addd 0, CARG5, 0x0, CARG1, ~pred0 
        | addd 1, CARG4, 0x0, PC, ~pred0
        | std 5, RA, 0x18, TMP0
        |>
        |<
        | movtd 0, CARG1, ctpr1
        | addd 1, PC, 0x4, PC
        | ldw 2, PC, 0x0, TMP0
        | nop 2
        |>
        |<
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        break;

    case BC_FORI:
        | // ins_AJ RA = base*8, RD = target*8 (after end of loop or start of loop)
        |<
        | subd 2, PC, BCBIAS_J*4, CARG3
        | addd 3, BASE, RA, RA
        | addd 4, 0x0, 0x2f, CARG1
        | disp ctpr2, ->vmeta_for
        |>
        |<
        | shrd 1, RD, 0x1, CARG4
        | ldd 2, RA, 0x10, RB
        | ldd 3, RA, 0x0, TMP0
        | ldd 5, RA, 0x8, TMP1
        | nop 2
        |>
        |<
        | addd 1, CARG3, CARG4, CARG3
        | sard 2, RB, CARG1, ITYPE
        | sard 3, TMP0, CARG1, CARG1
        | sard 4, TMP1, CARG1, CARG2
        |>
        |<
        | cmplsb 0, ITYPE, LJ_TISNUM, pred3
        | cmpbsb 1, ITYPE, LJ_TISNUM, pred0
        | cmpbsb 3, CARG1, LJ_TISNUM, pred1
        | cmpbsb 4, CARG2, LJ_TISNUM, pred2
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp p0, p1, p4
        | pass p4, pred0
        | pass pred2, p2
        | landp p4, p2, p5
        | pass p5, pred2
        |>
        |<
        | fcmpltdb 3, TMP1, TMP0, pred0
        | fcmpltdb 4, TMP0, TMP1, pred1     // Invert comparison if step is negative.
        | nop 1
        |>
        |<
        | std 5, RA, 0x18, TMP0, pred2
        | ct ctpr2, ~pred2
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | pass pred3, p3
        | landp ~p0, ~p3, p4
        | landp ~p1, p3, p5
        | landp ~p4, ~p5, p6
        | pass p6, pred0
        |>
        | addd 0, CARG3, 0x0, PC, pred0
        |<
        | ldb 0, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | ldw 2, PC, 0x0, TMP0
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        break;

    case BC_ITERL:
        | // Fall through. Assumes BC_IITERL follows and ins_AJ is a no-op.
        break;

    case BC_JITERL:
        | // Unsupported
        break;

    case BC_IITERL:
        | // ins_AJ RA = base*8, RD = target*8
        |<
        | subd 2, PC, BCBIAS_J*4, CARG1
        | addd 3, BASE, RA, RA
        | shrd 4, RD, 0x1, RD
        |>
        |<
        | ldd 3, RA, 0x0, RB
        | nop 2
        |>
        |<
        | cmpedb 3, RB, LJ_TNIL, pred0
        | nop 1
        |>
        |<
        | addd 0, CARG1, RD, PC, ~pred0     // Otherwise save control var + branch.
        | std 5, RA, 0xfffffff8, RB, ~pred0
        |>
        |<
        | ldw 0, PC, 0x0, TMP0
        | ldb 2, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        break;

    case BC_LOOP:
        | // ins_A RA = base*8, RD = target*8 (loop extent)
        | // Note: RA/RD is only used by trace recorder to determine scope/extent
        | // This opcode does NOT jump, it's only purpose is to detect a hot loop.
        | //Fall through. Assumes BC_ILOOP follows and ins_A is a no-op.
        break;

    case BC_ILOOP:
        | // ins_A RA = base*8, RD = target*8 (loop extent)
        | ins_next
        break;

    case BC_JLOOP:
        | // Unsupported
        break;

    case BC_JMP:
        | // ins_AJ RA = unused, RD = target*8
        |<
        | subd 0, PC, BCBIAS_J*4, PC
        | shrd 3, RD, 0x1, CARG1
        |>
        |<
        | ldw 0, PC, CARG1, TMP0
        | addd 1, PC, CARG1, PC
        | ldb 2, PC, CARG1, TMP1
        | nop 3
        |>
        |<
        | addd 1, PC, 0x4, PC
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        break;

    /* -- Function headers -------------------------------------------------- */

    /*
    ** Reminder: A function may be called with func/args above L->maxstack,
    ** i.e. occupying EXTRA_STACK slots. And vmeta_call may add one extra slot,
    ** too. This means all FUNC* ops (including fast functions) must check
    ** for stack overflow _before_ adding more slots!
    */

    case BC_FUNCF:
    case BC_FUNCV: /* NYI: compiled vararg functions. */
        | // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow and ins_AD is a no-op.
        break;

    case BC_JFUNCF:
        | // Unsupported
        break;

    case BC_IFUNCF:
        | // ins_AD BASE = new_base*8, RA = framesize*8, RD = (nargs+1)*8
        |<
        | ldb 2, PC, 0x0, CARG2
        | ldd 3, PC, PC2PROTO(k)-4, KBASE
        | addd 4, BASE, RA, RA              // Top of frame.
        | ldd 5, STACK, SAVE_L, RB
        | disp ctpr1, ->vm_growstack_f
        | nop 1
        |>
        |<
        | shld 2, CARG2, 0x3, CARG2
        | ldbsm 3, PC, PC2PROTO(numparams)-4, CARG6
        | addd 4, 0x0, LJ_TNIL, TMP1
        |>
        |<
        | ldd 2, CARG2, DISPATCH, CARG2
        | ldd 3, RB, L->maxstack, TMP0
        | ldw 5, PC, 0x0, CARG1
        | disp ctpr2, >2
        | nop 2
        |>
        |<
        | movtd 0, CARG2, ctpr3
        | cmpbedb 3, RA, TMP0, pred0
        | shrd 4, CARG1, 0xd, CARG3
        | shrd 5, CARG1, 0x15, CARG4
        |>
        | ct ctpr1, ~pred0
        |<
        | shld 3, CARG6, 0x3, RA
        | shrd 4, CARG1, 0x5, CARG5
        | disp ctpr1, >1
        |>
        |<
        | addd 2, PC, 0x4, PC
        | cmpbedb 3, RD, RA, pred0
        | ct ctpr2, ~pred0                  // Check for missing parameters.
        |>
        |1: // Clear missing parameters.
        |<
        | subd 3, RD, 0x8, TMP0
        | addd 4, RD, 0x8, RD
        |>
        | cmpbedb 3, RD, RA, pred0
        |<
        | std 5, BASE, TMP0, TMP1
        | ct ctpr1, pred0
        |>
        |2:
        |<
        | andd 3, CARG3, 0x7fff8, RD
        | andd 4, CARG5, 0x7f8, RA
        |>
        |<
        | andd 3, CARG4, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        | ct ctpr3
        |>
        break;

    case BC_JFUNCV:
        | // Unsupported
        break;

    case BC_IFUNCV:
        | // ins_AD BASE = new base, RA = framesize*8, RB = LFUNC (but we need tagged), RD = (nargs+1)*8
        |<
        | ldbsm 2, PC, 0x0, CARG3
        | ldd 3, BASE, 0xfffffff0, KBASE
        | addd 4, RD, FRAME_VARG+0x8, TMP0
        | addd 5, RD, BASE, RD
        | disp ctpr1, ->vm_growstack_v
        |>
        |<
        | ldbsm 0, PC, PC2PROTO(numparams)-4, CARG1
        | ldd 3, STACK, SAVE_L, RB
        | addd 4, RD, 0x8, RD
        | ldwsm 5, PC, 0x0, CARG2
        | disp ctpr2, >2
        |>
        |<
        | addd 3, RA, RD, RA
        | std 5, RD, 0xfffffff8, TMP0       // Store delta + FRAME_VARG
        |>
        |<
        | shldsm 2, CARG3, 0x3, CARG3
        | std 5, RD, 0xfffffff0, KBASE      // Store copy of LFUNC
        |>
        |<
        | lddsm 2, CARG3, DISPATCH, CARG3
        | ldd 3, RB, L->maxstack, TMP0
        | nop 2
        |>
        |<
        | movtdsm 0, CARG3, ctpr3
        | cmpedbsm 1, CARG1, 0x0, pred1
        | cmpbedb 3, RA, TMP0, pred0
        |>
        |<
        | addd 3, BASE, 0x0, RA, pred0
        | addd 0, RD, 0x0, BASE, pred0
        | ct ctpr1, ~pred0                  // Need to grow stack?
        |>
        |<
        | addd 3, RA, 0x8, RA, ~pred1
        | shrd 4, CARG2, 0x15, RB
        | ldd 5, PC, PC2PROTO(k)-4, KBASE
        | ct ctpr2, pred1
        |>
        |1:                                 // Copy fixarg slots up to new frame.
        |<
        | addd 3, RA, 0x8, RA
        | addd 4, 0x0, LJ_TNIL, TMP1
        | disp ctpr1, >3
        |>
        |<
        | cmpbdb 3, RA, BASE, pred0
        | disp ctpr2, <1
        |>
        |<
        | ldd 3, RA, 0xfffffff0, CARG4, pred0
        | subd 0, CARG1, 0x1, CARG1, pred0
        | nop 1
        |>
        | ct ctpr1, ~pred0                  // Less args than parameters?
        |<
        | cmpedb 0, CARG1, 0x0, pred0
        | addd 3, RD, 0x8, RD
        | std 5, RD, 0x0, CARG4
        |>
        |<
        | std 5, RA, 0xfffffff0, TMP1       // Clear old fixarg slot (help the GC).
        | ct ctpr2, ~pred0
        |>
        |2:
        |<
        | addd 1, PC, 0x4, PC
        | shrd 3, CARG2, 0xd, RD
        | andd 4, RB, 0x7f8, RB
        | shrd 5, CARG2, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        |>
        |<
        | andd 4, RD, 0x7f8, RC
        | ct ctpr3
        |>
        |3:                                 // Clear missing parameters.
        |<
        | subd 0, CARG1, 0x1, CARG1
        | addd 3, RD, 0x8, RD
        | std 5, RD, 0x0, TMP1
        | disp ctpr2, <2
        |>
        |<
        | cmpedb 0, CARG1, 0x0, pred0
        |>
        | ct ctpr1, ~pred0
        | ct ctpr2
        break;

    case BC_FUNCC:
        | // ins_AD BASE = new base, RA = framesize*8, RD = (nargs+1)*8
        |<
        | ldd 3, BASE, 0xfffffff0, KBASE
        | addd 4, BASE, RD, RD
        | ldd 5, STACK, SAVE_L, RB
        | disp ctpr1, ->vm_growstack_c
        | nop 2
        |>
        |<
        | andd 3, KBASE, U64x(0x00007fff,0xffffffff), KBASE
        | subd 4, RD, 0x8, RD
        | std 5, RB, L->base, BASE
        | nop 1
        |>
        |<
        | ldd 0, KBASE, CFUNC->f, KBASE
        | ldd 3, RB, L->maxstack, TMP1
        | addd 4, RD, 8*LUA_MINSTACK, TMP0
        | nop 2
        |>
        |<
        | addd 1, 0x0, ~LJ_VMST_C, TMP0
        | cmpbedb 3, TMP0, TMP1, pred0
        | addd 4, RB, 0x0, CARG1
        | std 5, RB, L->top, RD
        |>
        |<
        | stw 2, DISPATCH, DISPATCH_GL(vmstate), TMP0, pred0
        | ct ctpr1, ~pred0                  // Need to grow stack?
        |>
        | movtd 0, KBASE, ctpr1             // (lua_State *L)
        | call ctpr1, wbs = 0x8
        |<
        | ldd 3, RB, L->base, BASE
        | shld 4, CRET1, 0x3, RD            // return nsresult
        | addd 5, 0x0, ~LJ_VMST_INTERP, TMP0
        | disp ctpr1, ->vm_returnc
        |>
        |<
        | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
        | addd 3, BASE, RD, RA
        | stw 5, DISPATCH, DISPATCH_GL(vmstate), TMP0
        |>
        |<
        | ldd 0, BASE, 0xfffffff8, PC       // Fetch PC of caller
        | ldd 3, RB, L->top, TMP0
        | nop 2
        |>
        |<
        | subd 3, TMP0, RA, RA              // RA = (L->top - (L->base+nresults))*8
        | ct ctpr1
        |>
        break;

    case BC_FUNCCW:
        | // ins_AD BASE = new base, RA = framesize*8, RD = (nargs+1)*8
        |<
        | ldd 3, BASE, 0xfffffff0, CARG2
        | addd 4, BASE, RD, RD
        | ldd 5, STACK, SAVE_L, RB
        | disp ctpr1, ->vm_growstack_c
        | nop 2
        |>
        |<
        | andd 3, CARG2, U64x(0x00007fff,0xffffffff), CARG2
        | subd 4, RD, 0x8, RD
        | std 5, RB, L->base, BASE
        | nop 1
        |>
        |<
        | ldd 0, CARG2, CFUNC->f, CARG2
        | ldd 2, DISPATCH, DISPATCH_GL(wrapf), CARG3
        | ldd 3, RB, L->maxstack, TMP1
        | addd 4, RD, 8*LUA_MINSTACK, TMP0
        | nop 2
        |>
        |<
        | addd 0, CARG2, 0x0, KBASE
        | addd 1, 0x0, ~LJ_VMST_C, TMP0
        | cmpbedb 3, TMP0, TMP1, pred0
        | addd 4, RB, 0x0, CARG1
        | std 5, RB, L->top, RD
        |>
        |<
        | stw 2, DISPATCH, DISPATCH_GL(vmstate), TMP0, pred0
        | ct ctpr1, ~pred0                  // Need to grow stack?
        |>
        | movtd 0, CARG3, ctpr1              // (lua_State *L, lua_CFunction f)
        | call ctpr1, wbs = 0x8
        |<
        | ldd 3, RB, L->base, BASE
        | shld 4, CRET1, 0x3, RD            // return nsresult
        | addd 5, 0x0, ~LJ_VMST_INTERP, TMP0
        | disp ctpr1, ->vm_returnc
        |>
        |<
        | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
        | addd 3, BASE, RD, RA
        | stw 5, DISPATCH, DISPATCH_GL(vmstate), TMP0
        |>
        |<
        | ldd 0, BASE, 0xfffffff8, PC       // Fetch PC of caller
        | ldd 3, RB, L->top, TMP0
        | nop 2
        |>
        |<
        | subd 3, TMP0, RA, RA              // RA = (L->top - (L->base+nresults))*8
        | ct ctpr1
        |>
        break;

    /* ---------------------------------------------------------------------- */
    default:
        fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
        exit(2);
        break;
    }
}

static int build_backend(BuildCtx *ctx)
{
    int op;
    dasm_growpc(Dst, BC__MAX);
    build_subroutines(ctx);
    |.code_op
    for (op = 0 ; op < BC__MAX; op++)
        build_ins(ctx, (BCOp)op, op);
    return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions */
static void emit_asm_debug(BuildCtx* ctx)
{
    int fcofs = (int)((uint8_t *)ctx->glob[GLOB_vm_ffi_call] - ctx->code);
    switch  (ctx->mode) {
    case BUILD_elfasm:
        fprintf(ctx->fp, "\t.section .debug_frame,\"\",@progbits\n");
        fprintf(ctx->fp,
        ".Lframe0:\n"
        "\t.long .LECIE0-.LSCIE0\n"
        ".LSCIE0:\n"
        "\t.long 0xffffffff\n"
        "\t.byte 0x1\n"
        "\t.string \"\"\n"
        "\t.uleb128 0x1\n"
        "\t.sleb128 -8\n"
        "\t.byte 0x8c\n"
        "\t.byte 0xc\n\t.uleb128 0x19\n\t.uleb128 0\n"
        "\t.byte 0x9\n\t.uleb128 0x8c\n\t.uleb128 0\n"
        "\t.align 8\n"
        ".LECIE0:\n\n");
        fprintf(ctx->fp,
        ".LSFDE0:\n"
        "\t.long .LEFDE0-.LASFDE0\n"
        ".LASFDE0:\n"
        "\t.long .Lframe0\n"
        "\t.quad .Lbegin\n"
        "\t.quad %d\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE0:\n\n", fcofs);
#if LJ_HASFFI
        fprintf(ctx->fp,
        ".LSFDE1:\n"
        "\t.long .LEFDE1-.LASFDE1\n"
        ".LASFDE1:\n"
        "\t.long .Lframe0\n"
        "\t.quad lj_vm_ffi_call\n"
        "\t.quad %d\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
#endif
#if !LJ_NO_UNWIND
        fprintf(ctx->fp, "\t.section .eh_frame,\"a\",@progbits\n");
        fprintf(ctx->fp,
        "\t.globl lj_err_unwind_dwarf\n"
        ".Lframe1:\n"
        "\t.long .LECIE1-.LSCIE1\n"
        ".LSCIE1:\n"
        "\t.long 0\n"
        "\t.byte 0x1\n"
        "\t.string \"zPR\"\n"
        "\t.uleb128 0x1\n"
        "\t.sleb128 -8\n"
        "\t.byte 0x8c\n"
        "\t.uleb128 0xa\n"
        "\t.byte 0\n"
        "\t.quad lj_err_unwind_dwarf\n"
        "\t.byte 0\n"
        "\t.byte 0xc\n\t.uleb128 0x19\n\t.uleb128 0\n"
        "\t.byte 0x9\n\t.uleb128 0x8c\n\t.uleb128 0\n"
        "\t.align 8\n"
        ".LECIE1:\n\n");
        fprintf(ctx->fp,
        ".LSFDE2:\n"
        "\t.long .LEFDE2-.LASFDE2\n"
        ".LASFDE2:\n"
        "\t.long .LASFDE2-.Lframe1\n"
        "\t.quad .Lbegin\n"
        "\t.quad %d\n"
        "\t.uleb128 0\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE2:\n\n", fcofs);
#if LJ_HASFFI
        fprintf(ctx->fp,
        ".Lframe2:\n"
        "\t.long .LECIE2-.LSCIE2\n"
        ".LSCIE2:\n"
        "\t.long 0\n"
        "\t.byte 0x1\n"
        "\t.string \"zR\"\n"
        "\t.uleb128 0x1\n"
        "\t.sleb128 -8\n"
        "\t.byte 0x8c\n"
        "\t.uleb128 1\n"
        "\t.byte 0\n"
        "\t.byte 0xc\n\t.uleb128 0x19\n\t.uleb128 0\n"
        "\t.byte 0x9\n\t.uleb128 0x8c\n\t.uleb128 0\n"
        "\t.align 8\n"
        ".LECIE2:\n\n");
        fprintf(ctx->fp,
        ".LSFDE3:\n"
        "\t.long .LEFDE3-.LASFDE3\n"
        ".LASFDE3:\n"
        "\t.long .LASFDE3-.Lframe2\n"
        "\t.quad lj_vm_ffi_call\n"
        "\t.quad %d\n"
        "\t.uleb128 0\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE3:\n\n", (int)ctx->codesz - fcofs);
#endif
#endif
        break;
    default:
        break;
    }
}
