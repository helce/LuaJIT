|// Low-level VM code for E2K CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2021 Mike Pall. See Copyright Notice in luajit.h
|
|.arch e2k
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|.define RRET1,     r0
|.define RARG1,     r0
|.define RARG2,     r1
|.define RARG3,     r2
|.define RARG4,     r3
|.define RARG5,     r4
|.define RARG6,     r5
|.define RARG7,     r6
|.define RARG8,     r7
|
|.define CRET1,     b0
|.define CRET2,     b1
|.define CRET3,     b2
|.define CRET4,     b3
|.define CRET5,     b4
|.define CRET6,     b5
|.define CRET7,     b6
|.define CRET8,     b7
|.define CARG1,     b0
|.define CARG2,     b1
|.define CARG3,     b2
|.define CARG4,     b3
|.define CARG5,     b4
|.define CARG6,     b5
|.define CARG7,     b6
|.define CARG8,     b7
|
|// Used to pass arguments without dropping pipeline state.
|.define PARG1,     r52
|.define PARG2,     r53
|.define PARG3,     r54
|.define PARG4,     r55
|.define PARG5,     r56
|.define PARG6,     r57
|.define PARG7,     r58
|.define PARG8,     r59
|
|.define BASE,      r4
|.define KBASE,     r5
|.define STACK,     r6
|.define PC,        r7
|.define DISPATCH,  r8
|
|// Callee saved temporary registers.
|.define S0,        r9
|.define S1,        r10
|
|.define RA,        r11
|.define RB,        r12
|.define RC,        r13
|.define RD,        r14
|.define ITYPE,     r15
|
|// Temporary (volatile) registers.
|.define T0,        g16
|.define T1,        g17
|.define T2,        g18
|.define T3,        g19
|.define T4,        g20
|.define T5,        g21
|.define T6,        g22
|.define T7,        g23
|.define T8,        g24
|.define T9,        g25
|.define T10,       g26
|.define T11,       g27
|.define T12,       g28
|.define T13,       g29
|.define T14,       g30
|.define T15,       g31
|
|// Pipeline state.
|.define INSN_F,      b0
|.define INSN_S,      b2        // fetched instruction
|.define INSN_D,      b4
|.define INSN_L,      b6
|.define INSN_B,      b8
|.define INSN_E,      b10
|.define OP_S,        b12
|.define OP_D,        b14       // scaled opcode
|.define OP_L,        b16       // extracted opcode
|.define OP_B,        b18
|.define OP_E,        b20
|.define OP_W,        b22
|.define DISPATCH_L,  b24
|.define DISPATCH_B,  b26       // dispatch pointer
|.define DISPATCH_E,  b28
|.define BYPASS_E,    b30
|.define BYPASS_W,    b32       // RA_E of previous insn or -1
|.define RA_L,        b1
|.define RA_B,        b3        // scaled RA
|.define RA_E,        b5        // extracted RA
|.define RA_W,        b7
|.define RB_L,        b9
|.define RB_B,        b11       // scaled RB
|.define RB_E,        b13       // extracted RB
|.define RB_W,        b15
|.define RCD_L,       b17
|.define RCD_B,       b19       // scaled RC/RD
|.define RC_B,        b21
|.define RC_E,        b23       // extracted RC
|.define RC_W,        b25
|.define RD_B,        b27
|.define RD_E,        b29       // extracted RD
|.define RD_W,        b31
|.define RESULT_E,    b33
|.define RESULT_W,    b35       // result of last insn if BYPASS_W is not -1
|
|.macro do_fault
| addd 0, 0x0, 0x0, RARG1
| --
| ldd 0, RARG1, 0x0, RARG1
| --
|.endmacro
|
|// Type definitions. Some of these are only used for documentation.
|.type L,           lua_State
|.type GL,          global_State
|.type TVALUE,      TValue
|.type GCOBJ,       GCobj
|.type STR,         GCstr
|.type TAB,         GCtab
|.type LFUNC,       GCfuncL
|.type CFUNC,       GCfuncC
|.type PROTO,       GCproto
|.type UPVAL,       GCupval
|.type NODE,        Node
|.type NARGS,       int
|.type TRACE,       GCtrace
|.type SBUF,        SBuf
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|//-----------------------------------------------------------------------
|.define CFRAME_SPACE,  0x70                // 8*6 + 8*8
|.define STACK_SPACE,   -CFRAME_SPACE       // -(8*6 + 8*8)
|.define STACK_TMP,     0x68
|.define SAVE_CFRAME,   0x60
|.define SAVE_PC,       0x58
|.define SAVE_L,        0x50
|.define SAVE_ERRF,     0x4c
|.define SAVE_NRES,     0x48
|.define MULTRES,       0x40
|.define RESERVE_CARGS, 0x0                 // 8*8
|
|//-----------------------------------------------------------------------
|// Helper macros.
|//-----------------------------------------------------------------------
|
|.macro todo
| ldd   0, 0x0, 0x0, T15
| --
| addd  0, T15, raw(0xdeadbeef), T15
| --
|.endmacro
|
|// Setup the register window for function call.
|.macro setwd_call
| setwd     wsz = 0xc, nfx = 0x1, dbl = 0x0
| setbn     rsz = 0x3, rbs = 0x8, rcur = 0x0
|.endmacro
|
|.macro wait_impl, n, latency
|.if n + 1 >= latency
| // nop 0
|.elif n + 2 >= latency
| nop 1
|.elif n + 3 >= latency
| nop 2
|.elif n + 4 >= latency
| nop 3
|.elif n + 5 >= latency
| nop 4
|.elif n + 6 >= latency
| nop 5
|.elif n + 7 >= latency
| nop 6
|.elif n + 8 >= latency
| nop 7
|.else
| nop 7
| --
|.endif
|.endmacro
|
|// Insert nops until resource is ready to use.
|//
|// Paramters:
|//       res - needed resource (just hint)
|//         n - current cycle
|//   latency - total count of cycles
|.macro wait, res, n, latency
| wait_impl n + 0x00, latency
| wait_impl n + 0x08, latency
| wait_impl n + 0x10, latency
| wait_impl n + 0x18, latency
| wait_impl n + 0x20, latency
| wait_impl n + 0x28, latency
|.endmacro
|
|.define LATENCY_LOAD, 3                    // v4
|.define LATENCY_PRED, 1 + 1                // v4, 1 cycle extra delay
|.define LATENCY_PRED_CT, 1 + 2             // v4, 2 cycles extra delay
|
|// Insert nops until load result is ready to use.
|.macro wait_load_extra, reg, done, extra
| wait reg, done, LATENCY_LOAD + extra
|.endmacro
|
|// Insert nops until load result is ready to use.
|.macro wait_load, reg, done
| wait reg, done, LATENCY_LOAD
|.endmacro
|
|// Insert nops until predicate register is ready to use for conditional execution.
|.macro wait_pred, reg, done
| wait reg, done, LATENCY_PRED
|.endmacro
|
|// Insert nops until predicate register is ready to use by ct instruction.
|.macro wait_pred_ct, reg, done
| wait reg, done, LATENCY_PRED_CT
|.endmacro
|
|//-----------------------------------------------------------------------
|// Instruction fetch and decode in a software pipeline.
|//-----------------------------------------------------------------------
|
|// Stages:
|//   Fetch       - fetch insn
|//   Scale       - scale opcode
|//   Decode      - extract opcode
|//   Load        - load dispatch, scale other fields
|//   Branch      - prepare and jump to dispatch, extract other fields, update pc
|//   Execute     - execute
|
|// State changes:
|//   *_F => *_S
|//   *_S => *_D
|//   *_D => *_L
|//   *_L => *_B
|//   *_B => *_E
|//   *_E => unavaiable
|
|// Fetch:
|//   | ldwsm     0, PC, 20, INSN_F             // PC + (NUM_STAGES - 1) * 4
|//                                             // TODO: use APB for insn loading?
|
|// Scale:
|//   | shldsm    0, INSN_S, 0x3, OP_S
|
|// Decode:
|//   | anddsm    0, OP_D, 0x7f8, OP_D
|
|// Load:
|//   | lddsm     0, OP_L, DISPATCH, DISPATCH_L
|//   | shrdsm    1, INSN_L, 0x5, RA_L
|//   | shrdsm    2, INSN_L, 0x15, RB_L
|//   | shrdsm    3, INSN_L, 0xd, RCD_L
|
|// Branch:
|//   | movtdsm   0, DISPATCH_B, ctpr3
|//   | anddsm    1, RA_B, 0x7f8, RA_B
|//   | anddsm    2, RB_B, 0x7f8, RB_B
|//   | anddsm    3, RCD_B, 0x7f8, RC_B
|//   | anddsm    4, RCD_B, 0x7fff8, RD_B
|//   | --
|//   | abnt
|//   | addd      0, PC, 4, PC
|//   | ct        ctpr3
|
|// Execute(bypass):
|//   | cmpedb    1, BYPASS_W, RB_E, pred0  // check if prev insn write to BASE+RB_E
|//   | ldd       3, BASE, RB_E, T0
|//   | cmpedb    4, BYPASS_W, RC_E, pred1  // check if prev insn write to BASE+RC_E
|//   | ldd       5, BASE, RC_E, T1
|//   | --
|//   | nop
|//   | --
|//   | addd      3, 0, RESULT_W, RB_E, pred0   // use result of prev insn for RB
|//   | addd      5, 0, RESULT_W, RC_E, pred1   // use result of prev insn for RC
|//   | --
|//   | faddd     3, RB_E, RC_E, RESULT_E   // produce result of this insn
|//   | addd      4, RA_E, 0, BYPASS_E      // notify next insn that this insn write to BASE+RA_E
|//   | wait      RESULT_E, 0, 4
|//   | --
|//   | std       BASE, RA_E, RESULT_E
|//   | --
|
|// Execute(nobypass):
|//   | subd      0, 0, 1, BYPASS_E         // disable bypass for next insn
|//   | --
|
|// Prologue expected state:
|//   PC  Stage   Expect
|//    0  E       INSN_E, OP_E, RA_E, RB_E, RC_E, RD_E, DISPATCH_E, BYPASS_W
|//    4  B       INSN_B, OP_B, RA_B, RB_B, RCD_B, DISPATCH_B
|//    8  L       INSN_L, OP_L, RA_L, RB_L, RCD_L
|//   12  D       INSN_D, OP_D
|//   16  S       INSN_S
|//   20  F
|
|// Prologue example:
|//   | setwd_pipe
|//   | --
|//   | ldwsm     0, PC, 0, INSN_E
|//   | ldwsm     2, PC, 4, INSN_B
|//   | ldwsm     3, PC, 8, INSN_L
|//   | ldwsm     5, PC,12, INSN_D
|//   | wait_load INSN_E, 0
|//   | --
|//   | ldwsm     0, PC,16, INSN_S
|//   | shldsm    1, INSN_E, 0x3, OP_E
|//   | shldsm    2, INSN_B, 0x3, OP_B
|//   | shldsm    3, INSN_L, 0x3, OP_L
|//   | shldsm    5, INSN_D, 0x3, OP_D
|//   | --
|//   | anddsm    0, OP_E, 0x7f8, OP_E
|//   | anddsm    2, OP_B, 0x7f8, OP_B
|//   | anddsm    3, OP_L, 0x7f8, OP_L
|//   | --
|//   | lddsm     0, OP_E, DISPATCH, DISPATCH_E
|//   | lddsm     2, OP_B, DISPATCH, DISPATCH_B
|//   | shrdsm    1, INSN_E, 0x5, RA_E
|//   | shrdsm    3, INSN_E, 0x15, RB_E
|//   | shrdsm    4, INSN_E, 0xd, T0
|//   | --
|//   | anddsm    1, RA_E, 0x7f8, RA_E
|//   | anddsm    3, RB_E, 0x7f8, RB_E
|//   | anddsm    4, T0, 0x7f8, RC_E
|//   | anddsm    5, T0, 0x7fff8, RD_E
|//   | --
|//   | shrdsm    0, INSN_B, 0x5, RA_B
|//   | shrdsm    1, INSN_B, 0x15, RB_B
|//   | shrdsm    2, INSN_B, 0xd, RCD_B
|//   | subd      3, 0, 1, BYPASS_E         // Disable bypass for current insn.
|//   | wait_load DISPATCH_E, 2
|//   | --
|//   |.if isa > 6
|//   | ibranchd  0, DISPATCH_E, empty
|//   | --
|//   |.else
|//   | movtdsm   0, DISPATCH_E, ctpr3
|//   | --
|//   | ct        ctpr3
|//   | --
|//   |.endif
|
|// Pipeline example with helper macros:
|//   | pipe_dispatch_prep 0, ctpr3
|//   | pipe_fetch 2
|//   | pipe_dispatch_load 3
|//   | --
|//   | pipe_scale 0, 1, 2, 3
|//   | pipe_bypass_none 4
|//   | --
|//   | pipe_extract 0, 1, 2, 3, 4
|//   | --
|//   | pipe_dispatch 0, ctpr3
|//   | --
|
|//-----------------------------------------------------------------------
|// Helper macros for software pipelining.
|//-----------------------------------------------------------------------
|
|// Setup register window for the software pipeline.
|//   r0 ..r15 - window registers
|//   b0 ..b27 - pipeline (based/rotating) registers
|//   r44..r52 - callee argument registers
|.macro setwd_pipe
| setwd     wsz = 0x1e, nfx = 0x1, dbl = 0x0
| setbn     rsz = 0x11, rbs = 0x8, rcur = 0x0
|.endmacro
|
|.macro pipe_call, ctpr
| call ctpr, wbs=0x1a
|.endmacro
|
|.macro pipe_call_if, ctpr, pred
| call ctpr, wbs=0x1a, pred
|.endmacro
|
|// Stage F
|.macro pipe_fetch, ch
| //ldwsm     ch, PC, 20, INSN_F
| ldwsm     ch, PC, 16, INSN_F          // FIXME: PC is NPC!!!
|.endmacro
|
|// Stage S
|.macro pipe_scale_op, ch
| shldsm    ch, INSN_S, 0x3, OP_S
|.endmacro
|
|// Stage L
|.macro pipe_scale_a, ch
| shrdsm    ch, INSN_L, 0x5, RA_L
|.endmacro
|
|// Stage L
|.macro pipe_scale_b, ch
| shrdsm    ch, INSN_L, 0x15, RB_L
|.endmacro
|
|// Stage L
|.macro pipe_scale_cd, ch
| shrdsm    ch, INSN_L, 0xd, RCD_L
|.endmacro
|
|// Stage S/L
|.macro pipe_scale, ch0, ch1, ch2, ch3
| pipe_scale_op ch0
| pipe_scale_a ch1
| pipe_scale_b ch2
| pipe_scale_cd ch3
|.endmacro
|
|// Stage D
|.macro pipe_extract_op, ch
| anddsm    ch, OP_D, 0x7f8, OP_D
|.endmacro
|
|// Stage B
|.macro pipe_extract_a, ch
| anddsm    ch, RA_B, 0x7f8, RA_B
|.endmacro
|
|// Stage B
|.macro pipe_extract_b, ch
| anddsm    ch, RB_B, 0x7f8, RB_B
|.endmacro
|
|// Stage B
|.macro pipe_extract_c, ch
| anddsm    ch, RCD_B, 0x7f8, RC_B
|.endmacro
|
|// Stage B
|.macro pipe_extract_d, ch
| anddsm    ch, RCD_B, 0x7fff8, RD_B
|.endmacro
|
|// Stage D/B
|.macro pipe_extract, ch0, ch1, ch2, ch3, ch4
| pipe_extract_op ch0
| pipe_extract_a ch1
| pipe_extract_b ch2
| pipe_extract_c ch3
| pipe_extract_d ch4
|.endmacro
|
|// Stage L
|.macro pipe_dispatch_load, ch
| lddsm     ch, OP_L, DISPATCH, DISPATCH_L
|.endmacro
|
|// Stage B
|.macro pipe_dispatch_prep, ch, ctpr
| movtdsm   ch, DISPATCH_B, ctpr
|.endmacro
|
|// Stage B
|.macro pipe_dispatch, ch, ctpr
| abnt
| addd      ch, PC, 4, PC
| ct        ctpr
|.endmacro
|
|// Stage B
|.macro pipe_dispatch_if, ch, ctpr, pred
| abnt
| addd      ch, PC, 4, PC, pred
| ct        ctpr, pred
|.endmacro
|
|// Stage E
|.macro pipe_bypass_check, ch, reg, pred
| cmpedb    ch, BYPASS_W, reg, pred
|.endmacro
|
|// Stage E
|.macro pipe_bypass_use, ch, reg, pred
| addd      ch, RESULT_W, 0, reg, pred
|.endmacro
|
|// Stage E
|.macro pipe_bypass_some, ch, reg
| addd      ch, reg, 0, BYPASS_E
|.endmacro
|
|// Stage E
|.macro pipe_bypass_some_if, ch, reg, pred
| addd      ch, reg, 0, BYPASS_E, pred
|.endmacro
|
|// Stage E
|.macro pipe_bypass_none, ch
| subd      ch, 0, 1, BYPASS_E
|.endmacro
|
|.macro pipe_next
| pipe_dispatch_prep 0, ctpr3
| pipe_fetch 2
| pipe_dispatch_load 3
| --
| pipe_scale 0, 1, 2, 3
| pipe_bypass_none 4
| --
| pipe_extract 0, 1, 2, 3, 4
| --
| wait_load OP_L, 3
| pipe_dispatch 0, ctpr3
| --
|.endmacro
|
|.macro pipe_restart_fast, dispatch, pc
| // (BCOp *)
| // PC
| movtd     0, dispatch, ctpr3              // Prepare an insn handler for stage E.
| ldw       2, pc, 0, T0
| ldwsm     3, pc, 4, T1
| --
| ldwsm     0, pc,12, INSN_D
| ldwsm     2, pc,16, INSN_S
| ldwsm     3, pc, 8, T2
| --
| addd      4, pc, 4, PC                    // FIXME: insn hanlders expect it to be NPC but not current PC
| wait_load T0, 2
| --
| shldsm    2, T0, 3, OP_E
| shldsm    3, T1, 3, OP_B
| --
| addd      0, T0, 0, INSN_E
| addd      1, T1, 0, INSN_B
| anddsm    2, OP_E, 0x7f8, OP_E
| anddsm    3, OP_B, 0x7f8, OP_B
| --
| shrd      0, T0, 0x5, RA_E
| shrd      1, T0, 0x15, RB_E
| shrd      3, T0, 0xd, T8
| addd      4, dispatch, 0, DISPATCH_E
| lddsm     5, OP_B, DISPATCH, DISPATCH_B
| --
| subd      0, 0, 1, BYPASS_W
| andd      1, RA_E, 0x7f8, RA_E
| andd      2, RB_E, 0x7f8, RB_E
| andd      3, T8, 0x7f8, RC_E
| andd      4, T8, 0x7fff8, RD_E
| shldsm    5, T2, 3, OP_L
| --
| shldsm    0, INSN_D, 3, OP_D
| shrdsm    1, INSN_B, 0x5, RA_B
| shrdsm    2, INSN_B, 0x15, RB_B
| shrdsm    3, INSN_B, 0xd, RCD_B
| anddsm    4, OP_L, 0x7f8, OP_L
| addd      5, T2, 0, INSN_L
| --
| ct        ctpr3                           // Jump to the insn handler for stage E.
| --
|.endmacro
|
|//-----------------------------------------------------------------------
|// Instruction decode+dispatch.
|.macro ins_NEXT             // AD = {D |A|OP}, ABC = {B|C|A|OP}, AC = {lo_D|A|OP}
| disp      ctpr1, ->vm_restart_pipeline    // TODO: inline/optimize
| --
| ct        ctpr1                           // vm_restart_pipeline
| --
|.endmacro
|
|// Instruction footer.
|.if 1
| // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
| .define ins_next, ins_NEXT
| .define ins_next_, ins_NEXT
|.else
| // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
| // Affects only certain kinds of benchmarks (and only with -j off).
| // Around 10%-30% slower on Core2, a lot more slower on P4.
| .macro ins_next
|   disp ctpr1, ->ins_next
| .endmacro
| .macro ins_next_
| ->ins_next:
|   ins_NEXT
| .endmacro
|.endif
|
|// Call decode and dispatch.
|.macro ins_callt
| // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, [BASE-8] = PC
| ldd       0, RB, LFUNC->pc, RARG1
| disp      ctpr1, ->vm_enter_pipeline      // TODO: optimize
| --
| ct        ctpr1
| wait_load RARG1, 1
| --
|.endmacro
|
|.macro ins_call
| // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, PC = caller PC
| ldd       0, RB, LFUNC->pc, RARG1
| std       2, BASE, -8, PC
| disp      ctpr1, ->vm_enter_pipeline      // TODO: optimize
| --
| ct        ctpr1
| wait_load RARG1, 1
| --
|.endmacro
|
|//-----------------------------------------------------------------------
|.define PC_OP, 0                           // Byte
|.define PC_RA, 1                           // Byte
|.define PC_RB, 3                           // Byte
|.define PC_RC, 2                           // Byte
|.define PC_RD, 2                           // Halfword
|
|.define PREV_PC_OP, -4                     // Byte
|.define PREV_PC_RA, -3                     // Byte
|.define PREV_PC_RB, -1                     // Byte
|.define PREV_PC_RC, -2                     // Byte
|.define PREV_PC_RD, -2                     // Halfword
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)      (GG_DISP2G + (int)offsetof(global_State, field))
#define PC2PROTO(field)         ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|//-----------------------------------------------------------------------

/* Generate subroutines used by opcodes and other parts of the VM */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
    |.code_sub
    |
    |//-----------------------------------------------------------------------
    |//-- Return handling ----------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_returnp:
    | // RA, RD
    | disp ctpr1, ->cont_dispatch
    | --
    | cmpandesb 0, PC, FRAME_P, pred0
    | nop 2
    | --
    | ct ctpr1, pred0
    | andd 3, PC, raw(0xfff8), PC, ~pred0
    | subd 4, RA, 0x8, RA, ~pred0
    | --
    |
    | // Return from pcall or xpcall fast func
    | subd 3, BASE, PC, BASE                // Restore caller base.
    | addd 4, RA, PC, RA                    // Rebase RA and prepend one result.
    | addd 5, 0x0, U64x(0xfffeffff,0xffffffff), ITYPE
    | --
    | ldd 3, BASE, -8, PC                   // Fetch PC of previous frame.
    | --
    | // Prepending may overwrite the pcall frame, so do it at the end.
    | std 5, BASE, RA, ITYPE                // Prepend true to results.
    | --
    |
    |->vm_returnc:
    | // BASE = base, RA = resultptr, RD = nresults*8, PC = return
    | addd      0, 0x0, LUA_YIELD, CRET1    // used in vm_unwind_c_eh
    | addd      1, RD, 0x8, RD              // RD = (nresults+1)*8
    | disp      ctpr1, ->vm_unwind_c_eh
    | --
    | cmpandedb 0, PC, FRAME_TYPE, pred1
    | cmpedb    1, RD, 0x0, pred0
    | disp      ctpr2, ->BC_RET_Z
    | wait_pred_ct pred0, 0
    | --
    | stw       2, STACK, MULTRES, RD, ~pred0
    | ct        ctpr1, pred0                // vm_unwind_c_eh(TODO)
    | --
    | ct        ctpr2, pred1                // BC_RET_Z(RA, RD, PC)
    |                                       // Handle regular return to Lua.
    | --
    |
    |->vm_return:
    | // BASE = base, RA = resultofs, RD/MULTRES = (nresults+1)*8, PC = return
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | --
    | xord 1, PC, FRAME_C, PC
    | subd 2, 0x0, 0x8, S1
    | addd 3, RA, 0x0, CARG4
    | subd 4, RD, 0x8, CARG3
    | ldd 5, STACK, SAVE_L, RB
    | disp ctpr1, ->vm_returnp
    | --
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | andd 1, PC, S1, S1
    | addd 2, 0x0, ~LJ_VMST_C, S0
    | cmpedb 3, CARG3, 0x0, pred1
    | disp ctpr2, >2
    | --
    | ldw 0, STACK, SAVE_NRES, RA, pred0
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), S0, pred0
    | subd 3, S1, BASE, PC, pred0
    | ct        ctpr1, ~pred0               // vm_returnp(RA)
    | --
    | return ctpr3
    | --
    | ldw 0, STACK, MULTRES, RD
    | subd 3, 0x0, PC, PC                   // Previous base = BASE - delta
    | disp ctpr1, >1
    | --
    | shld 0, RA, 0x3, RA                   // RA = wanted (nresults+1)*8
    | std 5, RB, L->base, PC
    | ct        ctpr2, pred1                // >2
    |1:                                     // Move results down.
    | ldd 3, BASE, CARG4, S1
    | subd 4, CARG3, 0x8, CARG3
    | --
    | cmpedb 4, CARG3, 0x0, pred0
    | wait_pred_ct pred0, 0
    | wait_load S1, 1
    | --
    | addd 3, BASE, 0x8, BASE
    | std 5, BASE, -16, S1
    | ct        ctpr1, ~pred0               // <1
    |2:
    | disp ctpr1, >4
    | --
    | cmpesb 0, RA, RD, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // >4, More/less results wanted?
    |3:
    | addd 2, 0x0, 0x0, RRET1               // Ok return status for vm_pcall.
    | ldd 3, STACK, SAVE_CFRAME, S0         // Restore previous C frame.
    | subd 4, BASE, 0x10, BASE
    | nop 1
    | --
    | std 5, RB, L->top, BASE
    | --
    | std 5, RB, L->cframe, S0
    | ct        ctpr3                       // return
    |4:
    | ldd 3, RB, L->maxstack, S0
    | addd 4, 0x0, LJ_TNIL, S1
    | disp ctpr1, >5
    | nop 1
    | --
    | cmpbsb 0, RA, RD, pred0
    | disp ctpr2, >6
    | --
    | cmpbedb 3, BASE, S0, pred1
    | nop 1
    | --
    | ct        ctpr1, pred0                // >5, Less results wanted?
    | --
    | disp ctpr1, <4
    | --
    | subd 3, BASE, 0x10, S0, pred1
    | ct        ctpr2, ~pred1               // >6, Need to grow stack?
    | --
    | addd 3, BASE, 0x8, BASE
    | adds 4, RD, 0x8, RD
    | std 5, S0, 0x0, S1                    // Check stack size and fill up results with nil.
    | return ctpr3
    | --
    | cmpesb 0, RA, RD, pred0
    | nop 1
    | --
    | ldd 3, STACK, SAVE_CFRAME, S0, pred0 // Restore previous C frame.
    | subd 4, BASE, 0x10, BASE, pred0
    | ct        ctpr1, ~pred0               // <4, More/less results wanted?
    | --
    | addd 0, 0x0, 0x0, RRET1               // Ok return status for vm_pcall.
    | std 5, RB, L->top, BASE
    | nop 1
    | --
    | std 5, RB, L->cframe, S0
    | ct        ctpr3                       // return
    |5:                                     // Less results wanted.
    | disp ctpr1, <3
    | --
    | cmpesb    0, RA, 0x0, pred0
    | wait_pred pred0, 0
    | --
    | subd      0, RA, RD, RA, ~pred0       // Negative result!
    | --
    | addd      0, BASE, RA, BASE, ~pred0   // Correct top.
    | ct        ctpr1                       // <3
    | --
    |
    |6:
    | // Corner case: need to grow stack for filling up results.
    | // This can happen if:
    | // - A C function grows the stack (a lot).
    | // - The GC shrinks the stack in between.
    | // - A return back from a lua_call() with (high) nresults adjustment.
    |
    | disp ctpr1, extern lj_state_growstack
    | --
    | adds 0, RA, 0x0, CARG2
    | addd 1, RB, 0x0, CARG1
    | stw 2, STACK, MULTRES, RD
    | std 5, RB, L->top, BASE               // Save current top held in BASE (yes).
    | --
    | call      ctpr1, wbs = 0x8            // lj_state_growstack (lua_State *L, int n)
    | --
    | ldw 0, STACK, MULTRES, RD
    | ldw 2, STACK, SAVE_NRES, RA
    | ldd 3, RB, L->top, BASE               // Need the (realloced) L->top in BASE
    | disp ctpr1, <4
    | nop 2
    | --
    | shld 0, RA, 0x3, RA
    | ldd 2, STACK, SAVE_CFRAME, S0       // Restore previous C frame.
    | return ctpr3
    | --
    | cmpesb 0, RA, RD, pred0
    | --
    | addd 0, 0x0, 0x0, RRET1, pred0        // Ok return status for vm_pcall.
    | subd 3, BASE, 0x10, BASE, pred0
    | ct        ctpr1, ~pred0               // <4, More/less results wanted?
    | --
    | std 2, RB, L->cframe, S0
    | std 5, RB, L->top, BASE
    | ct        ctpr3                       // return
    | --
    |
    |->vm_unwind_c:                         // Unwind C stack, return from vm_pcall.
    | // (void *cframe, int errcode)
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | addd 0, RARG1, 0x0, STACK
    | addd 1, RARG2, 0x0, CRET1             // Error return status for vm_pcall.
    | --
    |->vm_unwind_c_eh:                      // Landing pad for external unwinder.
    | ldd 0, STACK, SAVE_L, RB
    | addd 1, CRET1, 0x0, RRET1
    | return ctpr3
    | nop 2
    | --
    | ldd 0, RB, L->glref, RB
    | addd 1, 0x0, ~LJ_VMST_C, S0
    | nop 2
    | --
    | stw 2, RB, GL->vmstate, S0
    | ct ctpr3
    | --
    |
    |->vm_unwind_ff:                        // Unwind C stack, return from ff pcall.
    | // (void *cframe)
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | andd 0, RARG1, CFRAME_RAWMASK, RARG1
    | --
    | addd 0, RARG1, 0x0, STACK
    | --
    |->vm_unwind_ff_eh:                     //  Landing pad for external unwinder.
    | ldd 0, STACK, SAVE_L, RB
    | addd 3, 0x0, (1+1)*8, RD              // Really 1+2 results, incr. later.
    | disp ctpr1, ->vm_returnc
    | --
    | addd 0, 0x0, ~LJ_VMST_INTERP, S0
    | addd 3, 0x0, U64x(0xffff7fff,0xffffffff), RA
    | nop 1
    | --
    | ldd 0, RB, L->glref, DISPATCH         // Setup pointer to dispatch table.
    | ldd 2, RB, L->base, BASE
    | nop 2
    | --
    | ldd 0, BASE, -8, PC           // Fetch PC of previous frame.
    | addd 1, DISPATCH, GG_G2DISP, DISPATCH
    | ldd 3, BASE, 0x0, RB
    | nop 2
    | --
    | std 2, BASE, -8, RB
    | std 5, BASE, -16, RA           // Prepend false to error message.
    | --
    | subd 3, 0x0, 0x10, RA                 // Results start at BASE+RA = BASE-16.
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), S0
    | ct ctpr1                              // Increments RD/MULTRES and returns.
    | --
    |
    |//-----------------------------------------------------------------------
    |//-- Grow stack for calls -----------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_growstack_c:                      // Grow stack for C function.
    | // RB = L, L->base = new base, L->top = top
    | disp      ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    | --
    | setwd_call
    | --
    | addd      0, 0x0, LUA_MINSTACK, CARG2
    | addd      1, RB, 0x0, CARG1
    | --
    | call      ctpr1, wbs = 0x8            // lj_state_growstack(lua_State *L, int n)
    | --
    | ldd       3, RB, L->base, BASE
    | ldd       5, RB, L->top, RD
    | wait_load BASE, 0
    | --
    | ldd       3, BASE, -16, RB
    | subd      4, RD, BASE, RD
    | wait_load RB, 0
    | --
    | getfd     3, RB, (47 << 6), RB
    | addd      4, RD, 0x8, RD
    | --
    | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8
    | ins_callt                             // Just retry the call
    |
    |->vm_growstack_v:                      // Grow stack for vararg Lua function.
    | // PC, RD = top, RB = lua_State *L
    | setwd_call
    | ldb       0, PC, PC2PROTO(framesize)-4, RA
    | addd      1, PC, 0x4, PC              // Must point after first instruction.
    | subd      3, RD, 0x10, RD             // LJ_FR2
    | --
    | disp      ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    | --
    | std       2, STACK, SAVE_PC, PC
    | std       5, RB, L->base, BASE
    | --
    | addd      0, RA, 0x0, CARG2
    | addd      3, RB, 0x0, CARG1
    | std       5, RB, L->top, RD
    | call      ctpr1, wbs = 0x8            // lj_state_growstack(lua_State *L, int n)
    | --
    | // RB = L, L->base = new base, L->top = top
    | ldd       3, RB, L->base, BASE
    | ldd       5, RB, L->top, RD
    | wait_load BASE, 0
    | --
    | ldd       3, BASE, -16, RB
    | subd      4, RD, BASE, RD
    | wait_load RB, 0
    | --
    | getfd     3, RB, (47 << 6), RB
    | addd      4, RD, 0x8, RD
    | --
    | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8
    | ins_callt                             // Just retry the call
    |
    |->vm_growstack_f:                      // Grow stack for fixarg Lua function.
    | // BASE = new base, RD = (nargs+1)*8, RB = L, PC = first PC
    | disp      ctpr1, extern lj_state_growstack
    | --
    | setwd_call
    | ldb       0, PC, PC2PROTO(framesize)-4, RA
    | addd      1, PC, 0x4, PC              // Must point after first instruction.
    | addd      3, BASE, RD, RD
    | --
    | std       2, STACK, SAVE_PC, PC
    | subd      3, RD, 0x8, RD
    | std       5, RB, L->base, BASE
    | wait_load RA, 1
    | --
    | addd      0, RA, 0x0, CARG2
    | addd      3, RB, 0x0, CARG1
    | std       5, RB, L->top, RD
    | --
    | call      ctpr1, wbs = 0x8            // lj_state_growstack(lua_State *L, int n)
    | --
    | // RB = L, L->base = new base, L->top = top
    | ldd       3, RB, L->base, BASE
    | ldd       5, RB, L->top, RD
    | wait_load BASE, 0
    | --
    | ldd       3, BASE, -16, RB
    | subd      4, RD, BASE, RD
    | wait_load RB, 0
    | --
    | getfd     3, RB, (47 << 6), RB
    | addd      4, RD, 0x8, RD
    | --
    | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8
    | ins_callt                             // Just retry the call
    |
    |//-----------------------------------------------------------------------
    |//-- Entry points into the assembler VM ---------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_resume:                           // Setup C frame and resume thread.
    | // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | disp ctpr1, >2
    | --
    | getsp 0, STACK_SPACE, STACK
    | addd 1, RARG1, 0x0, RB
    | --
    | addd 0, 0x0, 0x0, RD
    | addd 1, 0x0, FRAME_CP, PC
    | ldd 2, RB, L->glref, DISPATCH         // Setup pointer to dispatch table.
    | --
    | addd 1, RARG2, 0x0, RA
    | ldb 3, RB, L->status, S0
    | addd 4, STACK, CFRAME_RESUME, KBASE
    | --
    | std 2, STACK, SAVE_CFRAME, RD
    | stw 5, STACK, SAVE_NRES, RD
    | --
    | stw 2, STACK, SAVE_ERRF, RD
    | std 5, RB, L->cframe, KBASE
    | --
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | std 2, STACK, SAVE_PC, RD             // Any value outside of bytecode is ok.
    | cmpedb 3, S0, 0x0, pred0
    | nop 2
    | --
    | std 2, STACK, SAVE_L, RARG1
    | ct ctpr1, pred0                       // Initial resume (like a call).
    | --
    |
    | // Resume after yield (like a return).
    | ldd 3, RB, L->base, BASE
    | ldd 5, RB, L->top, S1
    | disp ctpr2, ->BC_RET_Z
    | --
    | addd 1, 0x0, ~LJ_VMST_INTERP, S0
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    | disp      ctpr1, ->vm_return
    | --
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), S0
    | stb 5, RB, L->status, RD
    | --
    | ldd 3, BASE, -8, PC
    | subd 4, S1, RA, RD
    | subd 5, RA, BASE, RA                  // RA = resultofs
    | --
    | addd 3, RD, 0x8, RD                   // RD = (nresults+1)*8
    | --
    | stw 2, STACK, MULTRES, RD
    | --
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | nop 2
    | --
    | ct ctpr2, pred0
    | --
    | ct        ctpr1                       // vm_return(RA, RD)
    | --
    |
    |->vm_pcall:                            // Setup protected C frame and enter VM.
    | // (lua_State *L, TValue *base, int news1, ptrdiff_t ef)
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | disp ctpr1, >1
    | --
    | getsp 0, STACK_SPACE, STACK
    | addd 1, 0x0, FRAME_CP, PC
    | nop 1
    | --
    | stw 2, STACK, SAVE_ERRF, RARG4
    | ct ctpr1
    | --
    |
    |->vm_call:                             // Setup C frame and enter VM.
    | // (lua_State *L, TValue *base, int nres1)
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | --
    | getsp 0, STACK_SPACE, STACK
    | addd 1, 0x0, FRAME_C, PC
    |
    |1: // Entry point for vm_pcall above (PC = ftype)
    | std 2, STACK, SAVE_L, RARG1
    | addd 3, RARG2, 0x0, RA
    | addd 4, RARG1, 0x0, RB
    | stw 5, STACK, SAVE_NRES, RARG3
    | --
    | ldd 0, RB, L->glref, DISPATCH            // Setup pointer to dispatch table.
    | ldd 3, RB, L->cframe, KBASE              // Add our C frame to cframe chain.
    | nop 3
    | --
    | std 2, STACK, SAVE_CFRAME, KBASE
    | std 5, STACK, SAVE_PC, RB                // Any value outsize of bytecode is ok.
    | --
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | std 2, RB, L->cframe, STACK
    |
    |2: // Entry point for vm_resume/vm_cpcall (RA = base, RB = L, PC = ftype)
    | addd 0, PC, RA, PC
    | addd 1, 0x0, ~LJ_VMST_INTERP, S0
    | ldd 3, RB, L->base, BASE              // BASE = old base (used in vmeta_call).
    | ldd 5, RB, L->top, RD
    | disp ctpr1,  ->vmeta_call
    | --
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    | --
    | ldd 0, RA, -16, RB                    // RB = LFUNC
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), S0
    | nop 1
    | --
    | subd 0, PC, BASE, PC                  // PC = frame delta + frame type
    | addd 3, RA, 0x0, CARG2
    | --
    | sard 0, RB, 0x2f, ITYPE
    | getfd 1, RB, (47 << 6), RB
    | subd 3, RD, CARG2, RD
    | --
    | lddsm 0, RB, LFUNC->pc, RARG1
    | cmpesb 1, ITYPE, LJ_TFUNC, pred0
    | addd 3, RD, 0x8, RD                   // RD = (nargs+1)*8
    |                                       // used in insn handler
    | nop 1
    | --
    | addd 3, CARG2, 0x0, BASE, pred0       // BASE = new base
    | ct ctpr1, ~pred0
    | --
    | std 2, BASE, -8, PC                   // [BASE-8] = PC
    | --
    |
    |->vm_enter_pipeline:
    | // (PC)
    | // RD = (nargs+1)*8
    | // RB = (nresults+1)*8
    | setwd_pipe
    | --
    | ldw       0, RARG1, 0, INSN_E         // Load insns.
    | ldwsm     2, RARG1, 4, INSN_B
    | ldwsm     3, RARG1, 8, INSN_L
    | ldwsm     5, RARG1,12, INSN_D
    | --
    | ldwsm     0, RARG1,16, INSN_S
    | addd      1, RARG1, 0x4, PC           // FIXME: insn hanlders expect it to be NPC but not current PC
    | wait_load INSN_E, 1
    | --
    | shld      0, INSN_E, 0x3, OP_E        // Scale opcode fields.
    | shldsm    2, INSN_B, 0x3, OP_B
    | shldsm    3, INSN_L, 0x3, OP_L
    | shldsm    5, INSN_D, 0x3, OP_D
    | --
    | andd      0, OP_E, 0x7f8, OP_E        // Extract opcode fields.
    | anddsm    2, OP_B, 0x7f8, OP_B
    | anddsm    3, OP_L, 0x7f8, OP_L
    | --
    | ldd       0, OP_E, DISPATCH, DISPATCH_E   // Load pointers to insn handlers.
    | lddsm     2, OP_B, DISPATCH, DISPATCH_B
    | shrd      1, INSN_E, 0x5, RA_E        // Scale other fields for stage E.
    | --
    | andd      1, RA_E, 0x7f8, RA_E        // Extract other fields for stage E.
    | ldbsm     0, 0, 0, RC_E
    | addd      3, RD, 0, RD_E
    | addd      4, RB, 0, RB_E
    | wait_load DISPATCH_E, 1
    | --
    | movtd     0, DISPATCH_E, ctpr3        // Prepare an insn handler for stage E.
    | subd      1, 0, 1, BYPASS_W
    | shrdsm    3, INSN_B, 0x5, RA_B        // Scale other fields for stage B.
    | shrdsm    4, INSN_B, 0x15, RB_B
    | shrdsm    5, INSN_B, 0xd, RCD_B
    | --
    | ct        ctpr3                       // Jump to the insn handler for stage E.
    | --
    |
    |->vm_restart_pipeline:
    | // PC
    | ldb       0, PC, PC_OP, RARG1
    | wait_load RARG1, 0
    | --
    | shld      0, RARG1, 3, RARG1
    | --
    | ldd       0, RARG1, DISPATCH, RARG1   // E: Load pointer to insn handler.
    | wait_load RARG1, 0
    | --
    | // fallthrough
    |
    |->vm_restart_pipeline_fast_win:
    | // (BCOp *)
    | // PC
    | setwd_pipe
    | pipe_restart_fast RARG1, PC
    |
    |// Restart without reconfiguring the register window.
    |->vm_restart_pipeline_fast:
    | // (BCOp *)
    | // PC
    | pipe_restart_fast RARG1, PC
    |
    |->vm_restart_pipeline_static:
    | // PC
    | setwd_pipe
    | --
    | ldw       0, PC, 0, INSN_E            // Load insns.
    | ldwsm     2, PC, 4, INSN_B
    | ldwsm     3, PC, 8, INSN_L
    | ldwsm     5, PC,12, INSN_D
    | --
    | ldwsm     0, PC,16, INSN_S
    | addd      1, PC, 4, PC                // FIXME: insn hanlders expect it to be NPC but not current PC
    | wait_load INSN_E, 1
    | --
    | shld      0, INSN_E, 3, OP_E          // Scale opcode fields.
    | shldsm    2, INSN_B, 3, OP_B
    | shldsm    3, INSN_L, 3, OP_L
    | shldsm    5, INSN_D, 3, OP_D
    | --
    | andd      0, OP_E, 0x7f8, OP_E        // Extract opcode fields.
    | anddsm    2, OP_B, 0x7f8, OP_B
    | anddsm    3, OP_L, 0x7f8, OP_L
    | --
    | addd      0, OP_E, DISPATCH, DISPATCH_E
    | --
    | ldd       0, DISPATCH_E, GG_DISP2STATIC, DISPATCH_E   // Load pointers to insn handlers.
    | lddsm     2, OP_B, DISPATCH, DISPATCH_B
    | shrd      1, INSN_E, 0x5, RA_E        // Scale other fields for stage E.
    | shrd      3, INSN_E, 0x15, RB_E
    | shrd      4, INSN_E, 0xd, T0
    | --
    | subd      0, 0, 1, BYPASS_W
    | andd      1, RA_E, 0x7f8, RA_E        // Extract other fields for stage E.
    | andd      3, RB_E, 0x7f8, RB_E
    | andd      4, T0, 0x7f8, RC_E
    | andd      5, T0, 0x7fff8, RD_E
    | wait_load DISPATCH_E, 1
    | --
    | movtd     0, DISPATCH_E, ctpr3        // Prepare an insn handler for stage E.
    | shrdsm    3, INSN_B, 0x5, RA_B        // Scale other fields for stage B.
    | shrdsm    4, INSN_B, 0x15, RB_B
    | shrdsm    5, INSN_B, 0xd, RCD_B
    | --
    | ct        ctpr3                       // Jump to the insn handler for stage E.
    | --
    |
    |// Restart pipeline with a custom RA field.
    |->vm_restart_pipeline_static_ra:
    | // PC, RA
    | setwd_pipe
    | --
    | ldw       0, PC, 0, INSN_E            // Load insns.
    | ldwsm     2, PC, 4, INSN_B
    | ldwsm     3, PC, 8, INSN_L
    | ldwsm     5, PC,12, INSN_D
    | --
    | ldwsm     0, PC,16, INSN_S
    | addd      1, PC, 4, PC                // FIXME: insn hanlders expect it to be NPC but not current PC
    | wait_load INSN_E, 1
    | --
    | shld      0, INSN_E, 3, OP_E          // Scale opcode fields.
    | shldsm    2, INSN_B, 3, OP_B
    | shldsm    3, INSN_L, 3, OP_L
    | shldsm    5, INSN_D, 3, OP_D
    | --
    | andd      0, OP_E, 0x7f8, OP_E        // Extract opcode fields.
    | anddsm    2, OP_B, 0x7f8, OP_B
    | anddsm    3, OP_L, 0x7f8, OP_L
    | --
    | addd      0, OP_E, DISPATCH, DISPATCH_E
    | --
    | ldd       0, DISPATCH_E, GG_DISP2STATIC, DISPATCH_E   // Load pointers to insn handlers.
    | lddsm     2, OP_B, DISPATCH, DISPATCH_B
    | shrd      3, INSN_E, 0x15, RB_E       // Scale other fields for stage E.
    | shrd      4, INSN_E, 0xd, T0
    | --
    | subd      0, 0, 1, BYPASS_W
    | addd      1, RA, 0, RA_E              // Extract other fields for stage E.
    | andd      3, RB_E, 0x7f8, RB_E
    | andd      4, T0, 0x7f8, RC_E
    | andd      5, T0, 0x7fff8, RD_E
    | wait_load DISPATCH_E, 1
    | --
    | movtd     0, DISPATCH_E, ctpr3        // Prepare an insn handler for stage E.
    | shrdsm    3, INSN_B, 0x5, RA_B        // Scale other fields for stage B.
    | shrdsm    4, INSN_B, 0x15, RB_B
    | shrdsm    5, INSN_B, 0xd, RCD_B
    | --
    | ct        ctpr3                       // Jump to the insn handler for stage E.
    | --
    |
    |->vm_cpcall:                           // Setup protected C frame, call C.
    | // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    | --
    | getsp 0, STACK_SPACE, STACK
    | addd 1, RARG1, 0x0, RB
    | ldd 2, RARG1, L->top, S1
    | --
    | ldd 0, RB, L->stack, S0
    | ldd 2, RB, L->glref, DISPATCH         // Setup pointer to dispatch table.
    | nop 1
    | --
    | movtd 0, RARG4, ctpr1
    | std 2, STACK, SAVE_L, RB
    | --
    | subd 0, S0, S1, S0
    | addd 1, 0x0, 0x0, S1
    | std 2, STACK, SAVE_PC, RB
    | --
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | stw 2, STACK, SAVE_ERRF, S1           // No error function.
    | --
    | ldd 0, RB, L->cframe, S0
    | stw 2, STACK, SAVE_NRES, S0           // Neg. delta means cframe w/o frame.
    | --
    | addd 0, RARG1, 0x0, CARG1
    | std 2, STACK, SAVE_CFRAME, S0
    | --
    | addd 0, RARG2, 0x0, CARG2
    | std 2, RB, L->cframe, STACK
    | --
    | addd 0, RARG3, 0x0, CARG3
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    | call ctpr1, wbs = 0x8                 // (lua_State *L, lua_CFunction func, void *ud)
    | --
    | // TValue * (new base) or NULL returned.
    | lddsm 0, STACK, SAVE_CFRAME, S0       // Restore previous C frame.
    | cmpedb 1, CRET1, 0x0, pred0
    | disp ctpr1, <2
    | --
    | return ctpr3
    | nop 1
    | --
    | addd 0, 0x0, 0x0, RRET1, pred0        // Ok return status for vm_pcall.
    | std 2, RB, L->cframe, S0, pred0
    | ct ctpr3, pred0
    | --
    | addd 0, CRET1, 0x0, RA
    | addd 1, 0x0, FRAME_CP, PC
    | ct ctpr1                              // Else continue with the call.
    | --
    |
    |//-----------------------------------------------------------------------
    |//-- Metamethod handling ------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |//-- Continuation dispatch ----------------------------------------------
    |
    |->cont_dispatch:
    | // BASE = meta base, RA = resultofs, RD = (nresults+1)*8 (also in MULTRES)
    | andd 2, PC, raw(0xfff8), PC
    | addd 3, BASE, RA, RA
    | addd 4, BASE, 0x0, RB
    | addd 5, 0x0, LJ_TNIL, S0
    | disp ctpr2, >1
    | --
    | subd 3, BASE, PC, BASE                // Restore caller BASE.
    | addd 4, RA, RD, S1
    | addd 5, RA, 0x0, CRET1
    | disp ctpr1, ->cont_ffi_callback
    | --
    | ldd 0, RB, -24, PC                    // Restore PC from [cont|PC].
    | ldd 2, RB, -32, RA
    | disp ctpr3, ->vm_call_tail
    | --
    | lddsm 3, BASE, -16, CARG2
    | --
    | cmpbedb 0, RA, 0x1, pred0
    | cmpedb 1, RA, 0x1, pred1
    | std 5, S1, -8, S0                     // Ensure one valid arg.
    | nop 2
    | --
    |.if FFI
    | ct ctpr2, pred0
    | --
    |.endif
    | movtd 0, RA, ctpr1
    | getfd 3, CARG2, (47 << 6), KBASE
    | --
    | ldd 3, KBASE, LFUNC->pc, KBASE
    | nop 2
    | --
    | ldd 3, KBASE, PC2PROTO(k), KBASE
    | nop 1
    | --
    | ct ctpr1                              // Jump to continuation.
    | --
    | // BASE = base, CRET1 = result, RB = meta base
    |
    |.if FFI
    |1:
    | subd 0, RB, BASE, RB, ~pred1
    | ct ctpr1, pred1                       // cont = 1: return from FFI callback.
    | --
    | // cont = 0: Tail call from C function.
    | subd 0, RB, 0x18, RD
    | ct ctpr3
    | --
    |.endif
    |
    |->cont_cat:                            // BASE = base, CRET1 = result, RB = mbase
    | setwd_call
    | ldb       0, PC, PREV_PC_RB, T3
    | lddsm     2, CRET1, 0x0, S0
    | subd      3, RB, 0x20, RB
    | disp      ctpr1, ->cont_ra
    | --
    | disp      ctpr2, ->BC_CAT_Z
    | wait_load T3, 1
    | --
    | shld      3, T3, 0x3, CARG3
    | --
    | addd      3, BASE, CARG3, CARG3
    | --
    | subd      3, CARG3, RB, CARG3
    | --
    | cmpedb    3, CARG3, 0x0, pred0
    | wait_pred_ct pred0, 0
    | --
    | ldd       0, STACK, SAVE_L, CARG1, ~pred0
    | subd      1, 0x0, CARG3, CARG3
    | ct        ctpr1, pred0                // cont_ra(PC, CRET1)
    | --
    | shrd      0, CARG3, 0x3, CARG3
    | addd      1, RB, 0x0, CARG2
    | std       2, RB, 0x0, S0
    | nop 1
    | --
    | std       2, CARG1, L->base, BASE
    | ct        ctpr2                       // !!! CARG1-CARG3(lua_State *L, TValue *top, int left)
    | --
    |
    |//-- Table indexing metamethods -----------------------------------------
    |
    |->cont_nop:                            // BASE = base, (CRET1 = result)
    | ins_next
    |
    |->vmeta_tgets:
    | // (RB, RC)
    | disp      ctpr1, >1
    | addd      0, 0x0, LJ_TSTR, ITYPE
    | ldb       2, PC, PREV_PC_OP, S1
    | --
    | shld      0, ITYPE, 0x2f, ITYPE
    | addd      1, DISPATCH, DISPATCH_GL(tmptv), S0     // Store GStr * in g->tmptv
    | addd      2, DISPATCH, DISPATCH_GL(tmptv2), T2    // Store fn->l.env in g->tmptv2.
    | --
    | ord       0, RC, ITYPE, RC            // RC = GCstr *
    | addd      1, 0x0, LJ_TTAB, RA
    | --
    | cmpedb    0, S1, BC_GGET, pred0
    | shld      1, RA, 0x2f, RA
    | std       2, S0, 0x0, RC
    | --
    | addd      0, S0, 0x0, RC
    | ord       1, RA, RB, RA               // RB = GCtab * ?
    | --
    | addd      0, BASE, RB_E, RB, ~pred0
    | addd      1, T2, 0x0, RB, pred0
    | std       2, T2, 0x0, RA, pred0
    | ct        ctpr1                       // >1
    | --
    |
    |->vmeta_tgetb:
    | // PC
    | ldb       0, PC, PREV_PC_RC, S1
    | addd      1, BASE, RB_E, RB
    | addd      2, RA_E, 0, RA
    | disp      ctpr1, >1
    | wait_load S1, 0
    | --
    | istofd    0, S1, S0
    | addd      2, DISPATCH, DISPATCH_GL(tmptv), RC
    | wait      S0, 0, 4
    | --
    | std       2, RC, 0x0, S0
    | ct        ctpr1                       // >1
    | --
    |
    |->vmeta_tgetv:
    | addd      0, BASE, RC_E, RC
    | addd      1, BASE, RB_E, RB
    | addd      2, RA_E, 0, RA
    | --
    |1:                                     // entry point for vmeta_tgets and vmeta_tgetb
    | disp      ctpr1, extern lj_meta_tget
    | --
    | setwd_call
    | --
    | ldd       0, STACK, SAVE_L, CARG1
    | addd      1, RB, 0x0, CARG2
    | addd      2, RC, 0x0, CARG3
    | --
    | std       2, CARG1, L->base, BASE
    | addd      3, CARG1, 0x0, RB
    | --
    | std       2, STACK, SAVE_PC, PC
    | call      ctpr1, wbs = 0x8            // lj_meta_tget(lua_State *L, TValue *o, TValue *k)
    | --
    | // TValue * (finished) or NULL (metamethod) returned.
    | cmpedb    0, CRET1, 0x0, pred0
    | ldd       3, RB, L->base, BASE
    | disp      ctpr3, >2
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr3, pred0                // >2
    | --
    |
    |->cont_ra:                             // BASE = base, CRET1 = result
    | ldd       0, CRET1, 0x0, T2
    | ldb       2, PC, PREV_PC_RA, T3
    | disp      ctpr1, ->vm_restart_pipeline    // TODO: inline
    | wait_load T3, 0
    | --
    | shld      0, T3, 0x3, T3
    | --
    | std       2, BASE, T3, T2
    | ct        ctpr1                       // vm_restart_pipeline
    | --
    |
    |2:                                     // Call __index metamethod.
    | // BASE = base, L->top = new base, stack = cont/func/t/k
    | ldd       3, RB, L->top, RA
    | wait_load RA, 0
    | --
    | addd      4, RA, FRAME_CONT, PC
    | std       5, RA, -24, PC              // [RA-24] cont|PC
    | --
    | subd      2, PC, BASE, PC
    | ldd       3, RA, -16, RB              // [RA-16] Guaranteed to be a function here.
    | addd      4, 0x0, (2+1)*8, RD         // (2+1)*8 args for func(t, k)
    | --
    | getfd     3, RB, (47 << 6), RB
    | addd      4, RA, 0x0, BASE
    | --
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |
    |->vmeta_tgetr:
    | // RA, RB, RC
    | disp      ctpr1, extern lj_tab_getinth
    | --
    | setwd_call
    | --
    | addd      0, RB, 0x0, CARG1
    | adds      1, RC, 0x0, CARG2
    | --
    | call      ctpr1, wbs = 0x8            // lj_tab_getinth(GCtab *t, int32_t key)
    | --
    | // cTValue * or NULL returned.
    | disp      ctpr1, ->vm_restart_pipeline // TODO: inline
    | --
    | cmpedb    1, CRET1, 0x0, pred0
    | lddsm     2, CRET1, 0x0, ITYPE
    | wait_pred pred0, 0
    | --
    | addd      2, 0x0, LJ_TNIL, ITYPE, pred0
    | wait_load ITYPE, LATENCY_PRED
    | --
    | std       2, BASE, RA, ITYPE
    | ct        ctpr1                       // vm_restart_pipeline(PC)
    | --
    |
    |//-----------------------------------------------------------------------
    |
    |->vmeta_tsets:
    | // RA, RB, RC
    | setwd_call
    | ldb       0, PC, PREV_PC_OP, S0
    | addd      1, 0x0, LJ_TSTR, ITYPE
    | ldbsm     2, PC, PREV_PC_RB, T1       // Reload TValue *t from RB.
    | addd      3, 0x0, LJ_TTAB, T2
    | disp      ctpr1, >1
    | --
    | shld      0, ITYPE, 0x2f, ITYPE
    | shld      1, T2, 0x2f, CARG2
    | --
    | ord       0, RC, ITYPE, S1            // STR:RC = GCstr *
    | addd      1, STACK, STACK_TMP, CARG3
    | wait_load S0, 2
    | --
    | cmpedb    0, S0, BC_GSET, pred0
    | shld      1, T1, 0x3, T1
    | std       2, STACK, STACK_TMP, S1
    | wait_pred pred0, 0
    | --
    | addd      0, BASE, T1, CARG2, ~pred0
    | ord       1, CARG2, RB, RA, pred0        // RB = GCtab *
    | addd      2, DISPATCH, DISPATCH_GL(tmptv), CARG2, pred0 // Store fn->l.env in g->tmptv
    | --
    | std       2, CARG2, 0x0, RA, pred0
    | ct        ctpr1                       // >1
    | --
    |
    |->vmeta_tsetb:
    | setwd_call
    | ldb       0, PC, PREV_PC_RC, S0
    | ldb       2, PC, PREV_PC_RB, RB       // Reload TValue *t from RB.
    | disp      ctpr1, >1
    | wait_load S0, 0
    | --
    | istofd    0, S0, S0
    | shld      1, RB, 0x3, RB
    | wait      S0, 0, 2
    | --
    | addd      0, STACK, STACK_TMP, CARG3
    | addd      1, BASE, RB, CARG2
    | std       2, STACK, STACK_TMP, S0
    | ct        ctpr1                       // >1
    | --
    |
    |->vmeta_tsetv:
    | setwd_call
    | ldb       0, PC, PREV_PC_RC, RC       // Reload TValue *k from RC.
    | ldb       2, PC, PREV_PC_RB, RB       // Reload TValue *t from RB.
    | wait_load RC, 0
    | --
    | shld      0, RC, 0x3, RC
    | shld      1, RB, 0x3, RB
    | --
    | addd      0, BASE, RC, CARG3
    | addd      1, BASE, RB, CARG2
    |1:                                     // entry point for vmeta_tsets and vmeta_tsetb
    | disp      ctpr1, extern lj_meta_tset
    | --
    | ldd       0, STACK, SAVE_L, CARG1
    | --
    | std       2, STACK, SAVE_PC, PC
    | --
    | std       2, CARG1, L->base, BASE
    | addd      0, CARG1, 0x0, RB
    | call      ctpr1, wbs = 0x8            // lj_meta_tset(lua_State *L, TValue *o, TValue *k)
    | --
    | // TValue * (finished) or NULL (metamethod) returned.
    | cmpedb    0, CRET1, 0x0, pred0
    | disp      ctpr1, >2
    | wait_pred_ct pred0, 0
    | --
    | ldd       3, RB, L->base, BASE
    | ct        ctpr1, pred0                // >2
    | --
    | // NOBARRIER: lj_meta_tset ensures the table is not black.
    | disp      ctpr1, ->vm_restart_pipeline    // TODO: inline
    | ldb       0, PC, PREV_PC_RA, T2
    | wait_load T2, 0
    | --
    | shld      0, T2, 0x3, T2
    | --
    | ldd       0, BASE, T2, T3
    | wait_load T3, 0
    | --
    | std       2, CRET1, 0x0, T3
    | ct        ctpr1                       // vm_restart_pipeline
    |
    |2: // Call __newindex metamethod
    | // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
    | // Copy value to third argument.
    | ldd       0, RB, L->top, RA
    | ldb       2, PC, PREV_PC_RA, RC
    | disp      ctpr1, ->vm_enter_pipeline
    | wait_load RA, 0
    | --
    | std       2, RA, -24, PC              // [cont|PC]
    | shld      3, RC, 0x3, RC
    | --
    | addd      0, RA, FRAME_CONT, PC
    | ldd       3, BASE, RC, RB
    | wait_load RB, 0
    | --
    | subd      0, PC, BASE, PC
    | std       2, RA, 0x10, RB
    | --
    | ldd       3, RA, -16, RB              // Guaranteed to be a function here.
    | addd      4, 0x0, (3+1)*8, RD         // 3 args for func (t, k, v)
    | wait_load RB, 0
    | --
    | getfd     3, RB, (47 << 6), RB
    | addd      4, RA, 0x0, BASE
    | --
    | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, PC = caller PC
    | ldd       2, RB, LFUNC->pc, RARG1
    | std       5, BASE, -8, PC
    | wait_load RARG1, 0
    | ct        ctpr1                       // vm_enter_pipeline
    | --
    |
    |->vmeta_tsetr:
    | // RA, RB, RC
    | disp      ctpr1, extern lj_tab_setinth
    | --
    | setwd_call
    | ldd       0, STACK, SAVE_L, T1
    | --
    | addd      0, RB, 0x0, CARG2
    | adds      1, RC, 0x0, CARG3
    | std       2, STACK, SAVE_PC, PC
    | wait_load T1, 1
    | --
    | addd      0, T1, 0, CARG1
    | std       2, T1, L->base, BASE
    | call      ctpr1, wbs = 0x8            // lj_tab_setinth(lua_State *L, GCtab *t, int32_t key)
    | --
    | // TValue * returned.
    | ldd       0, BASE, RA, ITYPE
    | disp      ctpr1, ->vm_restart_pipeline // TODO: inline
    | wait_load ITYPE, 0
    | --
    | std       2, CRET1, 0x0, ITYPE
    | ct        ctpr1                       // vm_restart_pipeline(PC)
    | --
    |
    |//-- Comparison metamethods ---------------------------------------------
    |
    |->cont_condt:
    | // BASE = base, CRET1 = result
    | ldd       0, CRET1, 0x0, ITYPE
    | addd      1, PC, 0x4, PC
    | --
    | ldh       0, PC, PREV_PC_RD, S0
    | subd      1, PC, BCBIAS_J*4, S1
    | wait_load ITYPE, 1
    | --
    | sard      0, ITYPE, 0x2f, ITYPE
    | --
    | cmpbsb    0, ITYPE, LJ_TISTRUECOND, pred0
    | shld      1, S0, 0x2, S0
    | wait_pred pred0, 0
    | --
    | addd      0, S1, S0, PC, pred0        // Branch if result is true.
    | --
    | ins_next                              // TODO: inline
    |
    |->cont_condf:                          // BASE = base, CRET1 = result
    | ldd       0, CRET1, 0x0, ITYPE
    | addd      1, PC, 0x4, PC
    | --
    | ldh       0, PC, PREV_PC_RD, S0
    | subd      1, PC, BCBIAS_J*4, S1
    | wait_load ITYPE, 0
    | --
    | sard      0, ITYPE, 0x2f, ITYPE
    | --
    | cmpbsb    0, ITYPE, LJ_TISTRUECOND, pred0
    | shld      1, S0, 0x2, S0
    | wait_pred pred0, 0
    | --
    | addd      0, S1, S0, PC, ~pred0       // Branch if result is false.
    | --
    | ins_next                              // TODO: inline
    |
    |->vmeta_equal:
    | // RA, RB, RD
    | disp      ctpr1, extern lj_meta_equal
    | --
    | setwd_call
    | ldd       0, STACK, SAVE_L, RB
    | addd      1, RB, 0x0, T4
    | getfd     3, RD, (47 << 6), RD
    | --
    | ldh       0, PC, PREV_PC_RD, S0
    | subd      2, PC, 0x4, PC
    | subd      3, PC, BCBIAS_J*4, S1
    | wait_load RB, 1
    | --
    | addd      0, RA, 0x0, CARG2
    | addd      1, RB, 0x0, CARG1
    | std       2, RB, L->base, BASE
    | addd      3, T4, 0x0, CARG4
    | --
    | addd      0, RD, 0x0, CARG3
    | shld      1, S0, 0x2, S0
    | std       2, STACK, SAVE_PC, PC
    | call      ctpr1, wbs = 0x8            // lj_meta_equal(lua_State *L, GCobj *o1, *o2, int ne)
    | --
    | // 0/1 or TValue * (metamethod) returned.
    | cmpbedb   0, CRET1, 0x1, pred0
    | cmpbdb    1, CRET1, 0x1, pred1
    | addd      2, S1, 0x4, S1
    | ldd       3, RB, L->base, BASE
    | disp      ctpr2, ->vmeta_binop
    | wait      ctpr2, 0, 5
    | --
    | addd      0, PC, 0x4, PC, pred0
    | ct        ctpr2, ~pred0               // vmeta_binop(BASE, CRET1)
    | --
    | addd      0, S1, S0, PC, ~pred1
    | --
    | ins_next
    |
    |->vmeta_equal_cd:
    |.if FFI
    | disp      ctpr1, extern lj_meta_equal_cd
    | --
    | setwd_call
    | ldd       0, STACK, SAVE_L, RB
    | subd      1, PC, 0x4, PC
    | --
    | ldw       0, PC, PREV_PC_OP, CARG2
    | ldh       2, PC, PREV_PC_RD, S0
    | --
    | subd      0, PC, BCBIAS_J*4, S1
    | addd      1, RB, 0x0, CARG1
    | std       2, RB, L->base, BASE
    | --
    | addd      0, S1, 0x4, S1
    | shld      1, S0, 0x2, S0
    | std       2, STACK, SAVE_PC, PC
    | call      ctpr1, wbs = 0x8            // lj_meta_equal_cd(lua_State *L, BCIns ins)
    | --
    | // 0/1 or TValue * (metamethod) returned.
    | cmpbedb   0, CRET1, 0x1, pred0
    | cmpbdb    1, CRET1, 0x1, pred1
    | ldd       3, RB, L->base, BASE
    | disp      ctpr2, ->vmeta_binop
    | --
    | addd      0, PC, 0x4, PC, pred0
    | ct        ctpr2, ~pred0               // vmeta_binop(CRET1)
    | --
    | addd      0, S1, S0, PC, ~pred1
    | --
    | ins_next
    |.endif
    |
    |->vmeta_istype:
    | // RA, RD
    | disp      ctpr1, extern lj_meta_istype
    | --
    | setwd_call
    | ldd       0, STACK, SAVE_L, RB
    | wait_load RB, 0
    | --
    | std       2, RB, L->base, BASE
    | shrd      0, RD, 0x3, CARG3
    | shrd      1, RA, 0x3, CARG2
    | --
    | addd      1, RB, 0x0, CARG1
    | std       2, STACK, SAVE_PC, PC
    | call      ctpr1, wbs = 0x8            // lj_meta_istype(lua_State *L, BCReg ra, BCReg tp)
    | --
    | ldd       3, RB, L->base, BASE
    | --
    | ins_next
    |
    |//-- Arithmetic metamethods ---------------------------------------------
    |
    |.macro vmeta_arith_base
    | disp      ctpr1, extern lj_meta_arith
    | --
    | setwd_call
    | --
    | ldb       0, PC, PREV_PC_OP, CARG5
    | addd      1, RA, 0x0, CARG2
    | ldd       2, STACK, SAVE_L, CARG1
    | wait_load CARG1, 0
    | --
    | addd      0, RC, 0x0, CARG4
    | addd      1, RB, 0x0, CARG3
    | std       2, CARG1, L->base, BASE
    | --
    | addd      0, CARG1, 0x0, RB
    | std       2, STACK, SAVE_PC, PC
    | call      ctpr1, wbs = 0x8            // lj_meta_arith(lua_State *L, TValue *ra, *rb, *rc, BCReg op)
    | --
    | // NULL (finished) or TValue * (metamethod) returned.
    | ldd       3, RB, L->base, BASE
    | cmpedb    4, CRET1, 0x0, pred0
    | disp      ctpr2, ->cont_nop
    | --
    | disp      ctpr1, ->vmeta_binop
    | wait_pred_ct pred0, 1
    | --
    | ct        ctpr2, pred0                // cont_nop(TODO), TODO: vm_restart_pipeline
    | --
    | ct        ctpr1                       // vmeta_binop(TODO)
    | --
    |.endmacro
    |
    |->vmeta_arith_vn:
    | addd 3, KBASE, RC_E, RC
    | addd 4, BASE, RB_E, RB
    | addd 5, BASE, RA_E, RA
    | --
    | vmeta_arith_base
    |
    |->vmeta_arith_nv:
    | addd 3, KBASE, RC_E, RB
    | addd 4, BASE, RB_E, RC
    | addd 5, BASE, RA_E, RA
    | --
    | vmeta_arith_base
    |
    |->vmeta_unm:
    | addd 3, BASE, RD_E, RC
    | addd 4, BASE, RD_E, RB
    | addd 5, BASE, RA_E, RA
    | --
    | vmeta_arith_base
    |
    |->vmeta_arith_vv:
    | addd 3, BASE, RC_E, RC
    | addd 4, BASE, RB_E, RB
    | addd 5, BASE, RA_E, RA
    | --
    | vmeta_arith_base
    |
    | // Call metamethod for binary op.
    |->vmeta_binop:
    | // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
    | addd      0, CRET1, 0x0, RA
    | subd      1, CRET1, BASE, CRET1
    | --
    | addd      1, CRET1, FRAME_CONT, PC
    | std       2, RA, -24, PC              // [cont|PC]
    | addd      3, 0x0, (2+1)*8, RD         // 2 args for func(o1, o2).
    | --
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    | ldd       0, RA, -16, RB
    | disp      ctpr1, ->vmeta_call
    | wait_load RB, 0
    | --
    | sard      3, RB, 0x2f, ITYPE
    | getfd     4, RB, (47 << 6), RB
    | --
    | cmpesb    3, ITYPE, LJ_TFUNC, pred0
    | wait_pred_ct pred0, 0
    | --
    | addd      3, RA, 0x0, BASE, pred0
    | ct        ctpr1, ~pred0               // vmeta_call(RA, RD)
    | --
    | ins_call
    |
    |->vmeta_len:
    | // BASE
    | disp      ctpr1, extern lj_meta_len
    | --
    | setwd_call
    | ldh       0, PC, PREV_PC_RD, RD
    | ldd       2, STACK, SAVE_L, RB
    | wait_load RD, 0
    | --
    | shld      3, RD, 0x3, RD
    | std       5, RB, L->base, BASE
    | --
    | std       2, STACK, SAVE_PC, PC
    | addd      3, BASE, RD, CARG2
    | addd      4, RB, 0x0, CARG1
    | call      ctpr1, wbs = 0x8            // lj_meta_len(lua_State *L, TValue *o)
    | --
    | // NULL (retry) or TValue * (metamethod) returned.
    | ldd       3, RB, L->base, BASE
    | disp      ctpr2, ->vmeta_binop        // Binop call for compatibility.
    | wait_load BASE, 0
    | --
#if LJ_52
    | cmpedb    0, CRET1, 0x0, pred0
    | ldd       3, BASE, RD, CARG1
    | disp      ctpr1, ->BC_LEN_Z
    | wait_pred_ct pred0, 0
    | wait_load CARG1, 0
    | --
    | ct        ctpr2, ~pred0               // vmeta_binop(CARG1)
    | --
    | getfd     0, CARG1, (47 << 6), RD
    | ct        ctpr1                       // BC_LEN_Z(RD)
    | --
#else
    | ct        ctpr2                       // vmeta_binop(CARG1)
    | --
#endif
    |
    |//-- Call metamethod ----------------------------------------------------
    |
    |->vmeta_call:                          // Resolve and call __call metamethod.
    | // BASE = old base, RA = new base, RD = (nargs+1)*8
    | setwd_call
    | disp ctpr1, extern lj_meta_call       // (lua_State *L, TValue *func, TValue *top)
    | --
    | ldd 0, STACK, SAVE_L, CARG1
    | subd 1, RA, 0x10, CARG2
    | addd 2, RA, RD, CARG3
    | nop 2
    | --
    | subd 1, CARG3, 0x8, CARG3
    | std 2, CARG1, L->base, BASE
    | --
    | std 2, STACK, SAVE_PC, PC
    | call ctpr1, wbs = 0x8
    | --
    | ldd 0, STACK, SAVE_L, S0
    | ldd 2, RA, -16, RB
    | disp ctpr2, ->BC_CALLT_Z
    | nop 2
    | --
    | ldd 3, S0, L->base, BASE
    | addd 4, RD, 0x8, RD
    | nop 2
    | --
    | // This is fragile. L->base must not move, KBASE must always be defined.
    | cmpedb 3, KBASE, BASE, pred0
    | nop 2
    | --
    | getfd 3, RB, (47 << 6), RB, ~pred0
    | addd 4, RA, 0x0, BASE, ~pred0
    | ct ctpr2, pred0                       // Continue with CALLT if flag set.
    | --
    | ins_call                              // Otherwise call resolved metamethod.
    |
    |//-- Argument coercion for 'for' statement ------------------------------
    |
    |->vmeta_for:
    | // RA
    | disp      ctpr1, extern lj_meta_for
    | --
    | setwd_call
    | ldd       0, STACK, SAVE_L, RB
    | wait_load RB, 0
    | --
    | addd      1, RB, 0x0, CARG1
    | std       2, RB, L->base, BASE
    | addd      3, RA, 0x0, CARG2
    | --
    | std       2, STACK, SAVE_PC, PC
    | call      ctpr1, wbs = 0x8            // lj_meta_for(lua_State *L, TValue *base)
    | --
    | disp      ctpr1, ->vm_restart_pipeline_static // TODO: inline
    | subd      0, PC, 4, PC                // Current PC.
    | ldd       3, RB, L->base, BASE
    | --
    | ct        ctpr1                       // vm_restart_pipeline_static(PC)
    | --
    |
    |//-----------------------------------------------------------------------
    |//-- Fast functions -----------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |// Inlined GC threshold check.
    |// Setup the registers window for a call.
    |// Invalidate ctpr1 and ctpr2. Prepare ctpr3 to ->fff_fallback.
    |.macro ffgccheck
    | // RD = (nargs+1)*8
    | setwd_call
    | ldd       0, DISPATCH, DISPATCH_GL(gc.total), S1
    | ldd       2, DISPATCH, DISPATCH_GL(gc.threshold), S0
    | ldd       3, STACK, SAVE_L, T1
    | disp      ctpr2, >1
    | --
    | disp      ctpr1, extern lj_gc_step
    | wait_load S0, 1
    | --
    | cmpbdb    0, S1, S0, pred0
    | disp      ctpr3, ->fff_fallback
    | wait_pred_ct pred0, 0
    | --
    | std       2, STACK, SAVE_PC, PC, ~pred0
    | addd      3, BASE, RD, RD, ~pred0
    | addd      4, T1, 0x0, RB, ~pred0
    | ct        ctpr2, pred0                // >1
    | --
    | addd      0, T1, 0, CARG1
    | std       2, T1, L->base, BASE
    | subd      3, RD, 0x8, RD
    | --
    | std       2, T1, L->top, RD
    | call      ctpr1, wbs = 0x8            // lj_gc_step(lua_State *L)
    | --
    | ldd       3, RB, L->base, BASE
    | ldd       5, RB, L->top, RD
    | disp      ctpr3, ->fff_fallback
    | wait_load RD, 0
    | --
    | subd      3, RD, BASE, RD
    | --
    | addd      3, RD, 0x8, RD
    |1:
    |.endmacro
    |
    |//-- Base library: checks -----------------------------------------------
    |
    |->ff_assert:
    | // RD_E
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, ITYPE
    | disp      ctpr1, ->fff_fallback
    | --
    | disp      ctpr2, ->fff_res
    | wait_load ITYPE, 1
    | --
    | addd      3, ITYPE, 0x0, RB
    | sard      4, ITYPE, 0x2f, ITYPE
    | --
    | cmpbdb    3, RD, (1+1)*8, pred0
    | cmpbsb    4, ITYPE, LJ_TISTRUECOND, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ldd       0, BASE, -8, PC
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    | stw       2, STACK, MULTRES, RD
    | subd      4, RD, 0x10, RD
    | std       5, BASE, -16, RB
    | --
    | cmpedb    3, RD, 0x0, pred0
    | disp      ctpr1, >1
    | wait_pred_ct pred0, 0
    | --
    | addd      3, RD, 0x10, RD, pred0
    | addd      4, BASE, 0x8, RA
    | ct        ctpr2, pred0                // fff_res(RD)
    |1:
    | ldd       3, RA, 0x0, RB
    | subd      4, RD, 0x8, RD
    | --
    | cmpedb    3, RD, 0x0, pred0
    | wait_pred_ct pred0, 0
    | wait_load RB, 1
    | --
    | addd      4, RA, 0x8, RA, ~pred0
    | std       5, RA, -16, RB
    | ct        ctpr1, ~pred0               // <1
    | --
    | ldw       0, STACK, MULTRES, RD
    | wait_load RD, 0
    | ct        ctpr2                       // fff_res(RD)
    | --
    |
    |->ff_type:
    | // RD_E
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, RC
    | adds      4, 0x0, LJ_TISNUM, RB
    | disp      ctpr1, ->fff_fallback
    | wait_load RC, 0
    | --
    | sard      3, RC, 0x2f, RC
    | cmpbdb    4, RD, (1+1)*8, pred0
    | --
    | cmpbsb    4, RC, RB, pred1
    | wait_pred pred1, 0
    | --
    | xors      3, RB, -1, RC, pred1
    | xors      4, RC, -1, RC, ~pred1
    | ct        ctpr1, pred0                // fff_fallback(RD)
    | --
    | ldd       0, BASE, -8, PC
    | ldd       3, BASE, -16, RB
    | shls      4, RC, 0x3, RC
    | disp      ctpr2, ->fff_res
    | nop 2
    | --
    | sxt       3, 0x6, RC, RC
    | getfd     4, RB, (47 << 6), RB
    | addd      5, 0x0, LJ_TSTR, ITYPE
    | --
    | addd      3, RB, RC, S0
    | shld      4, ITYPE, 0x2f, ITYPE
    | --
    | ldd       3, S0, ((char *)(&((GCfuncC *)0)->upvalue)), RC
    | wait_load RC, 0
    | --
    | ord       3, RC, ITYPE, RC
    | --
    | addd      4, 0x0, (1+1)*8, RD
    | std       5, BASE, -16, RC
    | ct        ctpr2                       // fff_res(RD)
    | --
    |
    |//-- Base library: getters and setters ---------------------------------
    |
    |->ff_getmetatable:
    | // RD_E
    | ldd       3, BASE, 0x0, RB
    | addd      4, RD_E, 0, RD
    | disp      ctpr1, ->fff_fallback
    | --
    | ldd       0, BASE, -8, PC
    | cmpbdb    3, RD, (1+1)*8, pred0
    | disp      ctpr2, >1
    | wait_load RB, 1
    | --
    | sard      3, RB, 0x2f, ITYPE
    | getfd     4, RB, (47 << 6), RB
    | --
    | cmpesb    3, ITYPE, LJ_TTAB, pred1
    | cmpesb    4, ITYPE, LJ_TUDATA, pred2
    | ct        ctpr1, pred0                // fff_fallback(RD)
    | --
    | // Field metatable must be at same offset for GCtab and GCudata!
    | lddsm     3, RB, TAB->metatable, RB
    | cmpbesb   4, ITYPE, LJ_TISNUM, pred3
    | disp      ctpr1, ->fff_res
    | --
    | addd      3, 0x0, LJ_TISNUM, ITYPE, pred3
    | addd      4, 0x0, LJ_TTAB, RC
    | pass      pred1, p0
    | pass      pred2, p1
    | landp     ~p0, ~p1, p4
    | pass      p4, pred0
    | --
    | shld      3, RC, 0x2f, RC
    | xord      4, ITYPE, -1, ITYPE
    | ct        ctpr2, ~pred0               // >1
    | --
    | shld      0, ITYPE, 0x3, S0
    | --
    | addd      0, S0, DISPATCH_GL(gcroot[GCROOT_BASEMT]), S0
    | --
    | ldd       0, DISPATCH, S0, RB
    | wait_load RB, 0
    | --
    |1:
    | lddsm     0, DISPATCH, DISPATCH_GL(gcroot)+8*(GCROOT_MMNAME+MM_metatable), S1
    | cmpedb    3, RB, 0x0, pred0
    | addd      4, 0x0, LJ_TNIL, S0
    | ord       5, RC, RB, RC
    | --
    | ldwsm     3, RB, TAB->hmask, RA
    | lddsm     5, RB, TAB->node, T1
    | --
    | addd      0, 0x0, LJ_TSTR, ITYPE
    | std       5, BASE, -16, RC, ~pred0   // Store metatable as default result.
    | --
    | shld      0, ITYPE, 0x2f, ITYPE
    | addd      4, 0x0, (1+1)*8, RD
    | std       5, BASE, -16, S0, pred0
    | ct        ctpr1, pred0                // fff_res(RD)
    | --
    | ldw       0, S1, STR->hash, S0
    | wait_load S0, 0
    | --
    | andd      0, RA, S0, RA
    | ord       1, S1, ITYPE, S1
    | disp      ctpr2, >3
    | --
    | smulx     0, RA, #NODE, RA
    | wait      RA, 0, 4 + 2                // extra fp->int penalty
    | --
    | addd      0, RA, T1, RA
    | --
    |2: // Rearranged logic, because we expect _not_ to find the key.
    | ldd       0, RA, NODE->key, S0
    | disp      ctpr3, <2
    | wait_load S0, 0
    | --
    | cmpedb    0, S0, S1, pred0
    | wait_pred_ct pred0, 0
    | --
    | ldd       0, RA, NODE->next, RA, ~pred0
    | ct        ctpr2, pred0                // >3
    | --
    | wait_load RA, 1
    | --
    | cmpedb    0, RA, 0x0, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr3, ~pred0               // <2
    | --
    | addd      3, 0x0, (1+1)*8, RD
    | ct        ctpr1                       // fff_res(RD), Not found, keep default result.
    |3:
    | ldd       0, RA, NODE->val, RB
    | addd      3, 0x0, (1+1)*8, RD
    | wait_load RB, 0
    | --
    | cmpedb    0, RB, LJ_TNIL, pred0
    | wait_pred pred0, 0
    | --
    | std       5, BASE, -16, RB, ~pred0    // Return value of mt.__metatable.
    | ct        ctpr1                       // fff_res(RD)
    | --
    |
    |->ff_setmetatable:
    | // RD_E
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, RB
    | disp      ctpr1, ->fff_fallback
    | --
    | ldd       0, BASE, 0x8, RA
    | wait_load RB, 1
    | --
    | addd      3, RB, 0x0, S1
    | sard      4, RB, 0x2f, ITYPE
    | getfd     5, RB, (47 << 6), RB
    | --
    | cmpbdb    3, RD, (2+1)*8, pred0
    | cmpesb    4, ITYPE, LJ_TTAB, pred1
    | lddsm     5, RB, TAB->metatable, S0
    | --
    | sard      3, RA, 0x2f, ITYPE
    | getfd     4, RA, (47 << 6), RA
    | --
    | cmpesb    0, ITYPE, LJ_TTAB, pred2
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | cmpedbsm  3, S0, 0x0, pred1
    | ct        ctpr1, ~pred0
    | --
    | pass      pred1, p0
    | pass      pred2, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ldd       0, BASE, -8, PC, pred0
    | lddsm     2, DISPATCH, DISPATCH_GL(gc.grayagain), T1
    | ldbsm     3, RB, TAB->marked, S0
    | ct        ctpr1, ~pred0
    | --
    | // Fast path: no mt for table yet and not clearing the mt.
    | std       2, RB, TAB->metatable, RA
    | std       5, BASE, -16, S1            // Return original table.
    | disp      ctpr1, ->fff_res
    | wait_load S0, 1
    | --
    | cmpandedb 3, S0, LJ_GC_BLACK, pred0   // isblack(table)
    | andd      4, S0, ~LJ_GC_BLACK, S0     // black2gray(tab)
    | wait_pred_ct pred0, 0
    | --
    | addd      3, 0x0, (1+1)*8, RD, pred0
    | stb       5, RB, TAB->marked, S0, ~pred0
    | ct        ctpr1, pred0
    | --
    | // Possible write barrier. Table is black, but skip iswhite(mt) check.
    | std       2, DISPATCH, DISPATCH_GL(gc.grayagain), RB
    | std       5, RB, TAB->gclist, T1
    | ct        ctpr1
    | --
    |
    |->ff_rawget:
    | // RD_E
    | setwd_call
    | addd      0, RD_E, 0, RD
    | ldd       2, STACK, SAVE_L, T1
    | ldd       3, BASE, 0x0, T2
    | disp      ctpr2, ->fff_fallback
    | --
    | disp      ctpr1, extern lj_tab_get
    | wait_load T2, 1
    | --
    | addd      0, T1, 0, CARG1
    | sard      3, T2, 0x2f, ITYPE
    | getfd     4, T2, (47 << 6), CARG2
    | --
    | cmpbdb    3, RD, (2+1)*8, pred0
    | cmpesb    4, ITYPE, LJ_TTAB, pred1
    | --
    | addd      3, BASE, 0x8, CARG3
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr2, ~pred0               // fff_fallback(RD)
    | --
    | call      ctpr1, wbs = 0x8            // lj_tab_get(lua_State *L, GCtab *t, cTValue *key)
    | --
    | // cTValue * returned.
    | ldd       0, CRET1, 0x0, RB
    | ldd       2, BASE, -8, PC
    | disp      ctpr2, ->fff_res
    | wait_load RB, 0
    | --
    | addd      4, 0x0, (1+1)*8, RD
    | std       5, BASE, -16, RB
    | ct        ctpr2                       // fff_res(RD)
    | --
    |
    |//-- Base library: conversions ------------------------------------------
    |
    |->ff_tonumber:
    | // RD_E
    | // Only handles the number case inline (without a base argument).
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, RB
    | disp      ctpr1, ->fff_fallback
    | wait_load RB, 0
    | --
    | sard      3, RB, 0x2f, ITYPE
    | disp      ctpr2, ->fff_res
    | --
    | cmpedb    3, RD, (1+1)*8, pred0       // Exactly one argument.
    | cmpbesb   4, ITYPE, LJ_TISNUM, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | --
    | ldd       0, BASE, -8, PC, pred0
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    | addd      4, 0x0, (1+1)*8, RD
    | std       5, BASE, -16, RB
    | ct        ctpr2                       // fff_res(RD)
    | --
    |
    |->ff_tostring:
    | // RD_E = (nargs+1)*8
    | ldd       0, BASE, -8, PC
    | addd      1, RD_E, 0, RD
    | ldd       2, DISPATCH, DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM]), S0
    | ldd       3, BASE, 0x0, RB
    | disp      ctpr1, ->fff_fallback
    | --
    | disp      ctpr2, ->fff_res
    | wait_load S0, 1
    | --
    | cmpedb    3, S0, 0x0, pred3
    | cmpbdb    4, RD, (1+1)*8, pred0
    | sard      5, RB, 0x2f, ITYPE
    | --
    | cmpesb    3, ITYPE, LJ_TSTR, pred1
    | cmpbesb   4, ITYPE, LJ_TISNUM, pred2
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | pass      pred2, p2
    | pass      pred3, p3
    | landp     ~p0, p2, p4
    | landp     p4, p3, p5
    | landp     ~p1, p2, p6
    | pass      p5, pred0
    | pass      p6, pred2
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // fff_fallback(BASE, RD)
    | --
    | // Only handles the string or number case inline.
    | // A __tostring method in the string base metatable is ignored.
    | addd      4, 0x0, (1+1)*8, RD, ~pred2
    | std       5, BASE, -16, RB, pred1
    | ct        ctpr2, pred1                // fff_res(BASE, RD)
    | --
    | // Handle numbers inline, unless a number base metatable is present.
    | ffgccheck
    | --
    | disp      ctpr1, extern lj_strfmt_num
    | --
    | ldd       3, STACK, SAVE_L, RB
    | wait_load RB, 0
    | --
    | addd      1, BASE, 0x0, CARG2
    | std       2, STACK, SAVE_PC, PC       // Redundant (but a defined value).
    | addd      3, RB, 0x0, CARG1
    | std       5, RB, L->base, BASE        // Add frame since C call can throw.
    | call      ctpr1, wbs = 0x8            // lj_strfmt_num(lua_State *L, lua_Number *np)
    | --
    | // GCstr returned.
    | addd      2, 0x0, LJ_TSTR, S1
    | ldd       3, RB, L->base, BASE
    | disp      ctpr2, ->fff_res
    | --
    | shld      0, S1, 0x2f, S1
    | --
    | ord       0, S1, CRET1, S1
    | --
    | std       2, BASE, -16, S1
    | --
    | addd      3, 0x0, (1+1)*8, RD
    | --
    | ct        ctpr2                       // fff_res
    | --
    |
    |//-- Base library: iterators -------------------------------------------
    |
    |->ff_next:
    | // RD_E = (nargs+1)*8
    | cmpbdb    0, RD_E, (1+1)*8, pred0
    | cmpedb    1, RD_E, (1+1)*8, pred1     // Missing 2nd arg?
    | addd      2, RD_E, 0, RD
    | lddsm     3, BASE, 0x0, T1
    | lddsm     5, STACK, SAVE_L, RB
    | disp      ctpr2, ->fff_fallback
    | --
    | disp      ctpr1, extern lj_tab_next
    | wait_load T1, 1
    | --
    | sardsm    3, T1, 0x2f, ITYPE
    | getfdsm   4, T1, (47 << 6), T1
    | --
    | addd      0, 0x0, LJ_TNIL, S0
    | cmpesbsm  3, ITYPE, LJ_TTAB, pred2
    | --
    | std       5, BASE, 0x8, S0, pred1     // Set missing 2nd arg to nil
    | pass      pred0, p0
    | pass      pred2, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ldd       0, BASE, -8, PC, pred0
    | ct        ctpr2, ~pred0               // fff_fallback(RD)
    | --
    | setwd_call
    | std       2, RB, L->base, BASE
    | std       5, RB, L->top, BASE
    | wait_load PC, 1
    | --
    | addd      0, T1, 0, CARG2
    | addd      1, BASE, 0x8, CARG3
    | std       2, STACK, SAVE_PC, PC
    | addd      3, RB, 0x0, CARG1
    | call      ctpr1, wbs = 0x8            // lj_tab_next(lua_State *L, GCtab *t, TValue *key)
    | --
    | // Flag returned.
    | cmpedb    0, CRET1, 0x0, pred0
    | ldd       3, RB, L->base, BASE
    | addd      4, 0x0, LJ_TNIL, S0
    | lddsm     5, BASE, 0x8, S1
    | disp      ctpr2, ->fff_res
    | wait_load BASE, 0
    | --
    | lddsm     0, BASE, 0x10, T2
    | --
    | addd      4, 0x0, (1+1)*8, RD, pred0
    | std       5, BASE, -16, S0, pred0     // End of traversal: return nil.
    | ct        ctpr2, pred0                // fff_res(RD)
    | --
    | // Copy key and value to results.
    | std       2, BASE, -16, S1
    | addd      4, 0x0, (1+2)*8, RD
    | wait_load T2, 2
    | --
    | std       5, BASE, -8, T2
    | ct        ctpr2                       // fff_res(RD)
    | --
    |
    |->ff_pairs:
    | // RD_E = (nargs+1)*8
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, RB
    | lddsm     5, BASE, -16, T1
    | disp      ctpr1, ->fff_fallback
    | wait_load RB, 0
    | --
    | addd      3, RB, 0x0, S1
    | sard      4, RB, 0x2f, ITYPE
    | getfd     5, RB, (47 << 6), RB
    | --
    | cmpbdb    3, RD, (1+1)*8, pred0
    | cmpesb    4, ITYPE, LJ_TTAB, pred1
    | lddsm     5, RB, TAB->metatable, S0
    | --
    | addd      3, 0x0, LJ_TFUNC, ITYPE
    | getfdsm   4, T1, (47 << 6), T1
    | disp      ctpr2, ->fff_res
    | --
    | lddsm     3, T1, CFUNC->upvalue[0], T2
    | shld      4, ITYPE, 0x2f, ITYPE
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
#if LJ_52
    | cmpedb    3, S0, 0, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
#endif
    | ldd       0, BASE, -8, PC
    | addd      1, 0x0, LJ_TNIL, S0
    | ord       3, T2, ITYPE, T2
    | --
    | std       2, BASE, -16, T2
    | std       5, BASE, -8, S1
    | --
    | addd      4, 0x0, (1+3)*8, RD
    | std       5, BASE, 0x0, S0
    | ct        ctpr2                       // fff_res(RD)
    | --
    |
    |->ff_ipairs_aux:
    | // RD_E = (nargs+1)*8
    | addd      0, RD_E, 0, RD
    | lddsm     3, BASE, 0x0, RB
    | cmpbdb    4, RD_E, (2+1)*8, pred0
    | ldd       5, BASE, 0x8, S0
    | disp      ctpr1, ->fff_fallback
    | wait_load S0, 0
    | --
    | sard      3, S0, 0x2f, S1
    | faddd     4, S0, U64x(0x3ff00000,0x00000000), S0  // +1.0e0
    | disp      ctpr2, >1
    | --
    | sard      3, RB, 0x2f, ITYPE
    | getfd     4, RB, (47 << 6), RB
    | ct        ctpr1, pred0                // fff_fallback(RD)
    | --
    | cmpesb    3, ITYPE, LJ_TTAB, pred0
    | cmpbsb    4, S1, LJ_TISNUM, pred1
    | ldw       5, RB, TAB->asize, T3
    | disp      ctpr3, ->fff_res
    | --
    | ldwsm     3, RB, TAB->hmask, T4
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ldd       3, BASE, -8, PC, pred0
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    | lddsm     3, RB, TAB->array, RD
    | fdtoistr  4, S0, T2
    | std       5, BASE, -16, S0
    | wait      T2, 0, 4 + 2             // extra fp->int
    | --
    | cmpbsb    3, T2, T3, pred0
    | sxt       4, 0x2, T2, T2
    | --
    | shld      3, T2, 0x3, RA
    | wait_pred_ct pred0, 1
    | --
    | addd      3, RD, RA, RD, pred0
    | ct        ctpr2, ~pred0               // >1, Not in array part?
    | --
    | ldw       3, RD, 0x0, S0
    | lddsm     5, RD, 0x0, RB
    | wait_load S0, 0
    | --
    | cmpesb    3, S0, LJ_TNIL, pred0
    | wait_pred_ct pred0, 0
    | --
    | addd      3, 0x0, (0+1)*8, RD, pred0
    | ct        ctpr3, pred0                // fff_res(RD)
    | --
    | // Copy array slot.
    | addd      3, 0x0, (1+2)*8, RD
    | std       5, BASE, -8, RB
    | ct        ctpr3                       // fff_res(RD)
    |1: // Check for empty hash part first. Otherwise call C function.
    | disp      ctpr1, extern lj_tab_getinth     // (GCtab *t, int32_t key)
    | --
    | setwd_call
    | cmpedb    3, T4, 0x0, pred0
    | wait_pred_ct pred0, 0
    | --
    | addd      3, 0x0, (0+1)*8, RD, pred0
    | ct        ctpr3, pred0                // fff_res(RD)
    | --
    | addd      0, RB, 0, CARG1
    | addd      1, T2, 0, CARG2
    | call      ctpr1, wbs = 0x8            // lj_tab_getinth(GCtab *t, int32_t key)
    | --
    | // cTValue * or NULL returned.
    | lddsm     0, CRET1, 0x0, RB
    | cmpedb    1, CRET1, 0x0, pred0
    | ldwsm     2, CRET1, 0x0, S0
    | disp      ctpr3, ->fff_res
    | wait_load S0, 0
    | --
    | cmpesbsm 1, S0, LJ_TNIL, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, ~p1, p4
    | pass      p4, pred0
    | --
    | addd      3, 0x0, (0+1)*8, RD, ~pred0
    | ct        ctpr3, ~pred0               // fff_res(RD)
    | --
    | // Copy array slot.
    | addd      3, 0x0, (1+2)*8, RD
    | std       5, BASE, -8, RB
    | ct        ctpr3                       // fff_res(RD)
    | --
    |
    |->ff_ipairs:
    | // RD_E = (nargs+1)*8
    | lddsm     0, BASE, -16, T1
    | addd      1, RD_E, 0, RD              // TODO: remove me
    | ldd       3, BASE, 0, RB
    | addd      4, 0x0, U64x(0x00007fff,0xffffffff), T2
    | disp      ctpr1, ->fff_fallback
    | wait_load T1, 0
    | --
    | andd      2, T1, T2, T1
    | addd      3, RB, 0x0, S1
    | sard      4, RB, 0x2f, ITYPE
    | andd      5, RB, T2, RB
    | --
    | cmpbdb    3, RD, (1+1)*8, pred0
    | cmpesb    4, ITYPE, LJ_TTAB, pred1
    | lddsm     5, RB, TAB->metatable, S0
    | --
    | lddsm     0, T1, CFUNC->upvalue[0], T2
    | addd      1, 0x0, LJ_TFUNC, ITYPE
    | --
    | shld      0, ITYPE, 0x2f, ITYPE
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
#if LJ_52
    | cmpedb    3, S0, 0x0, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
#endif
    | ldd       0, BASE, -8, PC
    | ord       1, T2, ITYPE, T2
    | disp      ctpr1, ->fff_res
    | --
    | addd      1, 0x0, 0x0, S0
    | std       2, BASE, -8, S1
    | std       5, BASE, -16, T2
    | --
    | addd      4, 0x0, (1+3)*8, RD
    | std       5, BASE, 0x0, S0
    | ct        ctpr1                       // fff_res(RD)
    | --
    |
    |//-- Base library: catch errors ----------------------------------------
    |
    |->ff_pcall:
    | // RD_E
    | addd      0, RD_E, 0, RD
    | ldbsm     2, DISPATCH, DISPATCH_GL(hookmask), RB
    | cmpbdb    3, RD_E, (1+1)*8, pred0
    | disp      ctpr1, ->fff_fallback
    | wait_load RB, 0
    | --
    | shrdsm    0, RB, HOOK_ACTIVE_SHIFT, RB
    | addd      3, BASE, 0x10, RA
    | disp      ctpr2, >1
    | --
    | anddsm    0, RB, 0x1, RB
    | --
    | addd      0, 0x0, 16+FRAME_PCALL, PC, ~pred0
    | subd      3, RD, 0x8, RD, ~pred0
    | ct        ctpr1, pred0                // fff_fallback(BASE, RD)
    | --
    | addd      0, PC, RB, PC               // Remember active hook before pcall.
    | subd      3, RD, 0x8, KBASE
    | addd      4, RA, RD, S0
    | // Note: this does a (harmless) copy of the function to the PC slot, too.
    |1:
    | ldd       3, S0, -24, RB
    | cmpbedb   4, KBASE, 0x0, pred0
    | wait_pred_ct pred0, 0
    | --
    | addd      3, RA, KBASE, S0, ~pred0
    | subd      4, KBASE, 0x8, KBASE, ~pred0
    | std       5, S0, -16, RB
    | ct        ctpr2, ~pred0               // <1
    | --
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    | ldd       3, RA, -16, RB
    | disp      ctpr1, ->vmeta_call
    | --
    | disp      ctpr2, ->vm_enter_pipeline
    | wait_load RB, 1
    | --
    | sard      3, RB, 0x2f, ITYPE
    | getfd     4, RB, (47 << 6), RB
    | --
    | lddsm     3, RB, LFUNC->pc, RARG1
    | cmpesb    4, ITYPE, LJ_TFUNC, pred0
    | wait_pred_ct pred0, 0
    | --
    | addd      4, RA, 0x0, BASE, pred0
    | ct        ctpr1, ~pred0               // vmeta_call(BASE, RA, RD)
    | --
    | std       5, BASE, -8, PC
    | ct        ctpr2                       // vm_enter_pipeline(RARG1, RD, RB)
    | --
    |
    |->ff_xpcall:
    | // RD_E = (nargs+1)*8
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x8, RA
    | ldd       5, BASE, 0x0, RB
    | disp      ctpr1, ->fff_fallback
    | wait_load RA, 0
    | --
    | sard      3, RA, 0x2f, ITYPE
    | --
    | cmpbdb    3, RD, (2+1)*8, pred0
    | cmpesb    4, ITYPE, LJ_TFUNC, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | addd      1, 0x0, 0x18+FRAME_PCALL, PC, pred0
    | std       2, BASE, 0x0, RA, pred0     // Swap function and traceback.
    | std       5, BASE, 0x8, RB, pred0
    | ct        ctpr1, ~pred0               // fff_fallback(BASE, RD)
    | --
    | ldb       0, DISPATCH, DISPATCH_GL(hookmask), RB
    | disp      ctpr2, >1
    | --
    | addd      3, BASE, 0x18, RA
    | subd      4, RD, 0x10, RD
    | wait_load RB, 1
    | --
    | shrd      0, RB, HOOK_ACTIVE_SHIFT, RB
    | addd      3, RD, 0x0, KBASE
    | --
    | andd      0, RB, 0x1, RB
    | addd      3, RA, KBASE, S0
    | --
    | addd      0, PC, RB, PC               // Remember active hook before pcall.
    | subd      3, KBASE, 0x8, KBASE
    | // Note: this does a (harmless) copy of the function to the PC slot, too.
    |1:
    | ldd       3, S0, -24, RB
    | cmpbedb   4, KBASE, 0x0, pred0
    | wait_pred_ct pred0, 0
    | --
    | addd      3, RA, KBASE, S0, ~pred0
    | subd      4, KBASE, 0x8, KBASE, ~pred0
    | std       5, S0, -16, RB
    | ct        ctpr2, ~pred0               // <1
    | --
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    | ldd       3, RA, -16, RB
    | disp      ctpr1, ->vmeta_call
    | --
    | disp      ctpr2, ->vm_enter_pipeline  // TODO: inline
    | wait_load RB, 1
    | --
    | sard      3, RB, 0x2f, ITYPE
    | getfd     4, RB, (47 << 6), RB
    | --
    | lddsm     3, RB, LFUNC->pc, RARG1
    | cmpesb    4, ITYPE, LJ_TFUNC, pred0
    | wait_load RARG1, 0
    | --
    | addd      4, RA, 0x0, BASE, pred0
    | ct        ctpr1, ~pred0               // vmeta_call(BASE, RA, RD)
    | --
    | std       5, BASE, -8, PC
    | ct        ctpr2                       // vm_enter_pipeline(RARG1, RD, RB)
    | --
    |
    |//-- Coroutine library --------------------------------------------------
    |
    |.macro coroutine_resume_wrap, resume
    |.if resume
    |->ff_coroutine_resume:
    | // RD_E
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, -8, PC
    | ldd       5, BASE, 0x0, RB
    | disp      ctpr1, ->fff_fallback
    | wait_load RB, 0
    | --
    | sard      3, RB, 0x2f, ITYPE
    | getfd     4, RB, (47 << 6), RB
    | --
    | cmpbdb    3, RD, (1+1)*8, pred0
    | cmpesb    4, ITYPE, LJ_TTHREAD, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | std       2, STACK, SAVE_PC, PC, pred0
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    |.else
    |->ff_coroutine_wrap_aux:
    | // RD_E
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, -16, RB
    | ldd       5, BASE, -8, PC
    | wait_load RB, 0
    | --
    | getfd     3, RB, (47 << 6), RB
    | --
    | ldd       3, RB, CFUNC->upvalue[0].gcr, RB
    | wait_load RB, 0
    | --
    | std       2, STACK, SAVE_PC, PC
    | getfd     3, RB, (47 << 6), RB
    | --
    |.endif
    | setwd_call
    | ldd       3, RB, L->cframe, S0
    | addd      4, RB, 0x0, S1
    | ldbsm     5, RB, L->status, CARG1
    | --
    | lddsm     3, RB, L->top, RA
    | disp      ctpr1, ->fff_fallback
    | wait_load S0, 1
    | --
    | cmpedb    3, S0, 0x0, pred0
    | cmpbedbsm 4, CARG1, LUA_YIELD, pred1
    | lddsm     5, RB, L->base, S0
    | --
    | cmpedb    3, CARG1, LUA_YIELD, pred2
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | --
    | cmpbedb   3, RA, S0, pred1            // Check for presence of initial func.
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | nop 1
    | --
    | lddsm     0, RB, L->maxstack, S0
    | pass      pred1, p0
    | pass      pred2, p1
    | landp     p0, ~p1, p4
    | landp     ~p0, ~p1, p5
    | pass      p4, pred0
    | pass      p5, pred1                   // Status != LUA_YIELD (i.e. 0)?
    | --
    | ldd       3, RA, -8, PC, pred1        // Move initial function up.
    | ct        ctpr1, pred0                // fff_fallback(RD)
    | --
    | wait_load PC, 1
    | --
    | addd      4, RA, 0x8, RA, pred1
    | std       5, RA, 0x0, PC, pred1
    | --
    |.if resume
    | addd      3, RA, RD, PC               // Check stack space (-1-thread).
    | --
    | subd      0, PC, 0x10, PC
    | --
    |.else
    | addd      3, RA, RD, PC               // Check stack space (-1).
    | --
    | subd      0, PC, 0x8, PC
    | --
    |.endif
    | cmpbedb   0, PC, S0, pred0
    | ldd       2, STACK, SAVE_L, CARG1
    | disp      ctpr2, >2
    | wait_load CARG1, 0
    | --
    | std       2, CARG1, L->base, BASE, pred0
    | std       5, RB, L->top, PC, pred0
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    |.if resume
    | addd      3, BASE, 0x8, BASE          // Keep resumed thread in stack for GC.
    | --
    |.endif
    | std       2, CARG1, L->top, BASE
    | disp      ctpr3, >1
    | --
    |.if resume
    | addd      3, BASE, RD, RB             // RB = end of source for stack move.
    | --
    | subd      3, RB, 0x18, RB
    | --
    |.else
    | addd      3, BASE, RD, RB             // RB = end of source for stack move.
    | --
    | subd      3, RB, 0x10, RB
    | --
    |.endif
    | cmpedb    0, PC, RA, pred0
    | subd      3, RB, PC, RB               // Relative to PC.
    | disp      ctpr1, ->vm_resume
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr2, pred0                // >2
    | --
    |1: // Move args to coroutine.
    | ldd       0, PC, RB, RC
    | wait_load RC, 0
    | --
    | subd      1, PC, 0x8, PC
    | std       2, PC, -8, RC
    | --
    | cmpedb    0, PC, RA, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr3, ~pred0               // <1
    |2:
    | addd      0, RA, 0x0, CARG2
    | addd      1, S1, 0x0, CARG1
    | call      ctpr1, wbs = 0x8            // vm_resume(lua_State *L, TValue *base, 0, 0)
    | --
    | ldd       0, STACK, SAVE_L, RB
    | addd      1, S1, 0x0, PC
    | addd      2, 0x0, ~LJ_VMST_INTERP, S0
    | disp      ctpr2, >7
    | wait_load RB, 0
    | --
    | ldd       3, RB, L->base, BASE
    | --
    | cmpbedb   0, CRET1, LUA_YIELD, pred0
    | stw       2, DISPATCH, DISPATCH_GL(vmstate), S0
    | std       5, DISPATCH, DISPATCH_GL(cur_L), RB
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr2, ~pred0               // >7
    |3:
    | ldd       0, PC, L->base, RA
    | ldd       2, PC, L->top, KBASE
    | lddsm     3, RB, L->maxstack, S0
    | disp      ctpr1, >5
    | wait_load RA, 0
    | --
    | std       2, PC, L->top, RA           // Clear coroutine stack.
    | subd      3, KBASE, RA, PC
    | disp      ctpr2, >8
    | --
    | cmpedb    3, PC, 0x0, pred0
    | disp      ctpr3, >4
    | wait_pred_ct pred0, 0
    | --
    | addd      3, BASE, PC, RD, ~pred0
    | ct        ctpr1, pred0                // >5, No results?
    | --
    | cmpbedb   3, RD, S0, pred0
    | addd      4, BASE, 0x0, CARG1
    | wait_pred_ct pred0, 0
    | --
    | subd      3, CARG1, RA, RB, pred0
    | ct        ctpr2, ~pred0               // >8, Need to grow stack?
    |4: // Move results from coroutine.
    | ldd       3, RA, 0x0, RD
    | wait_load RD, 0
    | --
    | addd      4, RA, 0x8, RA
    | std       5, RA, RB, RD
    | --
    | cmpedb    3, RA, KBASE, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr3, ~pred0               // <4
    |5:
    |.if resume
    | addd      3, PC, (1+1)*8, RD          // (nresults+1)*8 = (1 + true)*8 + results*8.
    | addd      4, 0x0, U64x(0xfffeffff,0xffffffff), ITYPE
    | --
    | std       5, BASE, -8, ITYPE          // Prepend true to results.
    |.else
    | addd      3, PC, 1*8, RD              // (nresults+1)*8 = 8 + results*8.
    |.endif
    |6:
    | ldd       0, STACK, SAVE_PC, PC
    | disp      ctpr1, ->BC_RET_Z
    | --
    | stw       2, STACK, MULTRES, RD
    | disp      ctpr2, ->vm_return
    | --
    |.if resume
    | subd      3, 0x0, 0x8, RA
    | --
    |.else
    | addd      3, 0x0, 0x0, RA
    | --
    |.endif
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, pred0                // BC_RET_Z(RA, RD, PC)
    | --
    | ct        ctpr2                       // vm_return(RA, RD)
    |7: // Coroutine returned with error (at co->top-1).
    |.if resume
    | ldd       0, PC, L->top, RA
    | addd      3, 0x0, U64x(0xffff7fff,0xffffffff), ITYPE
    | disp      ctpr1, <6
    | --
    | std       5, BASE, -8, ITYPE          // Prepend false to results.
    | wait_load RA, 1
    | --
    | subd      0, RA, 0x8, RA
    | --
    | std       2, PC, L->top, RA           // Clear error from coroutine stack.
    | --
    | // Copy error message.
    | ldd       0, RA, 0x0, RD
    | wait_load RD, 0
    | --
    | addd      4, 0x0, (1+2)*8, RD         // (nresults+1)*8 = (1 + false + error)*8.
    | std       5, BASE, 0x0, RD
    | ct        ctpr1                       // <6
    | --
    |.else
    | disp      ctpr1, extern lj_ffh_coroutine_wrap_err // (lua_State *L, lua_State *co)
    | --
    | addd      0, PC, 0x0, CARG2
    | addd      1, RB, 0x0, CARG1
    | --
    | call      ctpr1, wbs = 0x8            // lj_ffh_coroutine_wrap_err(lua_State *L, lua_State *co)
    | --
    | // Error function does not return.
    |.endif
    |8:  // Handle stack expansion on return from yield.
    | disp      ctpr1, extern lj_state_growstack
    | --
    | addd      0, S1, 0x0, RA
    | shrd      1, PC, 0x3, PC
    | --
    | addd      0, PC, 0x0, CARG2
    | addd      1, RB, 0x0, CARG1
    | std       2, RA, L->top, KBASE        // Undo coroutine stack clearing.
    | --
    | call      ctpr1, wbs = 0x8            // lj_state_growstack(lua_State *L, int n)
    | --
    | ldd       3, RB, L->base, BASE
    | disp      ctpr2, <3
    | --
    | addd      0, S1, 0x0, PC
    | --
    | ct        ctpr2                       // <3, Retry the stack move.
    | --
    |.endmacro
    |
    | coroutine_resume_wrap 1        // coroutine.resume
    | coroutine_resume_wrap 0        // coroutine.wrap
    |
    |->ff_coroutine_yield:
    | ldd       0, STACK, SAVE_L, RB
    | addd      1, RD_E, 0, RD
    | disp      ctpr1, ->fff_fallback
    | --
    | return    ctpr3
    | wait_load RB, 1
    | --
    | ldd       0, RB, L->cframe, S0
    | addd      3, BASE, RD, S1
    | wait_load S0, 0
    | --
    | cmpandedb 0, S0, CFRAME_RESUME, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, pred0                // fff_fallback(RD)
    | --
    | std       2, RB, L->base, BASE
    | subd      3, S1, 0x8, RD
    | --
    | std       2, RB, L->top, RD
    | addd      3, 0x0, 0x0, RD
    | --
    | addd      0, 0x0, LUA_YIELD, RRET1
    | std       2, RB, L->cframe, RD
    | --
    | stb       2, RB, L->status, RRET1
    | ct        ctpr3                       // return
    | --
    |
    |//-- Math library -------------------------------------------------------
    |
    |->ff_math_abs:
    | // RD_E = (nargs+1)*8
    | ldd       3, BASE, 0x0, RB
    | disp      ctpr1, ->fff_fallback
    | wait_load RB, 0
    | --
    | addd      0, RD_E, 0, RD
    | sard      3, RB, 0x2f, ITYPE
    | shld      4, RB, 0x1, RB
    | --
    | cmpbdb    3, RD_E, (1+1)*8, pred0
    | cmpbsb    4, ITYPE, LJ_TISNUM, pred1
    | shrd      5, RB, 0x1, RB
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    | ldd       0, BASE, -8, PC
    | disp      ctpr1, ->fff_res
    | wait_load PC, 0
    | --
    | addd      3, 0x0, (1+1)*8, RD
    | std       5, BASE, -16, RB
    | ct        ctpr1                       // fff_res(RD)
    | --
    |
    |->ff_math_sqrt:
    | ldd 3, BASE, 0x0, CARG1
    | disp ctpr1, ->fff_fallback
    | nop 2
    | --
    | sard 3, CARG1, 0x2f, ITYPE
    | fsqrtid 5, CARG1, S1
    | --
    | cmpbdb 3, RD, (1+1)*8, pred0
    | cmpbsb 4, ITYPE, LJ_TISNUM, pred1
    | --
    | pass pred0, p0
    | pass pred1, p1
    | landp ~p0, p1, p4
    | pass p4, pred0
    | --
    | ct ctpr1, ~pred0
    | --
    | fsqrttd 5, CARG1, S1, S0
    | --
    | // fallthrough
    |
    |->fff_resb:
    | // RD, S0
    | ldd       0, BASE, -8, PC
    | wait_load PC, 1
    | wait      S0, 1, 4
    | --
    | addd      3, 0x0, (1+1)*8, RD
    | std       5, BASE, -16, S0
    | --
    | // fallthrough
    |
    |->fff_res:
    | // RD = (nargs+1)*8
    | cmpandedb 0, PC, FRAME_TYPE, pred0
    | stw       5, STACK, MULTRES, RD
    | disp      ctpr1, ->vm_return
    | --
    | addd      4, 0x0, LJ_TNIL, S1
    | disp      ctpr2, >2
    | --
    | ldb       3, PC, PREV_PC_RB, RB, pred0
    | --
    | ldb       3, PC, PREV_PC_RA, RA, pred0
    | subd      4, 0x0, 0x10, RA, ~pred0    // Results start at BASE+RA = BASE-16
    | wait_load RB, 1
    | --
    | shld      4, RB, 0x3, RB, pred0
    | disp      ctpr3, >1
    | --
    | cmpbedbsm 3, RB, RD, pred1            // More results expected?
    | ct        ctpr1, ~pred0               // vm_return(RA, RD), Non-standard return case.
    | wait_pred_ct pred1, 0
    | --
    | shld      3, RA, 0x3, T5
    | ct        ctpr2, pred1                // >2
    |1:                                     // Fill up results with nil.
    | subd      3, RD, 0x18, S0
    | addd      4, RD, 0x8, RD
    | --
    | cmpbedb   3, RB, RD, pred1
    | std       5, BASE, S0, S1
    | wait_pred_ct pred1, 0
    | --
    | ct        ctpr3, ~pred1               // <1
    |2:
    | subd      3, BASE, 0x10, BASE
    | disp      ctpr1, ->vm_restart_pipeline    // TODO: opmitize
    | --
    | subd      3, BASE, T5, BASE           // base = base - (RA+2)*8
    | ct        ctpr1                       // vm_restart_pipeline
    | --
    |
    |.macro math_round, func
    |->ff_math_ .. func:
    | setwd_call
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, T1
    | disp      ctpr2, ->fff_fallback
    | --
    | disp      ctpr1, ->vm_ .. func
    | --
    | addd      0, T1, 0, CARG1
    | sard      3, T1, 0x2f, ITYPE
    | --
    | cmpbsb    0, ITYPE, LJ_TISNUM, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr2, ~pred0               // fff_fallback(RD)
    | --
    | call      ctpr1, wbs = 0x8
    | --
    | addd      0, CRET1, 0x0, S0
    | disp      ctpr1, ->fff_resb
    | --
    | ct        ctpr1                       // fff_resb(RD, S0)
    | --
    |.endmacro
    |
    | math_round floor
    | math_round ceil
    |
    |->ff_math_log:
    | // RD_E = (nargs+1)*8
    | setwd_call
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, T1
    | disp      ctpr2, ->fff_fallback
    | --
    | disp      ctpr1, extern log
    | --
    | wait_load T1, 2
    | --
    | addd      0, T1, 0, CARG1
    | sard      3, T1, 0x2f, ITYPE
    | --
    | cmpedb    3, RD, (1+1)*8, pred0
    | cmpbsb    4, ITYPE, LJ_TISNUM, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr2, ~pred0
    | --
    | call      ctpr1, wbs = 0x8            // log
    | --
    | addd      0, CRET1, 0x0, S0
    | disp      ctpr2, ->fff_resb
    | --
    | ct        ctpr2                       // fff_resb(RD, S0)
    | --
    |
    |.macro math_extern, func
    |->ff_math_ .. func:
    | // RD_E = (nargs+1)*8
    | ldd       3, BASE, 0x0, T1
    | disp      ctpr2, ->fff_fallback
    | --
    | disp      ctpr1, extern func
    | wait_load T1, 1
    | --
    | sard      3, T1, 0x2f, ITYPE
    | --
    | setwd_call
    | addd      0, RD_E, 0, RD
    | cmpbdb    3, RD_E, (1+1)*8, pred0
    | cmpbsb    4, ITYPE, LJ_TISNUM, pred1
    | --
    | addd      0, T1, 0, CARG1
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr2, ~pred0
    | --
    | call      ctpr1, wbs = 0x8
    | --
    | addd      0, CRET1, 0x0, S0
    | disp      ctpr2, ->fff_resb
    | --
    | ct        ctpr2                       // fff_resb(RD, S0)
    | --
    |.endmacro
    |
    |.macro math_extern2, func
    |->ff_math_ .. func:
    | // RD_E
    | ldd       3, BASE, 0x0, T1
    | addd      4, 0x0, 0x2f, S0
    | ldd       5, BASE, 0x8, T2
    | disp      ctpr2, ->fff_fallback
    | --
    | disp      ctpr1, extern func
    | wait_load T1, 1
    | --
    | setwd_call
    | addd      0, RD_E, 0, RD
    | cmpbdb    3, RD_E, (2+1)*8, pred0
    | sard      4, T1, S0, ITYPE
    | sard      5, T2, S0, S1
    | --
    | cmpbsb    3, ITYPE, LJ_TISNUM, pred1
    | cmpbsb    4, S1, LJ_TISNUM, pred2
    | --
    | addd      0, T1, 0, CARG1
    | addd      1, T2, 0, CARG2
    | pass      pred0, p0
    | pass      pred1, p1
    | pass      pred2, p2
    | landp     ~p0, p1, p4
    | landp     p4, p2, p5
    | pass      p5, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr2, ~pred0               // fff_fallback(RD)
    | --
    | call      ctpr1, wbs = 0x8
    | --
    | addd      3, CRET1, 0x0, S0
    | disp      ctpr1, ->fff_resb
    | --
    | ct        ctpr1                       // fff_resb(RD, S0)
    | --
    |.endmacro
    |
    | math_extern log10
    | math_extern exp
    | math_extern sin
    | math_extern cos
    | math_extern tan
    | math_extern asin
    | math_extern acos
    | math_extern atan
    | math_extern sinh
    | math_extern cosh
    | math_extern tanh
    | math_extern2 pow
    | math_extern2 atan2
    | math_extern2 fmod
    |
    |->ff_math_ldexp:
    | // RD_E
    | ldd       3, BASE, 0x0, S0
    | addd      4, 0x0, 0x2f, CARG2
    | ldd       5, BASE, 0x8, S1
    | disp      ctpr1, ->fff_fallback
    | wait_load S0, 0
    | --
    | addd      0, RD_E, 0, RD
    | cmpbdb    3, RD_E, (2+1)*8, pred0
    | sard      4, S0, CARG2, ITYPE
    | sard      5, S1, CARG2, CARG1
    | disp      ctpr2, ->fff_res
    | --
    | cmpbsb    3, ITYPE, LJ_TISNUM, pred1
    | cmpbsb    4, CARG1, LJ_TISNUM, pred2
    | --
    | fdtoidtr  3, S1, S1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | pass      pred2, p2
    | landp     ~p0, p1, p4
    | landp     p4, p2, p5
    | pass      p5, pred0
    | --
    | fscaled   4, S0, S1, S0
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    | ldd       0, BASE, -8, PC
    | wait_load PC, 0
    | --
    | addd      3, 0x0, (1+1)*8, RD
    | std       5, BASE, -16, S0
    | ct        ctpr2                       // fff_res(RD)
    | --
    |
    |->ff_math_frexp:
    | // RD_E
    | setwd_call
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, T1
    | disp      ctpr2, ->fff_fallback
    | --
    | disp      ctpr1, extern frexp
    | wait_load T1, 1
    | --
    | sard      3, T1, 0x2f, ITYPE
    | addd      4, T1, 0, CARG1
    | --
    | cmpbdb    3, RD, (1+1)*8, pred0
    | cmpbsb    4, ITYPE, LJ_TISNUM, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr2, ~pred0               // fff_fallback(RD)
    | --
    | addd      0, STACK, STACK_TMP, CARG2
    | call      ctpr1, wbs = 0x8            // frexp(f64, int*)
    | --
    | ldd       0, BASE, -8, PC
    | ldw       2, STACK, STACK_TMP, S0
    | disp      ctpr1, ->fff_res
    | wait_load S0, 0
    | --
    | istofd    0, S0, S0
    | std       5, BASE, -16, CRET1
    | wait      S0, 0, 4
    | --
    | addd      3, 0x0, (1+2)*8, RD
    | std       5, BASE, -8, S0
    | ct        ctpr1                       // fff_res(RD)
    | --
    |
    |->ff_math_modf:
    | // RD_E
    | setwd_call
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, T1
    | disp      ctpr2, ->fff_fallback
    | --
    | disp      ctpr1, extern modf
    | wait_load T1, 1
    | --
    | addd      0, T1, 0, CARG1
    | sard      3, T1, 0x2f, ITYPE
    | --
    | cmpbdb    3, RD, (1+1)*8, pred0
    | cmpbsb    4, ITYPE, LJ_TISNUM, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | --
    | ct        ctpr2, ~pred0               // fff_fallback(RD)
    | --
    | subd      3, BASE, 0x10, CARG2
    | call      ctpr1, wbs = 0x8            // modf
    | --
    | ldd       0, BASE, -8, PC
    | disp      ctpr2, ->fff_res
    | --
    | addd      4, 0x0, (1+2)*8, RD
    | std       5, BASE, -8, CRET1
    | ct        ctpr2                       // fff_res(RD)
    | wait_load PC, 1
    | --
    |
    |.macro math_minmax, name, ins
    |->ff_ .. name:
    | // RD_E = (nargs+1)*8
    | ldd       3, BASE, 0x0, S0
    | disp      ctpr1, ->fff_fallback
    | --
    | disp      ctpr2, ->fff_resb
    | --
    | disp      ctpr3, >1
    | wait_load S0, 2
    | --
    | sard      3, S0, 0x2f, ITYPE
    | --
    | addd      0, RD_E, 0, RD
    | cmpbdb    3, RD_E, (1+1)*8, pred0
    | cmpbsb    4, ITYPE, LJ_TISNUM, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     ~p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | addd      3, 0x0, 0x10, RA
    | ct        ctpr1, ~pred0
    |1: //  Handle numbers or integers.
    | cmpbsb    3, RA, RD, pred0
    | addd      4, BASE, RA, S1
    | --
    | lddsm     3, S1, -8, S1
    | wait_pred_ct pred0, 1
    | --
    | ct        ctpr2, ~pred0               /// fff_resb(RD, S0)
    | --
    | sard      3, S1, 0x2f, ITYPE
    | --
    | cmpbsb    3, ITYPE, LJ_TISNUM, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    | ins       3, S0, S1, S0
    | addd      4, RA, 0x8, RA
    | ct        ctpr3                       // <1
    | --
    |.endmacro
    |
    | math_minmax math_min, fmind
    | math_minmax math_max, fmaxd
    |
    |//-- String library -----------------------------------------------------
    |
    |->ff_string_byte:
    | // RD_E
    | addd      0, RD_E, 0, RD
    | ldd       3, BASE, 0x0, RB
    | disp      ctpr1, ->fff_fallback
    | --
    | disp      ctpr2, ->fff_res
    | --
    | disp      ctpr3, ->fff_resb
    | wait_load RB, 2
    | --
    | sard      3, RB, 0x2f, ITYPE
    | getfd     4, RB, (47 << 6), RB
    | --
    | cmpedb    3, RD, (1+1)*8, pred0
    | cmpesb    4, ITYPE, LJ_TSTR, pred1
    | ldwsm     5, RB, STR->len, S0
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    | ldd       2, BASE, -8, PC
    | ldbsm     3, RB, STR[1], RB
    | cmpbsbsm  4, S0, 0x1, pred1
    | wait_load RB, 0
    | wait_pred_ct pred1, 0
    | --
    | addd      2, 0x0, (0+1)*8, RD, pred1
    | istofd    3, RB, S0
    | ct        ctpr2, pred1                // fff_res(RD), Return no results for empty string.
    | --
    | ct        ctpr3                       // fff_resb(RD, S0)
    | --
    |
    |->ff_string_char:
    | addd      1, RD_E, 0, RD              // used in ffgccheck
    | ffgccheck
    | ldd       3, BASE, 0x0, S0
    | addd      4, 0x0, 0x1, S1             // used in fff_newstr
    | wait_load S0, 0
    | --
    | sard      3, S0, 0x2f, ITYPE
    | fdtoistr  4, S0, RB
    | --
    | cmpedb    3, RD, (1+1)*8, pred0
    | cmpbsb    4, ITYPE, LJ_TISNUM, pred1
    | --
    | pass      pred0, p0                   // *Exactly* 1 arg.
    | pass      pred1, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | wait      RB, 2, 4 + 2                // extra fp->int pernalty
    | --
    | cmpbesb   3, RB, 255, pred1
    | ct        ctpr3, ~pred0               // fff_fallback(RD), prepared in ffgccheck
    | wait_pred_ct pred1, 0
    | --
    | stw       2, STACK, STACK_TMP, RB, pred1
    | addd      3, STACK, STACK_TMP, RD, pred1   // Points to stack. Little-endian.
    | ct        ctpr3, ~pred1               // fff_fallback(RD), prepared in ffgccheck
    | --
    | // Fall through
    |
    |->fff_newstr:
    | // RD, S1
    | disp      ctpr1, extern lj_str_new
    | --
    | setwd_call
    | ldd       0, STACK, SAVE_L, RB
    | wait_load RB, 0
    | --
    | addd      0, RD, 0x0, CARG2
    | addd      1, RB, 0x0, CARG1
    | std       2, RB, L->base, BASE
    | sxt       3, 0x2, S1, CARG3           // Zero-extended to size_t.
    | --
    | std       2, STACK, SAVE_PC, PC
    | call      ctpr1, wbs = 0x8            // lj_str_new(lua_State *L, char *str, size_t l)
    | --
    | // GStr * returned.
    | addd      2, 0x0, LJ_TSTR, ITYPE
    | ldd       3, RB, L->base, BASE
    | disp      ctpr1, ->fff_res
    | nop 2
    | --
    | shld      0, ITYPE, 0x2f, ITYPE
    | --
    | ord       2, CRET1, ITYPE, CRET1
    | ldd       3, BASE, -8, PC
    | --
    | addd      0, 0x0, (1+1)*8, RD
    | std       5, BASE, -16, CRET1
    | ct        ctpr1                       // fff_res(RD)
    | --
    |
    |->ff_string_sub:
    | addd      1, RD_E, 0, RD              // used in ffgccheck
    | ffgccheck
    | lddsm     3, BASE, 0x10, S0
    | addd      4, 0x0, 0x0, RA
    | adds      5, 0x0, -1, S1
    | wait_pred_ct S0, 0
    | --
    | cmpbdb    3, RD, (1+2)*8, pred0
    | cmpbedb   4, RD, (1+2)*8, pred1
    | sardsm    5, S0, 0x2f, ITYPE
    | --
    | cmpbsbsm  3, ITYPE, LJ_TISNUM, pred2
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | pass      pred2, p2
    | landp     ~p0, p2, p4
    | landp     ~p1, p2, p5
    | pass      p4, pred0
    | pass      p5, pred1
    | wait_pred_ct pred0, 0
    | --
    | fdtoistr  3, S0, S1, pred1
    | ct        ctpr3, ~pred0               // fff_fallback(RD), prepared in ffgccheck
    | --
    | ldd       3, BASE, 0x0, RB
    | addd      4, 0x0, U64x(0x00007fff,0xffffffff), T1
    | ldd       5, BASE, 0x8, S0
    | disp      ctpr1, >2
    | wait_load RB, 0
    | --
    | sard      3, RB, 0x2f, ITYPE
    | andd      4, RB, T1, RB
    | sard      5, S0, 0x2f, T1
    | --
    | cmpesb    3, ITYPE, LJ_TSTR, pred0
    | cmpbsb    4, T1, LJ_TISNUM, pred1
    | ldwsm     5, RB, STR->len, RC
    | --
    | fdtoistr  3, S0, RA
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | disp      ctpr2, >2
    | wait_load RC, 1
    | wait_pred_ct pred0, 0
    | --
    | cmpbsbsm  3, RC, S1, pred1
    | cmplsbsm  4, RC, S1, pred2
    | adds      5, S1, 0x1, T1
    | ct        ctpr3, ~pred0               // fff_fallback(RD), prepared in ffgccheck
    | --
    | cmplesb   3, RA, 0x0, pred3
    | cmpesb    4, RA, 0x0, pred4
    | disp      ctpr2, ->fff_newstr
    | --
    | pass      pred1, p0
    | pass      pred2, p1
    | landp     p0, p1, p4
    | landp     p0, ~p1, p5
    | pass      p4, pred0
    | pass      p5, pred1
    | --
    | pass      pred3, p0
    | pass      pred4, p1
    | landp     p0, ~p1, p4
    | pass      p4, pred2
    | wait_pred_ct pred2, 0
    | --
    | adds      3, T1, RC, S1, pred1        // end = end+(len+1)
    | adds      4, RC, 0x0, S1, pred0       // end = len
    | adds      5, 0x0, 0x1, RA, pred4      // start = 1
    | ct        ctpr1, ~pred2               // >2 start > 0?
    | --
    | // Negative start or underflow.
    | adds      3, RA, RC, RA               // start = start+(len+1)
    | --
    | adds      3, RA, 0x1, RA
    | --
    | cmplesb   3, RA, 0x0, pred0
    | --
    | adds      3, 0x0, 0x1, RA, pred0      // start = 1
    | --
    |2:
    | subs      3, S1, RA, S1
    | addd      4, RB, RA, T1
    | --
    | cmplsb    3, S1, 0x0, pred0
    | nop 1
    | --
    | xors      3, S1, S1, S1, pred0        // Zero length. Any ptr in RD is ok.
    | adds      4, S1, 0x1, S1, ~pred0
    | addd      5, T1, #STR-1, RD, ~pred0
    | ct        ctpr2                       // fff_newstr(RD, S1)
    | --
    |
    |.macro ffstring_op, name
    |->ff_string_..name:
    | // RD_E
    | setwd_call
    | lddsm     0, DISPATCH, DISPATCH_GL(gc.total), RB
    | lddsm     2, DISPATCH, DISPATCH_GL(gc.threshold), S0
    | cmpbdb    3, RD_E, (1+1)*8, pred0
    | addd      4, RD_E, 0, RD
    | disp      ctpr1, ->fff_fallback
    | --
    | ldd       0, STACK, SAVE_L, CARG1
    | disp      ctpr2, >1
    | wait_pred_ct pred0, 1
    | --
    | ct        ctpr1, pred0                // fff_fallback(BASE, RD)
    | --
    | cmpbdbsm  0, RB, S0, pred1
    | --
    | disp      ctpr1, extern lj_gc_step
    | wait_pred_ct pred1, 1
    | --
    | std       2, CARG1, L->base, BASE, ~pred1
    | addd      3, BASE, RD, RD, ~pred1
    | std       5, STACK, SAVE_PC, PC, ~pred1
    | ct        ctpr2, pred1                // >1
    | --
    | subd      3, RD, 0x8, RD
    | --
    | addd      3, CARG1, 0x0, RB
    | std       5, CARG1, L->top, RD
    | call      ctpr1, wbs = 0x8            // lj_gc_step(lua_State *L)
    | --
    | ldd       3, RB, L->base, BASE
    | ldd       5, RB, L->top, RD
    | wait_load BASE, 0
    | --
    | subd      3, RD, BASE, RD
    | --
    | addd      3, RD, 0x8, RD
    |1:
    | addd      0, DISPATCH, DISPATCH_GL(tmpbuf), CARG1
    | ldd       3, BASE, 0x0, CARG2
    | ldd       5, STACK, SAVE_L, RB
    | disp      ctpr2, ->fff_fallback
    | --
    | ldd       0, CARG1, SBUF->b, RC
    | --
    | disp      ctpr1, extern lj_buf_putstr_ .. name
    | --
    | sard      3, CARG2, 0x2f, ITYPE
    | getfd     4, CARG2, (47 << 6), CARG2
    | --
    | cmpesb    3, ITYPE, LJ_TSTR, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr2, ~pred0               // fff_fallback(BASE, RD)
    | --
    | std       2, CARG1, SBUF->L, RB
    | std       5, RB, L->base, BASE
    | --
    | std       2, CARG1, SBUF->p, RC
    | std       5, STACK, SAVE_PC, PC
    | call      ctpr1, wbs = 0x8            // lj_buf_putstr_op(SBuf *sb, GCstr *s)
    | --
    | disp      ctpr1, extern lj_buf_tostr
    | --
    | call      ctpr1, wbs = 0x8            // lj_buf_tostr(SBuf *sb)
    | --
    | // GStr * returned.
    | addd      0, 0x0, LJ_TSTR, ITYPE
    | ldd       3, RB, L->base, BASE
    | disp      ctpr1, ->fff_res
    | --
    | shld      0, ITYPE, 0x2f, ITYPE
    | --
    | ord       0, CRET1, ITYPE, CRET1
    | wait_load BASE, 0
    | --
    | addd      0, 0x0, (1+1)*8, RD
    | ldd       3, BASE, -8, PC
    | std       5, BASE, -16, CRET1
    | --
    | ct        ctpr1                       // fff_res(RD)
    | --
    |.endmacro
    |
    | ffstring_op reverse
    | ffstring_op lower
    | ffstring_op upper
    |
    |//-- Bit library --------------------------------------------------------
    |
    |.macro .ffunc_bit, name
    |->ff_bit_..name:
    | // RD_E
    | addd      0, RD_E, 0, RD
    | lddsm     3, BASE, 0x0, S0
    | cmpbdb    4, RD_E, (1+1)*8, pred0
    | disp      ctpr1, ->fff_fallback
    | wait_load S0, 0
    | --
    | sardsm    3, S0, 0x2f, ITYPE
    | fadddsm   4, S0, U64x(0x43380000,0x00000000), S0
    | disp      ctpr2, ->fff_resb
    | --
    | cmpbsbsm  3, ITYPE, LJ_TISNUM, pred1
    | --
    | ct        ctpr1, pred0                // fff_fallback(RD)
    | --
    | wait_pred_ct pred1, 2
    | --
    | adds      3, S0, 0x0, RB, pred1
    | ct        ctpr1, ~pred1               // fff_fallback(RD)
    | --
    |.endmacro
    |
    |.macro .ffunc_bit_op, name, ins
    | .ffunc_bit name
    | addd      3, RD, 0x0, S1              // Save for fallback.
    | addd      4, BASE, RD, RD
    | disp      ctpr1, ->fff_fallback
    | --
    | subd      3, RD, 0x10, RD
    | disp      ctpr3, >1
    | --
    |1:
    | istofd    3, RB, S0
    | cmpbedb   4, RD, BASE, pred0
    | lddsm     5, RD, 0x0, T1
    | wait_pred_ct pred0, 0
    | wait_load T1, 0
    | --
    | sardsm    3, T1, 0x2f, ITYPE
    | fadddsm   4, T1, U64x(0x43380000,0x00000000), T1
    | ct        ctpr2, pred0                // fff_resb(RD, S0)
    | --
    | cmpbsb    3, ITYPE, LJ_TISNUM, pred0
    | --
    | addd      3, S1, 0x0, RD, ~pred0      // Restore for fallback
    | wait_pred_ct pred0, 1
    | --
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    | adds      3, T1, 0x0, RA
    | subd      4, RD, 0x8, RD
    | --
    | ins       3, RB, RA, RB
    | ct        ctpr3                       // <1
    | --
    |.endmacro
    |
    |.ffunc_bit_op band, ands
    |.ffunc_bit_op bor, ors
    |.ffunc_bit_op bxor, xors
    |
    |.ffunc_bit tobit
    | istofd    3, RB, S0
    | ct        ctpr2                       // fff_resb(RD, S0)
    | --
    |
    |.ffunc_bit bswap
    | sxt       3, 0x6, RB, RB
    | addd      4, 0x0, U64x(0x80808080,0x00010203), S0
    | --
    | pshufb    3, RB, RB, S0, RB
    | --
    | istofd    3, RB, S0
    | ct        ctpr2                       // fff_resb(RD, S0)
    | --
    |
    |.ffunc_bit bnot
    | xors      3, RB, -1, RB
    | --
    | istofd    3, RB, S0
    | ct        ctpr2                       // fff_resb(RD, S0)
    | --
    |
    |.macro .ffunc_bit_sh, name, ins
    |->ff_..bit_..name:
    | // RD_E
    | addd      0, RD_E, 0, RD
    | lddsm     3, BASE, 0x0, T1
    | cmpbdb    4, RD_E, (2+1)*8, pred0
    | lddsm     5, BASE, 0x8, T2
    | disp      ctpr1, ->fff_fallback
    | --
    | addd      3, 0x0, U64x(0x43380000,0x00000000), S1
    | disp      ctpr2, ->fff_resb
    | wait_load T1, 1
    | --
    | sardsm    3, T1, 0x2f, S0
    | sardsm    4, T2, 0x2f, ITYPE
    | --
    | fadddsm   3, T1, S1, T1
    | fadddsm   4, T2, S1, T2
    | --
    | cmpbsbsm  3, S0, LJ_TISNUM, pred1
    | cmpbsbsm  4, ITYPE, LJ_TISNUM, pred2
    | ct        ctpr1, pred0                // fff_fallback(RD)
    | --
    | pass      pred1, p0
    | pass      pred2, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | --
    | adds      3, T1, 0x0, RB, pred0
    | ands      4, T2, 0xff, RA, pred0
    | ct        ctpr1, ~pred0               // fff_fallback(RD)
    | --
    | ins       3, RB, RA, RB
    | --
    | istofd    3, RB, S0
    | ct        ctpr2                       // fff_resb(RD, S0)
    | --
    |.endmacro
    |
    |.ffunc_bit_sh lshift, shls
    |.ffunc_bit_sh rshift, shrs
    |.ffunc_bit_sh arshift, sars
    |.ffunc_bit_sh rol, scls
    |.ffunc_bit_sh ror, scrs
    |
    |//-----------------------------------------------------------------------
    |
    |->fff_fallback:                        // Call fast function fallback handler.
    | // BASE = new base, RD = (nargs+1)*8
    | setwd_call
    | ldd 0, STACK, SAVE_L, RB
    | ldd 3, BASE, -8, PC                   // Fallback may overwrite PC.
    | addd 4, BASE, RD, RD
    | ldd 5, BASE, -16, S1
    | disp ctpr2, >5
    | nop 2
    | --
    | getfd 2, S1, (47 << 6), S1
    | ldd 3, RB, L->maxstack, S0
    | --
    | lddsm 0, S1, CFUNC->f, ITYPE
    | subd 3, RD, 0x8, RD
    | --
    | addd 3, RD, 8*LUA_MINSTACK, RA        // Ensure enough space for handler.
    | std 5, RB, L->top, RD
    | --
    | std 2, STACK, SAVE_PC, PC             // Redundant (but a defined value).
    | cmpbedb 3, RA, S0, pred0
    | addd 4, RB, 0x0, CARG1
    | std 5, RB, L->base, BASE
    | nop 1
    | --
    | movtdsm 0, ITYPE, ctpr1
    | --
    | ct ctpr2, ~pred0                      // Need to grow stack.
    | --
    | call ctpr1, wbs = 0x8                 // (lua_State *L)
    | --
    | // Either throws an error, or recovers and returns -1, 0 or nresults+1.
    | ldd 3, RB, L->base, BASE
    | shld 4, CRET1, 0x3, RD
    | disp ctpr2, ->fff_res
    | --
    | cmpledb 3, CRET1, 0x0, pred0
    | nop 2
    | --
    | ct ctpr2, ~pred0                      // Returned nresults+1?
    |1:
    | ldd 3, RB, L->top, RA
    | cmpedb 4, CRET1, 0x0, pred0
    | ldd 5, BASE, -16, RB
    | disp ctpr1, ->vm_call_tail
    | nop 2
    | --
    | subd 3, RA, BASE, RA
    | getfd 4, RB, (47 << 6), RB
    | --
    | addd 3, RA, 0x8, RD
    | ct ctpr1, ~pred0                      // Returned -1?
    | --
    | ins_callt                             // Returned 0: retry fast path.
    |
    |// Reconstruct previous base for vmeta_call during tailcall.
    |->vm_call_tail:
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | ldbsm 2, PC, PREV_PC_RA, RB
    | addd 3, BASE, 0x0, RA
    | disp ctpr1, >3
    | nop 2
    | --
    | lddsm 3, RA, -16, S1
    | subdsm 4, 0x0, RB, RB
    | disp ctpr2, ->vmeta_call
    | nop 1
    | --
    | shldsm 3, RB, 0x3, S0
    | ct ctpr1, ~pred0
    | --
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    | addd 3, BASE, S0, BASE
    | sard 4, S1, 0x2f, ITYPE
    | --
    | cmpesb 3, ITYPE, LJ_TFUNC, pred0
    | nop 1
    | --
    | subd 3, BASE, 0x10, BASE              // base = base - (RB+2)*8
    | getfd 4, S1, (47 << 6), RB
    | --
    | addd 3, RA, 0x0, BASE, pred0
    | ct ctpr2, ~pred0
    | --
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |3:
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    | ldd 3, RA, -16, S1
    | addd 4, PC, 0x0, RB
    | nop 2
    | --
    | andd 3, RB, -8, RB
    | sard 4, S1, 0x2f, ITYPE
    | --
    | cmpesb 3, ITYPE, LJ_TFUNC, pred0
    | subd 4, BASE, RB, BASE
    | getfd 5, S1, (47 << 6), RB
    | nop 2
    | --
    | addd 3, RA, 0x0, BASE, pred0
    | ct ctpr2, ~pred0
    | --
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |5: // Grow stack for fallback handler.
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    | --
    | addd 0, 0x0, LUA_MINSTACK, CARG2
    | addd 3, RB, 0x0, CARG1
    | nop 3
    | --
    | call ctpr1, wbs = 0x8
    | --
    | addd 2, 0x0, 0x0, CRET1               // Simulate a return 0.
    | ldd 3, RB, L->base, BASE
    | disp ctpr2, <1                        // Dumb retry (goes through ff first).
    | nop 4
    | --
    | ct ctpr2
    | --
    |
    |//-----------------------------------------------------------------------
    |//-- Special dispatch targets -------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_record:                           // Dispatch target for recording phase.
    | do_fault
    |
    |->vm_rethook:                          // Dispatch target for return hooks.
    | ldb       0, DISPATCH, DISPATCH_GL(hookmask), RD
    | addd      1, RA_E, 0, RA
    | disp      ctpr1, >5
    | --
    | disp      ctpr2, >1
    | wait_load RD, 1
    | --
    | cmpandedb 0, RD, HOOK_ACTIVE, pred0
    | wait_pred_ct pred0, 0
    | --
    | ct        ctpr1, ~pred0               // >5, Hook already active?
    | --
    | ct        ctpr2
    | --
    |
    |->vm_inshook:                          // Dispatch target for instr/line hooks.
    | // RA_E
    | ldb       0, DISPATCH, DISPATCH_GL(hookmask), RD
    | ldwsm     3, DISPATCH, DISPATCH_GL(hookcount), S0
    | addd      1, RA_E, 0, RA
    | disp      ctpr1, >5
    | --
    | disp      ctpr2, >1
    | wait_load RD, 1
    | --
    | cmpandedb 0, RD, HOOK_ACTIVE, pred0
    | cmpandedb 1, RD, LUA_MASKLINE|LUA_MASKCOUNT, pred1
    | subdsm    3, S0, 0x1, S0
    | --
    | cmpandedb 0, RD, LUA_MASKLINE, pred3
    | cmpedbsm  3, S0, 0x0, pred2
    | wait_pred_ct pred0, 1
    | --
    | ct        ctpr1, ~pred0               // >5, Hook already active?
    | --
    | ct        ctpr1, pred1                // >5, Hook already active?
    | --
    | stw       5, DISPATCH, DISPATCH_GL(hookcount), S0
    | ct        ctpr2, pred2                // >1
    | --
    | ct        ctpr1, pred3                // >5, Hook already active?
    | --
    |1:
    | disp      ctpr1, extern lj_dispatch_ins
    | --
    | setwd_call
    | ldd       0, STACK, SAVE_L, RB
    | wait_load RB, 0
    | --
    | addd      0, RB, 0x0, CARG1
    | addd      1, PC, 0x0, CARG2
    | std       2, RB, L->base, BASE
    | // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
    | call      ctpr1, wbs = 0x8            // lj_dispatch_ins(lua_State *L, const BCIns *pc)
    |3:
    | ldd       0, RB, L->base, BASE
    | --
    |4:
    | ldb       0, PC, PREV_PC_RA, RA
    | wait_load RA, 0
    | --
    | shld      0, RA, 0x3, RA
    | --
    |5:
    | // RA
    | subd      0, PC, 4, PC                   // Current PC.
    | disp      ctpr1, ->vm_restart_pipeline_static_ra // TODO: inline/optimize
    | --
    | ct        ctpr1
    | --
    |
    |->cont_hook:                           // Continue from hook yield.
    | do_fault
    |
    |->vm_callhook:                         // Dispatch target for call hooks.
    | std       2, STACK, SAVE_PC, PC
    | --
    |
    |->vm_hotcall:                          // Hot call counter underflow.
    | // RD_E
    | disp ctpr1, extern lj_dispatch_call
    | --
    | setwd_call
    | ldd       0, STACK, SAVE_L, RB
    | addd      1, BASE, RD_E, RD
    | --
    | subd      0, RD, 8, RD
    | wait_load RB, 1
    | --
    | addd      0, RB, 0, CARG1
    | addd      1, PC, 0, CARG2
    | addd      3, 0, 0, S0
    | --
    | std       2, RB, L->base, BASE
    | std       5, RB, L->top, RD
    | call      ctpr1, wbs = 0x8            // lj_dispatch_call(lua_State *L, const BCIns *pc)
    | --
    | // ASMFunction returned.
    | setwd_pipe
    | movtd     0, CRET1, ctpr3             // Prepare an insn handler for stage E.
    | addd      1, CRET1, 0x0, T0
    | ldd       2, RB, L->base, BASE
    | ldd       3, RB, L->top, RD
    | std       5, STACK, SAVE_PC, S0       // Invalidate for subsequent line hook.
    | --
    | ldw       0, PC,-4, INSN_E            // Load insns.
    | ldwsm     2, PC, 0, INSN_B
    | ldwsm     3, PC, 4, INSN_L
    | ldwsm     5, PC, 8, INSN_D
    | --
    | ldwsm     0, PC,12, INSN_S
    | wait_load INSN_B, 1
    | --
    | shld      0, INSN_E, 3, OP_E
    | shldsm    2, INSN_B, 3, OP_B          // Scale opcode fields.
    | shldsm    3, INSN_L, 3, OP_L
    | shldsm    5, INSN_D, 3, OP_D
    | --
    | anddsm    1, OP_E, 0x7f8, OP_E        // Extract opcode fields.
    | anddsm    2, OP_B, 0x7f8, OP_B
    | anddsm    3, OP_L, 0x7f8, OP_L
    | subd      4, RD, BASE, RD
    | --
    | addd      0, T0, 0, DISPATCH_E
    | lddsm     2, OP_B, DISPATCH, DISPATCH_B
    | shrd      1, INSN_E, 0x5, RA_E        // Scale other fields for stage E.
    | shrd      3, INSN_E, 0x15, RB_E
    | addd      4, RD, 0x8, RD
    | --
    | andd      1, RA_E, 0x7f8, RA_E        // Extract other fields for stage E.
    | andd      3, RB_E, 0x7f8, RB_E
    | addd      4, 0, 0, RC_E               // FIXME: set to RD???
    | addd      5, RD, 0, RD_E
    | --
    | shrdsm    3, INSN_B, 0x5, RA_B        // Scale other fields for stage B.
    | shrdsm    4, INSN_B, 0x15, RB_B
    | shrdsm    5, INSN_B, 0xd, RCD_B
    | --
    | ct        ctpr3                       // Jump to the insn handler for stage E.
    | --
    |
    |->vm_profhook:                         // Dispatch target for profiler hook.
#if LJ_HASPROFILE
    | disp ctpr1, extern lj_dispatch_profile
    | --
    | setwd_call
    | ldd       0, STACK, SAVE_L, RB
    | wait_load RB, 0
    | --
    | addd      0, RB, 0x0, CARG1
    | addd      1, PC, 0x0, CARG2
    | std       2, RB, L->base, BASE
    | --
    | call      ctpr1, wbs = 0x8            // lj_dispatch_profile(lua_State *L, const BCIns *pc)
    | --
    | ldd       0, RB, L->base, BASE
    | // HOOK_PROFILE is off again, so re-dispatch to dynamic instruction.
    | subd      1, PC, 4, PC
    | --
    | ins_next
#endif
    |
    |//-----------------------------------------------------------------------
    |//-- Trace exit handler -------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    | // Unsupported
    |
    |//-----------------------------------------------------------------------
    |//-- Math helper functions ----------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |// FP value rounding. Called by math.floor/math.ceil fast functions.
    |.macro vm_round, name, mode
    |->name:
    | setwd wsz = 0x4, nfx = 0x1, dbl = 0x0
    | return ctpr3
    | nop 4
    | --
    |.if mode == 2                          // trunc(x)?
    | fdtoifd 3, 0x3, RARG1, RRET1
    | --
    |.elif mode == 1                        // ceil(x)?
    | fdtoifd 3, 0x2, RARG1, RRET1
    | --
    |.else                                  // floor(x)
    | fdtoifd 3, 0x1, RARG1, RRET1
    | --
    |.endif
    | ct ctpr3
    | --
    |.endmacro
    |
    | vm_round vm_floor, 0
    | vm_round vm_ceil,  1
    | vm_round vm_trunc, 2
    |
    |// modulo x%y. Called by vm_arith.
    |->vm_mod:
    | addd      0, RARG1, 0, T9
    | addd      1, 0, U64x(0x43300000,0x00000000), T0
    | shld      2, 1, 63, T1                // 0x80000000_00000000
    | fdivd     5, RARG1, RARG2, T3
    | return    ctpr3
    | wait      T3, 0, 16
    | --
    | fmuldsm   3, RARG2, T3, T8
    | wait      T3, 16, 16 + 2              // fp->int extra delay
    | --
    | andnd     3, T3, T1, T4               // |x/y|
    | andd      4, T3, T1, T5               // Isolate sign bit.
    | --
    | fcmpnltdb 3, T4, T0, pred0            // |x/y| >= 2^52
    | faddd     4, T4, T0, T4               // (|x/y| + 2^52) - 2^52
    | --
    | fsubdsm   4, T9, T8, RARG1
    | wait      T4, 1, 4
    | --
    | fsubd     3, T4, T0, T4
    | ct        ctpr3, pred0                // return
    | --
    | wait      T4, 1, 4 + 2                // fp->int extra delay
    | --
    | ord       3, T4, T5, T4               // Merge sign bit back in.
    | --
    | fsubdsm   3, T4, U64x(0x3ff00000,0x00000000), T6 // If yes, subtract 1.0.
    | fmuldsm   4, RARG2, T4, T7
    | --
    | fcmpltdb  3, T3, T4, pred1
    | wait      T6, 1, 4
    | --
    | fmuldsm   3, RARG2, T6, T6
    | fsubd     4, T9, T7, RARG1
    | wait      RARG1, 0, 4
    | ct        ctpr3, ~pred1               // return
    | --
    | fsubd     3, T9, T6, RARG1
    | wait      RARG1, 0, 4
    | ct        ctpr3                       // return
    | --
    |
    |// modulo x%y. Called by BC_MOD*.
    |->vm_mod_fast:                         // (x: f64, y: f64, z: x/y)
    | addd      0, PARG1, 0, T9
    | addd      1, 0, U64x(0x43300000,0x00000000), T0
    | fmuldsm   3, PARG2, PARG3, T8
    | shld      4, 1, 63, T1                // 0x80000000_00000000
    | wait      PARG3, 16, 16 + 2           // fp->int extra delay
    | --
    | andnd     3, PARG3, T1, T4            // |x/y|
    | andd      4, PARG3, T1, T5            // Isolate sign bit.
    | --
    | fcmpnltdb 3, T4, T0, pred0            // |x/y| >= 2^52
    | faddd     4, T4, T0, T4               // (|x/y| + 2^52) - 2^52
    | --
    | fsubdsm   4, T9, T8, PARG1
    | wait      T4, 1, 4
    | --
    | fsubd     3, T4, T0, T4
    | ct        ctpr1, pred0                // return
    | --
    | wait      T4, 1, 4 + 2                // fp->int extra delay
    | --
    | ord       3, T4, T5, T4               // Merge sign bit back in.
    | --
    | fsubdsm   3, T4, U64x(0x3ff00000,0x00000000), T6 // If yes, subtract 1.0.
    | fmuldsm   4, PARG2, T4, T7
    | --
    | fcmpltdb  3, PARG3, T4, pred1
    | wait      T6, 1, 4
    | --
    | fmuldsm   3, PARG2, T6, T6
    | fsubd     4, T9, T7, PARG1
    | wait      PARG1, 0, 4
    | ct        ctpr1, ~pred1               // return
    | --
    | fsubd     3, T9, T6, PARG1
    | wait      PARG1, 0, 4
    | ct        ctpr1                       // return
    | --
    |
    |//-----------------------------------------------------------------------
    |//-- Miscellaneous functions --------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |//-----------------------------------------------------------------------
    |//-- Assertions ---------------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->assert_bad_for_arg_type:
    | disp ctpr1, extern raise              // sigtrap
    | --
    | addd 0, 0x5, 0x0, CARG1
    | --
    | call ctpr1, wbs = 0x8
    | --
    |
    |//-----------------------------------------------------------------------
    |//-- FFI helper functions -----------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |// Handler for callback functions.
    |->vm_ffi_callback:
    |.if FFI
    | do_fault
    |.endif
    |
    |->cont_ffi_callback:                   // Return from FFI callback.
    |.if FFI
    | .type CTSTATE, CTState
    | disp ctpr1, extern lj_ccallback_leave // (CTState *cts, TValue *o)
    | --
    | ldd 0, STACK, SAVE_L, RA
    | addd 1, CRET1, 0x0, CARG2
    | ldd 2, DISPATCH, DISPATCH_GL(ctype_state), PC
    | nop 2
    | --
    | std 2, RA, L->base, BASE
    | std 5, PC, CTSTATE->L, RA
    | --
    | addd 1, PC, 0x0, CARG1
    | std 2, RA, L->top, RB
    | call ctpr1, wbs = 0x8
    | --
    | ldd 0, PC, CTSTATE->cb.gpr[0], RRET1
    | return ctpr3
    | --
    | ct ctpr3
    | --
    |.endif
    |
    |->vm_ffi_call:                         // Call C function via FFI.
    |.if FFI
    | .type CCSTATE, CCallState
    | setwd wsz = 0x8, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x4, rcur = 0x0
    | disp ctpr1, >2
    | --
    | ldw 0, RARG1, CCSTATE->spadj, RARG3
    | ldb 2, RARG1, CCSTATE->nsp, RARG5
    | disp ctpr2, >1
    | nop 2
    | --
    | subd 0, 0x0, RARG3, RARG3
    | subd 1, RARG5, 0x1, RARG5
    | --
    | getsp 0, RARG3, RARG4                 // allocate stack for parameters and return value
    | cmpldb 1, RARG5, 0x0, pred0
    | nop 2
    | --
    | // Copy stack slots.
    | shld 0, RARG5, 0x3, RARG5, ~pred0
    | ct ctpr1, pred0
    |1:
    | addd 0, RARG5, 0x40, RARG2
    | addd 1, RARG1, offsetof(CCallState, stack), RARG6
    | --
    | ldd 0, RARG6, RARG5, RARG6            // read stack parameters
    | subd 1, RARG5, 0x8, RARG5
    | --
    | cmpldb 0, RARG5, 0x0, pred0
    | nop 2
    | --
    | std 2, RARG4, RARG2, RARG6            // write to allocated stack
    | ct ctpr2, ~pred0
    |2: // wrire register parameters on stack too
    | ldd 0, RARG1, CCSTATE->gpr[0], CARG1
    | ldd 2, RARG1, CCSTATE->func, RARG2
    | ldd 3, RARG1, CCSTATE->gpr[1], CARG2
    | ldd 5, RARG1, CCSTATE->gpr[2], CARG3
    | --
    | ldd 0, RARG1, CCSTATE->gpr[3], CARG4
    | ldd 2, RARG1, CCSTATE->gpr[4], CARG5
    | ldd 3, RARG1, CCSTATE->gpr[5], CARG6
    | --
    | ldd 0, RARG1, CCSTATE->gpr[7], CARG8
    | ldd 2, RARG1, CCSTATE->gpr[6], CARG7
    | --
    | movtd 0, RARG2, ctpr1
    | std 2, RARG4, 0x0, CARG1
    | std 5, RARG4, 0x8, CARG2
    | --
    | std 2, RARG4, 0x10, CARG3
    | std 5, RARG4, 0x18, CARG4
    | --
    | std 2, RARG4, 0x20, CARG5
    | std 5, RARG4, 0x28, CARG6
    | --
    | std 2, RARG4, 0x30, CARG7
    | std 5, RARG4, 0x38, CARG8
    | call ctpr1, wbs = 0x4
    | --
    | // speculatively write from return regs, if result > 8*8 bytes, read all from stack
    | ldw 0, RARG1, CCSTATE->ret_size, RARG2
    | disp ctpr2, >3
    | nop 1
    | --
    | disp ctpr1, extern memcpy
    | --
    | cmpedb 0, RARG2, 0x0, pred0
    | nop 2
    | --
    | ldd 0, RARG1, CCSTATE->ret_stack, CARG1, ~pred0
    | addd 1, RARG2, 0x0, CARG3, ~pred0
    | addd 2, RARG4, 0x0, CARG2, ~pred0
    | ct ctpr2, pred0
    | --
    | call ctpr1, wbs = 0x4
    | --
    | return ctpr3
    | --
    | ct ctpr3
    |3:
    | stdsm 2, RARG1, CCSTATE->gpr[0], CRET1
    | stdsm 5, RARG1, CCSTATE->gpr[1], CRET2
    | return ctpr3
    | --
    | stdsm 2, RARG1, CCSTATE->gpr[2], CRET3
    | stdsm 5, RARG1, CCSTATE->gpr[3], CRET4
    | --
    | stdsm 2, RARG1, CCSTATE->gpr[4], CRET5
    | stdsm 5, RARG1, CCSTATE->gpr[5], CRET6
    | --
    | stdsm 2, RARG1, CCSTATE->gpr[6], CRET7
    | stdsm 5, RARG1, CCSTATE->gpr[7], CRET8
    | ct ctpr3
    | --
    |.endif
    |//-----------------------------------------------------------------------
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
    int vk = 0;
    |=>defop:

    switch (op) {

    /* -- Comparison ops ---------------------------------------------------- */

    /* Remember: all ops branch for a true comparison, fall through otherwise. */

    case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
        | // ins_AD RA_E = src1*8, RD_E = src2*8, JMP with RD = target
        | // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
        | pipe_dispatch_load 0
        | pipe_extract_d 2                  // JMP.RD*8
        | pipe_bypass_check 1, RA_E, pred0
        | pipe_bypass_check 4, RD_E, pred1
        | ldd       3, BASE, RA_E, RA
        | ldd       5, BASE, RD_E, RD
        | disp      ctpr1, ->vm_restart_pipeline_fast
        | --
        | pipe_fetch 2
        | pipe_scale_a 3
        | pipe_scale_b 4
        | pipe_scale_cd 5
        | shrd      0, RD_B, 1, S0          // JMP.RD*4.
        | subd      1, PC, BCBIAS_J*4 - 4, S1
        | disp      ctpr2, extern lj_meta_comp
        | --
        | abnf                              // Advance to next stage.
        | pipe_extract_op 0
        | pipe_scale_op 5
        | pipe_bypass_use 3, RA, pred0
        | pipe_bypass_use 4, RD, pred1
        | addd      1, PC, 4, PC            // PC for next stage.
        | ldb       2, S1, S0, RARG1        // Load an opcode for taken branch.
        | wait_load RA, 2
        | --
        switch (op) {
        case BC_ISLT:
        | pipe_dispatch_prep 0, ctpr3
        | fcmpltdb  3, RA, RD, pred2
        | sard      4, RA, 0x2f, T0
        | sard      5, RD, 0x2f, T1
        | --
          break;
        case BC_ISGE:
        | pipe_dispatch_prep 0, ctpr3
        | fcmpnltdb 3, RA, RD, pred2
        | sard      4, RA, 0x2f, T0
        | sard      5, RD, 0x2f, T1
        | --
          break;
        case BC_ISLE:
        | pipe_dispatch_prep 0, ctpr3
        | fcmpledb  3, RA, RD, pred2
        | sard      4, RA, 0x2f, T0
        | sard      5, RD, 0x2f, T1
        | --
          break;
        case BC_ISGT:
        | pipe_dispatch_prep 0, ctpr3
        | fcmpnledb 3, RA, RD, pred2
        | sard      4, RA, 0x2f, T0
        | sard      5, RD, 0x2f, T1
        | --
          break;
        default: break;
        }
        | pipe_fetch 0
        | pipe_bypass_none 1
        | pipe_dispatch_load 2
        | cmpbsb    3, T0, LJ_TISNUM, pred0
        | cmpbsb    4, T1, LJ_TISNUM, pred1
        | --
        | pipe_scale 1, 2, 3, 4
        | shld      0, RARG1, 3, RARG1      // Scale an opcode for taken branch.
        | lddsm     5, STACK, SAVE_L, RB    // Used in lj_meta_comp.
        | --
        | pipe_extract 1, 2, 3, 4, 5
        | ldd       0, RARG1, DISPATCH, RARG1   // Load dispath for branch target.
        | pass      pred0, p0
        | pass      pred1, p1
        | pass      pred2, p2
        | landp     p0, p1, p4
        | landp     p4, p2, p5
        | landp     p4, ~p2, p6
        | pass      p4, pred0
        | pass      p5, pred1               // Branch is taken.
        | pass      p6, pred2               // Branch is not taken.
        | wait_pred_ct pred1, 0
        | wait_load RARG1, 1                // Must be ready for vm_restart_pipeline_fast.
        | --
        | addd      0, S1, S0, PC, pred1    // Set PC to branch target if taken.
        | ct        ctpr1, pred1            // vm_restart_pipeline_fast(RARG1), taken
        | --
        | subd      1, PC, 4, PC, ~pred0    // Restore PC for vmeta_comp.
        | addd      2, RB, 0, PARG1
        | addd      3, BASE, RA_W, PARG2
        | addd      4, BASE, RD_W, PARG3
        | shrd      5, OP_W, 3, PARG4
        | pipe_dispatch_if 0, ctpr3, pred2  // Not taken, goto next insn.
        | --
        | // inlined vmeta_comp
        | std       2, RB, L->base, BASE
        | std       5, STACK, SAVE_PC, PC
        | pipe_call ctpr2                   // lj_meta_comp(lua_State *L, TValue *o1, *o2, int op)
        | --
        | // 0/1 or TValue * (metamethod) returned.
        | cmpbedb   0, PARG1, 1, pred0
        | cmpbdb    1, PARG1, 1, pred1
        | ldd       2, RB, L->base, BASE
        | disp      ctpr1, ->vmeta_binop
        | --
        | disp      ctpr2, ->vm_restart_pipeline_fast
        | wait_pred pred0, 1
        | --
        | pipe_dispatch_prep 0, ctpr3
        | addd      1, PC, 4, PC, pred0
        | addd      2, PARG1, 0, CRET1, ~pred0 // FIXME: remove me in the future...
        | --
        | ct        ctpr1, ~pred0           // vmeta_binop(CRET1)
        | --
        | addd      0, S1, S0, PC, ~pred1   // Set PC to branch target if taken.
        | ct        ctpr2, ~pred1           // vm_restart_pipeline_fast(RARG1)
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_ISEQV: case BC_ISNEV:
        vk = op == BC_ISEQV;
        | // ins_AD RA_E = src1*8, RD_E = src2*8, JMP with RD = target
        | addd      0, PC, 0x4, PC
        | subd      1, PC, BCBIAS_J*4 - 4, T2
        | shrd      2, INSN_B, 0xe, T1      // JMP.RD*4
        | ldd       3, BASE, RD_E, RD
        | ldd       5, BASE, RA_E, RA
        | disp      ctpr1, >3
        | --
        | andd      0, T1, 0x3fffc, T1      // extract JMP.RD*4 (18 bits)
        | disp      ctpr2, >2
        | --
        | disp      ctpr3, >1
        | wait_load RA, 2
        | --
        | fcmpuoddb 3, RA, RD, pred2
        | fcmpeqdb  4, RA, RD, pred3
        | --
        | sard      4, RA, 0x2f, ITYPE
        | sard      5, RD, 0x2f, RB
        | --
        | cmpbsb    3, RB, LJ_TISNUM, pred0
        | cmpbsb    4, ITYPE, LJ_TISNUM, pred1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     p0, p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
        | pass      pred2, p0
        | pass      pred3, p1
        | landp     ~p0, p1, p4
        | pass      p4, pred1
        | ct        ctpr1, ~pred0           // >3
        | --
        | wait_pred_ct pred1, 1
        | --
        if (vk) {
          | ct      ctpr2, ~pred1           // >2
          |1: // EQ: Branch to the target.
          | addd    0, T2, T1, PC
          |2: // NE: Fallthrough to next instruction.
        } else {
          | ct      ctpr3, pred1            // >1
          |2: // NE: Branch to the target.
          | addd    0, T2, T1, PC
          |1: // EQ: Fallthrough to next instruction.
        }
        | disp      ctpr1, ->vm_restart_pipeline    // TODO: inline/optimize
        | --
        | ct        ctpr1                   // vm_restart_pipeline
        | --
        |3: // Either or both types are not numbers.
        |.if FFI
        | cmpesb    3, RB, LJ_TCDATA, pred0
        | cmpesb    4, ITYPE, LJ_TCDATA, pred1
        | disp      ctpr1, ->vmeta_equal_cd
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, ~p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, ~pred0           // vmeta_equal_cd
        | --
        |.endif
        | cmpbesb   1, RB, LJ_TISTABUD, pred2
        | cmpedb    3, RA, RD, pred0
        | cmpesb    4, RB, ITYPE, pred1
        | getfd     5, RA, (47 << 6), RA
        | disp      ctpr1, ->vmeta_equal
        | --
        | lddsm     3, RA, TAB->metatable, RB
        | wait_pred_ct pred0, 1
        | --
        | pass      pred1, p0
        | pass      pred2, p1
        | landp     p0, p1, p4
        | pass      p4, pred1
        | ct        ctpr3, pred0            // <1, Same GCobjs or pvalues?
        | --
        | wait_pred_ct pred1, 1
        | --
        | ldbsm     3, RB, TAB->nomm, S0
        | cmpedbsm  4, RB, 0x0, pred0
        | ct        ctpr2, ~pred1           // <2, Not the same type? or Different objects and not table/ud?
        | --
        | wait_pred_ct pred0, 1
        | --
        | // Different tables or userdatas. Need to check __eq metamethod.
        | // Field metatable must be at same offset for GCtab and GCudata!
        | ct        ctpr2, pred0            // <2, No metatable?
        | --
        | cmpandedb 3, S0, 1<<MM_eq, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr2, ~pred0           // <2, Or 'no __eq' flag set?
        | --
        if (vk) {
          | addd    3, 0x0, 0x0, RB         // ne = 0
          | ct      ctpr1                   // vmeta_equal(RA, RB, RD), Handle __eq metamethod.
          | --
        } else {
          | addd    3, 0x0, 0x1, RB         // ne = 1
          | ct      ctpr1                   // vmeta_equal(RA, RB, RD), Handle __eq metamethod.
          | --
        }
        break;

    case BC_ISEQS: case BC_ISNES:
        vk = op == BC_ISEQS;
        | // ins_AND RA_E = src*8, RD_E = str_const*8, JMP with RD = target
        | addd      0, PC, 0x4, PC
        | subd      1, PC, BCBIAS_J*4 - 4, T2
        | shrd      2, INSN_B, 0xe, T1      // JMP.RD*4
        | ldd       3, BASE, RA_E, RA
        | subd      4, KBASE, RD_E, RD
        | disp      ctpr1, >3
        | --
        | andd      0, T1, 0x3fffc, T1      // extract JMP.RD*4 (18 bits)
        | ldd       3, RD, -8, RD
        | disp      ctpr2, >2
        | --
        | disp      ctpr3, >1
        | wait_load RA, 2
        | --
        | sard      3, RA, 0x2f, ITYPE
        | getfd     4, RA, (47 << 6), RA
        | --
        | cmpesb    3, ITYPE, LJ_TSTR, pred1
        | cmpedb    4, RA, RD, pred0
        | wait_pred_ct pred1, 0
        | --
        | ct        ctpr1, ~pred1           // >3
        | --
        if (vk) {
          | ct      ctpr2, ~pred0           // >2
          |1: // EQ: Branch to the target.
          | addd    0, T2, T1, PC
          |2: // NE: Fallthrough to next instruction.
          |.if not FFI
          |3:
          |.endif
        } else {
          | ct      ctpr3, pred0            // >1
          |.if not FFI
          |3:
          |.endif
          |2: // NE: Branch to the target.
          | addd    0, T2, T1, PC
          |1: // EQ: Fallthrough to next instruction.
        }
        | disp      ctpr1, ->vm_restart_pipeline    // TODO: inline/optimize
        | --
        | ct        ctpr1                   // vm_restart_pipeline
        | --
        |.if FFI
        |3:
        | cmpesb 3, ITYPE, LJ_TCDATA, pred0
        | disp      ctpr1, ->vmeta_equal_cd
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr2, ~pred0           // <2
        | --
        | ct        ctpr1                   // vmeta_equal_cd(TODO)
        | --
        |.endif
        break;

    case BC_ISEQN: case BC_ISNEN:
        vk = op == BC_ISEQN;
        | // ins_AD RA_E = src*8, RD_E = num_const*8, JMP with RD = target
        | addd      0, PC, 0x4, PC
        | subd      1, PC, BCBIAS_J*4 - 4, T2
        | shrd      2, INSN_B, 0xe, T1      // JMP.RD*4
        | ldd       3, BASE, RA_E, RA
        | ldd       5, KBASE, RD_E, RD
        | disp      ctpr1, >3
        | --
        | andd      0, T1, 0x3fffc, T1      // extract JMP.RD*4 (18 bits)
        | disp      ctpr3, >1
        | --
        | disp      ctpr2, >2
        | wait_load RD, 2
        | --
        | fcmpuoddb 3, RD, RA, pred2
        | fcmpeqdb  4, RD, RA, pred3
        | sard      5, RA, 0x2f, ITYPE
        | --
        | cmpbsb    3, ITYPE, LJ_TISNUM, pred0
        | wait_pred_ct pred0, 0
        | --
        | pass      pred2, p0
        | pass      pred3, p1
        | landp     ~p0, p1, p4
        | pass      p4, pred1
        | ct        ctpr1, ~pred0           // >3
        | --
        if (vk) {
          | ct      ctpr2, ~pred1           // >2
          |1: // EQ: Branch to the target.
          | addd    0, T2, T1, PC
          |2: // NE: Fallthrough to next instruction.
          |.if not FFI
          |3:
          |.endif
        } else {
          | ct      ctpr3, pred1            // >1
          | --
          |.if not FFI
          |3:
          |.endif
          |2: // NE: Branch to the target.
          | addd    0, T2, T1, PC
          |1: // EQ: Fallthrough to next instruction.
        }
        | disp      ctpr1, ->vm_restart_pipeline    // TODO: optimize
        | --
        | ct        ctpr1                   // vm_restart_pipeline
        | --
        |.if FFI
        |3:
        | cmpesb    3, ITYPE, LJ_TCDATA, pred0
        | disp      ctpr1, ->vmeta_equal_cd
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr2, ~pred0           // <2
        | --
        | ct        ctpr1                   // vmeta_equal_cd
        | --
        |.endif
        break;

    case BC_ISEQP: case BC_ISNEP:
        vk = op == BC_ISEQP;
        | // ins_AND RA_E = src*8, RD_E = primitive_type*8 (~), JMP with RD = target
        | addd      0, PC, 0x4, PC
        | shrd      1, INSN_B, 0xe, T1      // JMP.RD*4
        | ldd       3, BASE, RA_E, RA
        | shrd      4, RD_E, 0x3, RD
        | disp      ctpr1, ->vmeta_equal_cd
        | --
        | andd      0, T1, 0x3fffc, T1      // extract JMP.RD*4 (18 bits)
        | subd      1, PC, BCBIAS_J*4, T2
        | xord      3, RD, -1, RD
        | disp      ctpr2, ->vm_restart_pipeline    // TODO: inline
        | --
        | sard      3, RA, 0x2f, RA
        | --
        | cmpesb    3, RA, RD, pred0
        | cmpesb    4, RA, LJ_TCDATA, pred1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, p1, p4
        | landp     ~p0, ~p1, p5
        | pass      p4, pred2
        | pass      p5, pred1
        | wait_pred_ct pred2, 0
        | --
        if (vk) {
          | addd    0, T2, T1, PC, pred0
          | ct      ctpr1, pred2            // vmeta_equal_cd
          | --
        } else {
          | addd    0, T2, T1, PC, pred1
          | ct      ctpr1, pred2            // vmeta_equal_cd
          | --
        }
        | // TODO: skip jump and continue if not taken
        | ct        ctpr2                   // vm_restart_pipeline
        | --
        break;

    /* -- Unary test and copy ops ------------------------------------------- */

    case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
        | // ins_AD RA_E = dst*8 or unused, RD_E = src*8, JMP with RD = target
        | pipe_dispatch_load 0
        | subd      1, PC, BCBIAS_J*4 - 4, T2
        | pipe_extract_d 2                  // JMP.RD*8
        | ldd       3, BASE, RD_E, RD
        | pipe_bypass_check 4, RD_E, pred2
        | disp      ctpr1, ->vm_restart_pipeline_fast
        | --
        | pipe_fetch 2
        | pipe_scale 1, 3, 4, 5
        | shrd      0, RD_B, 1, T1          // JMP.RD*4.
        | --
        | ldb       2, T2, T1, RARG1        // Load an opcode for taken branch.
        | pipe_bypass_use 3, RD, pred2
        | wait_load RD, 2
        | --
        | pipe_extract_op 0
        | sard      3, RD, 0x2f, ITYPE
        | --
        | abnf                              // Advance to next stage.
        | addd      0, PC, 4, PC            // PC for next stage.
        | cmpbsb    3, ITYPE, LJ_TISTRUECOND, pred0
        | --
        | pipe_dispatch_prep 0, ctpr3
        | shld      1, RARG1, 3, RARG1      // Scale an opcode for taken branch.
        | --
        switch (op) {
        case BC_ISTC:
        | ldd       2, RARG1, DISPATCH, RARG1   // Load dispath for branch target.
        | addd      4, T2, T1, PC, pred0
        | std       5, BASE, RA_W, RD
        | --
        | wait_load RARG1, 1
        | ct        ctpr1, pred0            // vm_restart_pipeline_fast(RARG1)
        | --
          break;
        case BC_ISFC:
        | ldd       2, RARG1, DISPATCH, RARG1   // Load dispath for branch target.
        | addd      3, T2, T1, PC, ~pred0
        | std       5, BASE, RA_W, RD
        | --
        | wait_load RARG1, 1
        | ct        ctpr1, ~pred0           // vm_restart_pipeline_fast(RARG1)
        | --
          break;
        case BC_IST:
        | addd      1, T2, T1, PC, pred0
        | ldd       2, RARG1, DISPATCH, RARG1   // Load dispath for branch target.
        | --
        | wait_load RARG1, 1
        | ct        ctpr1, pred0            // vm_restart_pipeline_fast(RARG1)
        | --
          break;
        case BC_ISF:
        | addd      1, T2, T1, PC, ~pred0
        | ldd       2, RARG1, DISPATCH, RARG1   // Load dispath for branch target.
        | --
        | wait_load RARG1, 1
        | ct        ctpr1, ~pred0           // vm_restart_pipeline_fast(RARG1)
        | --
          break;
        default:
          break;
        }
        // BC_JMP
        | pipe_bypass_none 0
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | --
        | pipe_scale 0, 1, 2, 3
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_ISTYPE:
        | // ins_AD RA_E = src*8, RD_E = -type*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 4, RA_E, pred1
        | ldd       5, BASE, RA_E, RB
        | disp      ctpr1, ->vmeta_istype
        | --
        | pipe_scale 0, 1, 2, 3
        | addd      4, RA_E, 0, RA
        | addd      5, RD_E, 0, RD
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_use 5, RB, pred1
        | wait_load RB, 2
        | --
        | sard      3, RB, 0x2c, RB
        | --
        | andd      3, RB, -8, RB
        | --
        | addd      3, RB, RD_E, RB
        | --
        | cmpedb    3, RB, 0x0, pred0
        | --
        | ct        ctpr1, ~pred0           // vmeta_istype(RA, RD)
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_ISNUM:
        | // ins_AD RA_E = src*8, RD_E = -(TISNUM-1)*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 4, RA_E, pred1
        | ldd       5, BASE, RA_E, T1
        | disp      ctpr2, ->vmeta_istype
        | --
        | pipe_scale 0, 1, 2, 3
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_use 5, T1, pred1
        | wait_load T1, 2
        | --
        | addd      0, RA_E, 0, RA
        | addd      1, RD_E, 0, RD
        | sard      3, T1, 0x2f, ITYPE
        | --
        | cmpbsb    3, ITYPE, LJ_TISNUM, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr2, ~pred0           // vmeta_istype(RA, RD)
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    /* -- Unary ops --------------------------------------------------------- */

    case BC_MOV:
        | // ins_AD RA_E = dst*8, RD_E = src*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_some 1, RA_E
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 4, RD_E, pred0
        | ldd 5, BASE, RD_E, RESULT_E
        | --
        | pipe_scale 0, 1, 2, 3
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_use 5, RESULT_E, pred0
        | wait_load RESULT_E, 2
        | --
        | std 5, BASE, RA_E, RESULT_E
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_NOT:
        | // ins_AD RA_E = dst*8, RD_E = src*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_some 1, RA_E
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 4, RD_E, pred1
        | ldd       5, BASE, RD_E, T0
        | --
        | pipe_scale 0, 1, 2, 3
        | shld      4, 1, 0x2f, T1
        | shld      5, 2, 0x2f, T2
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_use 5, T0, pred1
        | wait_load T0, 2
        | --
        | sard      3, T0, 0x2f, T0
        | xord      4, T1, -1, T1
        | xord      5, T2, -1, T2
        | --
        | cmpbsb    3, T0, LJ_TISTRUECOND, pred0
        | wait_pred_ct pred0, 0
        | --
        | addd      1, T1, 0, RESULT_E, pred0
        | addd      3, T2, 0, RESULT_E, ~pred0
        | std       2, BASE, RA_E, T1, pred0
        | std       5, BASE, RA_E, T2, ~pred0
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_UNM:
        | // ins_AD RA_E = dst*8, RD_E = src*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 4, RD_E, pred1
        | ldd       5, BASE, RD_E, T1
        | disp      ctpr1, ->vmeta_unm
        | --
        | pipe_scale 0, 1, 2, 3
        | shld      4, 1, 63, T0
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_use 5, T1, pred1
        | wait_load T1, 2
        | --
        | sard      3, T1, 0x2f, ITYPE
        | xord      4, T1, T0, RESULT_E
        | --
        | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
        | wait_pred pred0, 0
        | --
        | pipe_bypass_some_if 0, RA_E, pred0
        | --
        | std       5, BASE, RA_E, RESULT_E, pred0
        | pipe_dispatch_if 0, ctpr3, pred0
        | --
        | ct        ctpr1                   // vmeta_unm(TODO)
        | --
        break;

    case BC_LEN:
        | // ins_AD RA_E = dst*8, RD_E = src*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 4, RD_E, pred2
        | ldd       5, BASE, RD_E, RD
        | disp      ctpr1, >2
        | --
        | pipe_scale 0, 1, 2, 3
        | disp      ctpr2, ->vmeta_len
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_use 5, RD, pred2
        | wait_load RD, 2
        | --
        | sard      3, RD, 0x2f, ITYPE
        | getfd     4, RD, (47 << 6), RD
        | --
        | ldwsm     0, RD, STR->len, T2
        | cmpesb    3, ITYPE, LJ_TSTR, pred0
        | cmpedb    4, ITYPE, LJ_TTAB, pred1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, ~p1, p4
        | pass      p4, pred2
        | wait_pred_ct pred2, 0
        | --
        | ct        ctpr2, pred2            // vmeta_len(TODO)
        | --
        | pipe_bypass_some 0, RA_E
        | wait_load T2, 1 + LATENCY_PRED_CT + 1
        | --
        | istofd    3, T2, RESULT_E
        | ct        ctpr1, ~pred0           // >2
        | --
        | wait      RESULT_E, 1, 4
        | --
        | std       5, BASE, RA_E, RESULT_E
        | pipe_dispatch 0, ctpr3
        | --
        |2:
#if LJ_52
        | disp      ctpr1, >4
        | ldd       3, RD, TAB->metatable, RB
        | wait_load RB, 0
        | --
        | cmpedb    3, RB, 0x0, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, ~pred0           // >4
        |3:
#endif
        |->BC_LEN_Z:
        | // RD = GCtab *t
        | disp      ctpr1, extern lj_tab_len
        | --
        | setwd_call
        | --
        | addd      5, RD, 0x0, CARG1
        | --
        | call      ctpr1, wbs = 0x8        // lj_tab_len(GCtab *t)
        | --
        | // Length of table returned.
        | ldb       0, PC, PREV_PC_RA, T4   // TODO: reuse RA_E/S0
        | istofd    1, CRET1, T3
        | disp      ctpr1, ->vm_restart_pipeline // TODO: inline
        | wait_load T4, 0
        | --
        | shld      3, T4, 0x3, T4
        | --
        | std       5, BASE, T4, T3
        | ct        ctpr1                   // vm_restart_pipeline
        | --
#if LJ_52
        |4: // Check for __len.
        | ldb       3, RB, TAB->nomm, T5
        | disp      ctpr1, <3
        | wait_load T5, 0
        | --
        | cmpandedb 0, T5, 1<<MM_len, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, ~pred0           // <3
        | --
        | ct        ctpr2                   // vmeta_len(TODO), 'no __len' flag NOT set: check.
        | --
#endif
        break;

    /* -- Binary ops -------------------------------------------------------- */

    |.macro ins_arith_opt, ins, ch, latency
    || vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    || switch (vk) {
    ||  case 0:
    | pipe_dispatch_prep 0, ctpr3
    | pipe_dispatch_load 2
    | pipe_bypass_check 1, RB_E, pred3
    | ldd       3, KBASE, RC_E, T1
    | ldd       5, BASE, RB_E, T0
    | disp      ctpr1, ->vmeta_arith_vn
    | --
    | pipe_extract 0, 1, 2, 3, 4
    | pipe_bypass_some 5, RA_E
    | --
    | pipe_scale 0, 1, 2, 4
    | pipe_bypass_use 5, T0, pred3
    | wait_load T0, 2
    | --
    | pipe_fetch 0
    | ins       ch, T0, T1, RESULT_E
    |.if ch == 3
    | sard      4, T0, 0x2f, T3
    |.else
    | sard      3, T0, 0x2f, T3
    |.endif
    | --
    | cmpbsb    3, T3, LJ_TISNUM, pred0
    | wait_pred_ct pred0, 0
    | wait      RESULT_E, 1, latency
    | --
    ||   break;
    ||  case 1:
    | pipe_dispatch_prep 0, ctpr3
    | pipe_dispatch_load 2
    | pipe_bypass_check 1, RB_E, pred3
    | ldd       3, KBASE, RC_E, T1
    | ldd       5, BASE, RB_E, T0
    | disp      ctpr1, ->vmeta_arith_nv
    | --
    | pipe_extract 0, 1, 2, 3, 4
    | pipe_bypass_some 5, RA_E
    | --
    | pipe_scale 0, 1, 2, 4
    | pipe_bypass_use 5, T0, pred3
    | wait_load T0, 2
    | --
    | pipe_fetch 0
    | ins       ch, T1, T0, RESULT_E
    |.if ch == 3
    | sard      4, T0, 0x2f, T3
    |.else
    | sard      3, T0, 0x2f, T3
    |.endif
    | --
    | cmpbsb    3, T3, LJ_TISNUM, pred0
    | wait_pred_ct pred0, 0
    | wait      RESULT_E, 1, latency
    | --
    ||   break;
    ||  default:
    | pipe_dispatch_prep 0, ctpr3
    | pipe_dispatch_load 2
    | pipe_bypass_check 1, RC_E, pred3
    | pipe_bypass_check 4, RB_E, pred4
    | ldd       3, BASE, RC_E, T1
    | ldd       5, BASE, RB_E, T0
    | disp      ctpr1, ->vmeta_arith_vv
    | --
    | pipe_extract 0, 1, 2, 3, 4
    | pipe_bypass_some 5, RA_E
    | --
    | pipe_scale 0, 1, 2, 4
    | pipe_bypass_use 3, T1, pred3
    | pipe_bypass_use 5, T0, pred4
    | wait_load T0, 2
    | --
    | pipe_fetch 0
    | ins       ch, T0, T1, RESULT_E
    |.if ch == 3
    | sard      4, T0, 0x2f, T3
    |.else
    | sard      3, T0, 0x2f, T3
    |.endif
    |.if ch == 4
    | sard      5, T1, 0x2f, T4
    |.else
    | sard      4, T1, 0x2f, T4
    |.endif
    | --
    | cmpbsb    3, T3, LJ_TISNUM, pred0
    | cmpbsb    4, T4, LJ_TISNUM, pred1
    | --
    | pass      pred0, p0
    | pass      pred1, p1
    | landp     p0, p1, p4
    | pass      p4, pred0
    | wait_pred_ct pred0, 0
    | wait      RESULT_E, 2, latency
    | --
    ||  break;
    || }
    | std       5, BASE, RA_E, RESULT_E, pred0
    | pipe_dispatch_if 0, ctpr3, pred0          // next insn
    | --
    | ct        ctpr1                           // vmeta_arith_*
    | --
    |.endmacro

    case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
        | // ins_ABC RA_E = dst*8, RB_E = src1*8, RC_E = src2*8 or num_const*8
        | ins_arith_opt faddd, 4, 4
        break;

    case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
        | // ins_ABC RA_E = dst*8, RB_E = src1*8, RC_E = src2*8 or num_const*8
        | ins_arith_opt fsubd, 4, 4
        break;

    case BC_MULVN: case BC_MULNV: case BC_MULVV:
        | // ins_ABC RA_E = dst*8, RB_E = src1*8, RC_E = src2*8 or num_const*8
        | ins_arith_opt fmuld, 4, 4
        break;

    case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
        | // ins_ABC RA_E = dst*8, RB_E = src1*8, RC_E = src2*8 or num_const*8
        | ins_arith_opt fdivd, 5, 14 // FIXME: latency depends on inputs
        break;

    case BC_MODVN: case BC_MODNV: case BC_MODVV:
        | // ins_ABC RA_E = dst*8, RB_E = src1*8, RC_E = src2*8 or num_const*8
        switch (op) {
        case BC_MODVN:
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_bypass_check 1, RB_E, pred2
        | ldd       3, BASE, RB_E, PARG1
        | ldd       5, KBASE, RC_E, PARG2
        | disp      ctpr1, ->vmeta_arith_vn
        | --
        | pipe_dispatch_load 0
        | pipe_scale 1, 2, 3, 4
        | disp      ctpr2, ->vm_mod_fast
        | --
        | pipe_bypass_use 3, PARG1, pred2
        | wait_load PARG1, 2
        | --
        | sard      3, PARG1, 0x2f, T0
        | fdivdsm   5, PARG1, PARG2, PARG3  // Used in vm_mod_fast.
        | --
        | cmpbsb    3, T0, LJ_TISNUM, pred0
        | wait_pred_ct pred0, 0
        | --
          break;
        case BC_MODNV:
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_bypass_check 1, RB_E, pred2
        | ldd       3, KBASE, RC_E, PARG1
        | ldd       5, BASE, RB_E, PARG2
        | disp      ctpr1, ->vmeta_arith_nv
        | --
        | pipe_dispatch_load 0
        | pipe_scale 1, 2, 3, 4
        | disp      ctpr2, ->vm_mod_fast
        | --
        | pipe_bypass_use 5, PARG2, pred2
        | wait_load PARG1, 2
        | --
        | sard      3, PARG2, 0x2f, T0
        | fdivdsm   5, PARG1, PARG2, PARG3  // Used in vm_mod_fast.
        | --
        | cmpbsb    3, T0, LJ_TISNUM, pred0
        | wait_pred_ct pred0, 0
        | --
          break;
        case BC_MODVV:
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_bypass_check 1, RB_E, pred2
        | pipe_bypass_check 4, RC_E, pred3
        | ldd       3, BASE, RB_E, PARG1
        | ldd       5, BASE, RC_E, PARG2
        | disp      ctpr1, ->vmeta_arith_vv
        | --
        | pipe_dispatch_load 0
        | pipe_scale 1, 2, 3, 4
        | disp      ctpr2, ->vm_mod_fast
        | --
        | pipe_bypass_use 3, PARG1, pred2
        | pipe_bypass_use 5, PARG2, pred3
        | wait_load PARG1, 2
        | --
        | sard      3, PARG1, 0x2f, T0
        | sard      4, PARG2, 0x2f, T1
        | fdivdsm   5, PARG1, PARG2, PARG3  // Used in vm_mod_fast.
        | --
        | cmpbsb    3, T0, LJ_TISNUM, pred0
        | cmpbsb    4, T1, LJ_TISNUM, pred1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     p0, p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
          break;
        default:
          break;
        }
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_none 5
        | ct        ctpr1, ~pred0           // vmeta_arith_*
        | --
        | pipe_bypass_some 5, RA_E
        | disp      ctpr1, >1               // return for vm_mod_fast
        | wait      PARG3, 3 + LATENCY_PRED_CT, 16
        | ct        ctpr2                   // vm_mod_fast(f64, f64, f64, ctpr1)
        | --
        |1:
        | addd      3, PARG1, 0, RESULT_E
        | std       5, BASE, RA_E, PARG1
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_POW:
        | // ins_ABC RA_E = dst*8, RB_E = src1*8, RC_E = src2*8 or num_const*8
        | pipe_bypass_check 0, RB_E, pred2
        | pipe_bypass_check 1, RC_E, pred3
        | ldd       3, BASE, RB_E, PARG1
        | ldd       5, BASE, RC_E, PARG2
        | disp      ctpr2, ->vmeta_arith_vv
        | --
        | pipe_fetch 0
        | pipe_dispatch_load 2
        | pipe_scale 1, 3, 4, 5
        | disp      ctpr1, extern pow
        | --
        | pipe_bypass_use 3, PARG1, pred2
        | pipe_bypass_use 4, PARG2, pred3
        | wait_load PARG1, 2
        | --
        | sard      3, PARG1, 0x2f, T3
        | sard      4, PARG2, 0x2f, T4
        | --
        | cmpbsb    3, T3, LJ_TISNUM, pred0
        | cmpbsb    4, T4, LJ_TISNUM, pred1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     p0, p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_none 5
        | ct        ctpr2, ~pred0           // vmeta_arith_vv
        | --
        | pipe_call ctpr1
        | --
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_some 1, RA_E
        | wait      ctpr3, 0, 9
        | --
        | addd      3, PARG1, 0, RESULT_E
        | std       5, BASE, RA_E, PARG1
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_CAT:
        | // ins_ABC // RA_E = dst*8, RB_E = src_start*8, RC_E = src_end*8
        | setwd_call
        | addd      0, RA_E, 0, RA          // TODO: remove me
        | addd      1, RB_E, 0, RB          // TODO: remove me
        | addd      3, RC_E, 0, RC          // TODO: remove me
        | --
        | ldd       0, STACK, SAVE_L, CARG1
        | addd      3, BASE, RC, CARG2
        | addd      4, RC, 0x0, CARG3
        | --
        | subd      3, CARG3, RB, CARG3
        | wait_load CARG3, 1
        | --
        | shrd      0, CARG3, 0x3, CARG3
        | std       2, CARG1, L->base, BASE
        | --
        |->BC_CAT_Z:
        | // (lua_State *L, TValue *top, int left)
        | disp      ctpr1, extern lj_meta_cat
        | --
        | std       2, STACK, SAVE_PC, PC
        | addd      3, CARG1, 0x0, RB
        | --
        | call      ctpr1, wbs = 0x8        // lj_meta_cat(lua_State *L, TValue *top, int left)
        | --
        | // NULL (finished) or TValue * (metamethod) returned.
        | ldb       3, PC, PREV_PC_RB, T2
        | ldb       5, PC, PREV_PC_RA, T3
        | disp      ctpr1, ->vmeta_binop
        | --
        | disp      ctpr2, ->vm_restart_pipeline
        | wait_load T2, 1
        | --
        | cmpedb    0, CRET1, 0x0, pred0
        | ldd       3, RB, L->base, BASE
        | shld      4, T2, 0x3, T2
        | shld      5, T3, 0x3, T3
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, ~pred0           // vmeta_binop(TODO)
        | --
        | ldd       5, BASE, T2, T4
        | wait_load T4, 1
        | --
        | std       5, BASE, T3, T4         // Copy result to Stk[RA] from Stk[RB].
        | ct        ctpr2                   // vm_restart_pipeline
        | --
        break;

    /* -- Constant ops ------------------------------------------------------ */

    case BC_KSTR:
        | // ins_AND RA_E = dst*8, RD_E = str_const*8 (~)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | subd      4, KBASE, RD_E, T0
        | --
        | pipe_scale 0, 1, 2, 3
        | addd      4, 0x0, LJ_TSTR, T1
        | ldd       5, T0, -8, T0
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | shld      5, T1, 0x2f, T1
        | wait_load T0, 1
        | --
        | pipe_bypass_some 0, RA_E
        | ord       5, T0, T1, RESULT_E
        | --
        | std       5, BASE, RA_E, RESULT_E
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_KCDATA:
        |.if FFI
        | // ins_AND RA_E = dst*8, RD_E = cdata_const*8 (~)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | addd      4, 0x0, LJ_TCDATA, ITYPE
        | subd      5, KBASE, RD_E, T1
        | --
        | pipe_scale 0, 1, 2, 3
        | shld      4, ITYPE, 0x2f, ITYPE
        | ldd       5, T1, -8, T1
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_some 5, RA_E
        | wait_load T1, 1
        | --
        | ord       5, T1, ITYPE, RESULT_E
        | --
        | std       5, BASE, RA_E, RESULT_E
        | pipe_dispatch 0, ctpr3
        | --
        |.endif
        break;

    case BC_KSHORT:
        | // ins_AD RA = dst*8, RD = int16_literal*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_some 4, RA_E
        | shrd 5, RD_E, 0x3, RESULT_E
        | --
        | pipe_scale 0, 1, 2, 3
        | sxt 4, 1, RESULT_E, RESULT_E      // Sign-extend literal.
        | --
        | pipe_extract 0, 1, 2, 4, 5
        | idtofd 3, RESULT_E, RESULT_E
        | wait RESULT_E, 0, 3
        | --
        | std 5, BASE, RA_E, RESULT_E
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_KNUM:
        | // ins_AD RA_E = dst*8, RD_E = num_const*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_some 1, RA_E
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | ldd       5, KBASE, RD_E, RESULT_E
        | --
        | pipe_scale 0, 1, 2, 3
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load RESULT_E, 2
        | --
        | std       5, BASE, RA_E, RESULT_E
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_KPRI:
        | // ins_AD RA_E = dst*8, RD_E = primitive_type*8 (~)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_some 1, RA_E
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | shld      5, RD_E, 0x2c, RESULT_E
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | xord      5, RESULT_E, -1, RESULT_E
        | --
        | pipe_scale 1, 2, 3, 4
        | std       5, BASE, RA_E, RESULT_E
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_KNIL:
        | // ins_AD RA_E = dst_start*8, RD_E = dst_end*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | addd      4, BASE, RA_E, RA
        | addd      5, BASE, RD_E, RD
        | disp      ctpr1, >1
        | --
        | pipe_scale 0, 1, 2, 3
        | addd      4, 0x0, LJ_TNIL, RB
        | addd      5, RA, 0x8, RA
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | std       5, RA, -8, RB           // Sets minimum 2 slots
        | --
        |1:
        | addd      3, RA, 0x8, RA
        | std       5, RA, 0x0, RB
        | --
        | cmpbedb   3, RA, RD, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, pred0            // <1
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    /* -- Upvalue and function ops ------------------------------------------ */

    case BC_UGET:
        | // ins_AD RA_E = dst*8, RD_E = upvalue*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_some 1, RA_E
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | addd      4, RA_E, 0x0, T4
        | ldd       5, BASE, -16, RB
        | wait_load RB, 0
        | --
        | pipe_scale 0, 1, 2, 3
        | getfd     4, RB, (47 << 6), RB
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | addd      5, RB, RD_E, T1
        | --
        | ldd       3, T1, offsetof(GCfuncL, uvptr), RESULT_E
        | wait_load RESULT_E, 0
        | --
        | ldd       3, RESULT_E, UPVAL->v, T1
        | wait_load T1, 0
        | --
        | ldd       3, T1, 0x0, RESULT_E
        | wait_load RESULT_E, 0
        | --
        | std       5, BASE, T4, RESULT_E
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_USETV:
#define TV2MARKOFS \
 ((int32_t)offsetof(GCupval, marked)-(int32_t)offsetof(GCupval, tv))
        | // ins_AD RA_E = upvalue*8, RD_E = src*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | ldd       5, BASE, -16, RB
        | --
        | pipe_scale 0, 1, 2, 3
        | ldd       5, BASE, RD_E, T5
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load RB, 2
        | --
        | getfd     3, RB, (47 << 6), RB
        | --
        | addd      4, RB, RA_E, T2
        | --
        | ldd       3, T2, offsetof(GCfuncL, uvptr), T6
        | wait_load T6, 0
        | --
        | ldb       3, T6, UPVAL->closed, T2
        | ldd       5, T6, UPVAL->v, T6
        | wait_load T2, 0
        | --
        | ldbsm     3, T6, TV2MARKOFS, T1
        | cmpedb    4, T2, 0x0, pred0
        | wait_load T1, 0
        | --
        | cmpandedbsm 3, T1, LJ_GC_BLACK, pred1
        | std       5, T6, 0x0, T5
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, ~p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
        | sard      3, T5, 0x2f, T4
        | getfd     4, T5, (47 << 6), T5
        | pipe_dispatch_if 0, ctpr3, ~pred0 // isblack(uv)?
        | --
        | ldbsm     3, T5, GCOBJ->gch.marked, T3
        | subs      4, T4, LJ_TISGCV, T4
        | disp      ctpr1, extern lj_gc_barrieruv
        | --
        | wait_load T3, 2
        | --
        | cmpbesb   3, T4, LJ_TNUMX - LJ_TISGCV, pred0
        | cmpandedbsm 4, T3, LJ_GC_WHITES, pred1
        | --
        | pass      pred0, p0               // tvisgcv(v)
        | pass      pred1, p1               // iswhite(v)
        | landp     ~p0, ~p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
        | pipe_dispatch_if 0, ctpr3, ~pred0
        | --
        | setwd_call
        | --
        | // Crossed a write barrier. Move the barrier forward.
        | addd      0, DISPATCH, GG_DISP2G, CARG1
        | addd      1, T6, 0x0, CARG2
        | call      ctpr1, wbs = 0x8        // lj_gc_barrieruv(global_State *g, TValue *tv)
        | --
        | disp      ctpr1, ->vm_restart_pipeline    // TODO: inline/optimize
        | --
        | ct        ctpr1                   // vm_restart_pipeline
        | --
        break;
#undef TV2MARKOFS

    case BC_USETS:
        | // ins_AND RA_E = upvalue*8, RD_E = str_const*8 (~)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_dispatch_load 2
        | subd      4, KBASE, RD_E, T2
        | ldd       5, BASE, -16, T4
        | --
        | pipe_scale 0, 1, 2, 4
        | pipe_fetch 3
        | ldd       5, T2, -8, T3
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load T4, 2
        | --
        | getfd     3, T4, (47 << 6), T4
        | addd      4, 0x0, LJ_TSTR, ITYPE
        | --
        | addd      3, T4, RA_E, T1
        | shld      4, ITYPE, 0x2f, ITYPE
        | --
        | ldd       3, T1, offsetof(GCfuncL, uvptr), T4
        | ord       4, ITYPE, T3, ITYPE
        | wait_load T4, 0
        | --
        | ldd       3, T4, UPVAL->v, T5
        | ldb       5, T4, UPVAL->marked, T6
        | wait_load T5, 0
        | --
        | cmpandedb 3, T6, LJ_GC_BLACK, pred0
        | std       5, T5, 0x0, ITYPE
        | wait_pred_ct pred0, 0
        | --
        |1: // FIXME: unused label?
        | pipe_dispatch_if 0, ctpr3, pred0  // isblack(uv)?
        | --
        |// Check if string is white and ensure upvalue is closed.
        | ldb       3, T3, GCOBJ->gch.marked, T3
        | ldbsm     5, T4, UPVAL->closed, T6
        | --
        | disp      ctpr1, extern lj_gc_barrieruv
        | wait_load T3, 1
        | --
        | cmpandedb 3, T3, LJ_GC_WHITES, pred0
        | cmpedbsm  4, T6, 0x0, pred1
        | --
        | pass      pred0, p0               // iswhite(str)?
        | pass      pred1, p1
        | landp     ~p0, ~p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
        | pipe_dispatch_if 0, ctpr3, ~pred0
        | --
        | setwd_call
        | --
        | // Crossed a write barrier. Move the barrier forward.
        | addd      0, DISPATCH, GG_DISP2G, CARG1
        | addd      1, T5, 0x0, CARG2
        | call      ctpr1, wbs = 0x8        // lj_gc_barrieruv(global_State *g, TValue *tv)
        | --
        | disp      ctpr1, ->vm_restart_pipeline    // TODO: inline/optimize
        | --
        | ct        ctpr1                   // vm_restart_pipeline
        | --
        break;

    case BC_USETN:
        | // ins_AD RA_E = upvalue*8, RD_E = num_const*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_dispatch_load 2
        | ldd       3, BASE, -16, T2
        | ldd       5, KBASE, RD_E, T1
        | --
        | pipe_scale 0, 1, 2, 3
        | pipe_fetch 5
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load T2, 2
        | --
        | getfd     3, T2, (47 << 6), T2
        | --
        | addd      3, T2, RA_E, T3
        | --
        | ldd       3, T3, offsetof(GCfuncL, uvptr), T2
        | wait_load T2, 0
        | --
        | ldd       3, T2, UPVAL->v, T3
        | wait_load T3, 0
        | --
        | std       5, T3, 0x0, T1          // Safe here because UGETS do not read at first bundle.
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_USETP:
        | // ins_AD RA_E = upvalue*8, RD_E = primitive_type*8 (~)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | ldd       5, BASE, -16, T1
        | --
        | pipe_scale 0, 1, 2, 3
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load T1, 2
        | --
        | getfd     3, T1, (47 << 6), T1
        | --
        | addd      3, T1, RA_E, T2
        | --
        | ldd       3, T2, offsetof(GCfuncL, uvptr), T1
        | shld      4, RD_E, 0x2c, T3
        | wait_load T1, 0
        | --
        | ldd       3, T1, UPVAL->v, T2
        | xord      4, T3, -1, T3
        | wait_load T2, 0
        | --
        | std       5, T2, 0x0, T3          // Safe here because UGETS do not read at first bundle.
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_UCLO:
        | // ins_AD RA_E = level*8, RD_E = target*8
        | setwd_call
        | subd      0, PC, BCBIAS_J*4, PC
        | addd      1, RA_E, 0, T0
        | ldd       2, STACK, SAVE_L, RB
        | shrd      3, RD_E, 1, RD          // RD*4
        | disp      ctpr2, ->vm_restart_pipeline    // TODO: inline
        | --
        | addd      0, BASE, T0, CARG2
        | disp      ctpr1, extern lj_func_closeuv // (lua_State *L, TValue *level)
        | wait_load RB, 1
        | --
        | ldd       0, RB, L->openupval, CARG3
        | addd      1, RB, 0x0, CARG1
        | std       2, RB, L->base, BASE
        | addd      3, PC, RD, PC
        | wait_load CARG3, 0
        | --
        | cmpedb    0, CARG3, 0x0, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr2, pred0            // vm_restart_pipeline
        | --
        | call      ctpr1, wbs = 0x8        // lj_func_closeuv(lua_State *L, TValue *level)
        | --
        | ldd       0, RB, L->base, BASE
        | disp      ctpr2, ->vm_restart_pipeline    // TODO: inline
        | --
        | ct        ctpr2                   // vm_restart_pipeline
        | --
        break;

    case BC_FNEW:
        | // ins_AND RA_E = dst*8, RD_E = proto_const*8 (~) (holding function prototype)
        | setwd_call
        | ldd       0, STACK, SAVE_L, RB
        | addd      1, RA_E, 0, RA
        | subd      3, KBASE, RD_E, S0
        | disp      ctpr1, extern lj_func_newL_gc
        | --
        | ldd       0, BASE, -16, CARG3
        | ldd       5, S0, -8, CARG2        // Fetch GCproto *.
        | wait_load RB, 1
        | --
        | addd      0, RB, 0x0, CARG1
        | std       2, RB, L->base, BASE
        | std       5, STACK, SAVE_PC, PC
        | --
        | getfd     1, CARG3, (47 << 6), CARG3
        | call      ctpr1, wbs = 0x8        // lj_func_newL_gc(lua_State *L, GCproto *pt, GCfuncL *parent)
        | --
        | // GCfuncL * returned.
        | addd      0, 0, LJ_TFUNC, ITYPE
        | ldd       5, RB, L->base, BASE
        | disp      ctpr1, ->vm_restart_pipeline    // TODO: inline
        | --
        | shld      0, ITYPE, 0x2f, ITYPE
        | --
        | ord       0, CRET1, ITYPE, CRET1
        | --
        | std       2, BASE, RA, CRET1
        | ct        ctpr1                   // vm_restart_pipeline
        | --
        break;

    /* -- Table ops --------------------------------------------------------- */

    case BC_TNEW:
        | // ins_AD RA_E = dst*8, RD_E = (hbits|asize)*8
        | setwd_call
        | addd      1, RA_E, 0, RA
        | addd      4, RD_E, 0, RD
        | ldd       3, STACK, SAVE_L, RB
        | ldd       0, DISPATCH, DISPATCH_GL(gc.total), T4
        | ldd       2, DISPATCH, DISPATCH_GL(gc.threshold), T5
        | disp      ctpr2, >1
        | --
        | disp      ctpr1, extern lj_gc_step_fixtop // FIXME: invalid bundle if joined with next bundle
        | wait_load T4, 1
        | --
        | cmpbdb    0, T4, T5, pred0
        | std       2, STACK, SAVE_PC, PC
        | addd      3, RB, 0x0, CARG1
        | std       5, RB, L->base, BASE
        | wait_pred_ct pred0, 0
        | --
        | shrd      3, RD, 0x3, RD, pred0
        | ct        ctpr2, pred0            // >1
        | --
        | call      ctpr1, wbs = 0x8        // lj_gc_step_fixtop(lua_State *L)
        | --
        | ldh       3, PC, PREV_PC_RD, RD
        | wait_load RD, 0
        |1:
        | shrd      3, RD, 0xb, CARG3
        | andd      4, RD, 0x7ff, CARG2
        | addd      5, RB, 0x0, CARG1
        | disp      ctpr1, extern lj_tab_new
        | --
        | cmpedb    3, CARG2, 0x7ff, pred0
        | wait_pred pred0, 0
        | --
        | addd      3, 0x0, 0x801, CARG2, pred0 // Turn 0x7ff into 0x801.
        | --
        | call      ctpr1, wbs = 0x8        // lj_tab_new(lua_State *L, int32_t asize, uint32_t hbits)
        | --
        | // Table * returned.
        | addd      0, 0, LJ_TTAB, ITYPE
        | ldd       3, RB, L->base, BASE
        | disp      ctpr3, ->vm_restart_pipeline    // TODO: inline
        | --
        | shld      0, ITYPE, 0x2f, ITYPE
        | --
        | ord       1, CRET1, ITYPE, CRET1
        | wait_load BASE, 2
        | --
        | std       5, BASE, RA, CRET1
        | ct        ctpr3                   // vm_restart_pipeline
        | --
        break;

    case BC_TDUP:
        | // ins_AND RA_E = dst*8, RD_E = table_const*8 (~)
        | setwd_call
        | ldd       0, DISPATCH, DISPATCH_GL(gc.total), T3
        | addd      1, RA_E, 0, RA
        | ldd       2, DISPATCH, DISPATCH_GL(gc.threshold), T4
        | ldd       3, STACK, SAVE_L, RB
        | addd      4, RD_E, 0, RD
        | --
        | disp      ctpr1, extern lj_gc_step_fixtop
        | wait_load T3, 1
        | --
        | cmpbdb    0, T3, T4, pred0
        | std       2, STACK, SAVE_PC, PC
        | addd      3, RB, 0x0, CARG1
        | std       5, RB, L->base, BASE
        | wait_pred_ct pred0, 0
        | --
        | call      ctpr1, wbs = 0x8, ~pred0 // lj_gc_step_fixtop(lua_State *L)
        | --
        | subd      3, KBASE, RD, T3
        | addd      4, RB, 0x0, CARG1
        | disp      ctpr1, extern lj_tab_dup
        | --
        | ldd       3, T3, -8, CARG2
        | wait_load CARG2, 0
        | --
        | call      ctpr1, wbs = 0x8        // lj_tab_dup(lua_State *L, Table *kt)
        | --
        | ldd       3, RB, L->base, BASE
        | addd      4, 0, LJ_TTAB, ITYPE
        | disp      ctpr3, ->vm_restart_pipeline // TODO: inline
        | --
        | shld      4, ITYPE, 0x2f, ITYPE
        | --
        | ord       3, CRET1, ITYPE, CRET1
        | wait_load BASE, 2
        | --
        | std       5, BASE, RA, CRET1
        | ct        ctpr3                   // vm_restart_pipeline
        | --
        break;

    case BC_GGET:
        | // ins_AND RA_E = dst*8, RD_E = str_const*8 (~)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | addd      1, 0x0, LJ_TSTR, T1
        | subd      4, KBASE, RD_E, S0
        | ldd       5, BASE, -16, RB
        | disp      ctpr1, >1
        | --
        | pipe_scale 0, 1, 2, 3
        | shld      4, T1, 0x2f, T1
        | ldd       5, S0, -8, RC
        | disp      ctpr2, >2
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load RB, 0
        | --
        | pipe_bypass_none 0
        | getfd     4, RB, (47 << 6), RB
        | --
        | ldd       3, RB, LFUNC->env, RB
        | wait_load RB, 0
        | --
        | ldw       3, RB, TAB->hmask, S0   // RB = GCtab *, RC = GCstr *
        | ldw       5, RC, STR->hash, S1
        | --
        | ldd       3, RB, TAB->node, T2
        | wait_load S0, 1
        | --
        | andd      4, S0, S1, S1           // idx = str->hash & tab->hmask
        | --
        | shld      3, S1, 0x5, S0
        | shld      4, S1, 0x3, S1
        | --
        | subd      3, S0, S1, S1
        | --
        | addd      3, T2, S1, S0           // node = tab->node + (idx*32-idx*8)
        | ord       4, RC, T1, ITYPE
        | --
        | ldd       3, S0, NODE->key, S1
        | lddsm     5, S0, NODE->next, T5
        | wait_load S1, 0
        |1:
        | cmpedbsm  3, T5, 0x0, pred2
        | cmpedb 4, S1, ITYPE, pred3
        | lddsm     5, S0, NODE->val, T4    // Get node value.
        | --
        | pass pred3, p0
        | pass pred2, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred4
        | landp ~p0, p1, p5
        | pass p5, pred2
        | wait_load T4, 1
        | --
        | addd      3, T5, 0x0, S0, ~pred3  // Follow hash chain.
        | addd      4, T4, 0x0, ITYPE, pred3
        | --
        | ldd 3, S0, NODE->key, S1, pred4
        | cmpedbsm 4, ITYPE, LJ_TNIL, pred1
        | lddsm     5, S0, NODE->next, T5, pred4
        | wait_pred_ct pred4, 0
        | --
        | ct        ctpr1, pred4            // <1
        | --
        | addd 3, 0x0, LJ_TNIL, ITYPE, pred2 // End of hash chain: key not found, nil result.
        | ct        ctpr2, pred2            // >2
        | --
        | pipe_bypass_some_if 0, RA_E, ~pred1
        | addd      3, ITYPE, 0, RESULT_E, ~pred1
        | --
        | std       5, BASE, RA_E, ITYPE, ~pred1
        | pipe_dispatch_if 0, ctpr3, ~pred1
        | --
        |2:
        | disp      ctpr1, ->vmeta_tgets
        | ldd 3, RB, TAB->metatable, S0     //  Check for __index if table value is nil
        | wait_load S0, 0
        | --
        | ldbsm 3, S0, TAB->nomm, S1
        | cmpedb 4, S0, 0x0, pred0
        | wait_load S1, 0
        | --
        | cmpandedbsm 4, S1, 1<<MM_index, pred1
        | --
        | pass pred0, p0                    // No metatable: done
        | pass pred1, p1                    // 'no __index' flag set: done.
        | landp ~p0, p1, p4
        | pass p4, pred0
        | wait_pred pred0, 0
        | --
        | pipe_bypass_some_if 0, RA_E, ~pred0
        | addd      3, ITYPE, 0, RESULT_E, ~pred0
        | --
        | std       5, BASE, RA_E, ITYPE, ~pred0
        | pipe_dispatch_if 0, ctpr3, ~pred0
        | --
        | ct        ctpr1                   // vmeta_tgets(TODO)
        | --
        break;

    case BC_GSET:
        | // ins_AND RA_E = src*8, RD_E = str_const*8 (~)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | addd      1, RA_E, 0, RA
        | subd      4, KBASE, RD_E, T0
        | ldd       5, BASE, -16, RB
        | disp      ctpr1, ->BC_TSETS_Z
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load RB, 1
        | --
        | pipe_scale 0, 1, 2, 4
        | getfd     5, RB, (47 << 6), RB
        | --
        | pipe_bypass_none 0
        | ldd       3, RB, LFUNC->env, RB
        | ldd       5, T0, -8, RC
        | wait_load RB, 0
        | wait_load RC, 0
        | ct        ctpr1                   // BC_TSETS_Z(RA, RB, RC)
        | --
        break;

    case BC_TGETV:
        | // ins_ABC RA_E = dst*8, RB_E = table*8, RC_E = key*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_bypass_check 1, RB_E, pred2
        | pipe_bypass_check 4, RC_E, pred3
        | ldd       3, BASE, RB_E, RB
        | ldd       5, BASE, RC_E, RC
        | disp      ctpr1, ->vmeta_tgetv
        | --
        | pipe_scale 0, 1, 2, 3
        | pipe_dispatch_load 5
        | disp      ctpr2, >2
        | --
        | pipe_bypass_none 0
        | pipe_bypass_use 3, RB, pred2
        | pipe_bypass_use 5, RC, pred3
        | wait_load RC, 2
        | --
        | pipe_extract 0, 1, 2, 4, 5
        | fdtoistr  3, RC, S0
        | --
        | sard      3, RB, 0x2f, T1
        | sard      4, RC, 0x2f, ITYPE
        | getfd     5, RB, (47 << 6), RB
        | wait      S0, 1, 4                // fp domain
        | --
        | istofd    3, S0, S1
        | cmpesb    4, T1, LJ_TTAB, pred0
        | wait      S1, 0, 4                // fp domain
        | --
        | cmpbsb    1, ITYPE, LJ_TISNUM, pred1
        | ldwsm     3, RB, TAB->asize, T2
        | fcmpeqdb  4, RC, S1, pred2        // Convert number to int and back and compare.
        | ldd       5, RB, TAB->array, T5
        | --
        | ct        ctpr1, ~pred0           // vmeta_tgetv(TODO)
        | wait_pred_ct pred1, 1
        | --
        | ct        ctpr2, ~pred1           // >2, Integer key?
        | --
        | sxt       3, 0x2, S0, RC, pred2
        | ct        ctpr1, ~pred2           // vmeta_tgetv(TODO), Generic numeric key? Use fallback.
        | --
        | cmpbsb    3, RC, T2, pred0
        | shld      4, RC, 0x3, S1
        | wait_pred_ct pred0, 0
        | --
        | addd      3, S1, T5, RC, pred0
        | ct        ctpr1, ~pred0           // vmeta_tgetv(TODO)
        | --
        | ldd       3, RC, 0x0, ITYPE
        | wait_load ITYPE, 0
        | --
        | cmpedb    3, ITYPE, LJ_TNIL, pred0
        | wait_pred pred0, 0
        | --
        | pipe_bypass_some_if 0, RA_E, ~pred0
        | addd      3, ITYPE, 0, RESULT_E, ~pred0
        | ldd       5, RB, TAB->metatable, S0, pred0
        | --
        | std       5, BASE, RA_E, ITYPE, ~pred0
        | pipe_dispatch_if 0, ctpr3, ~pred0
        | --
        | wait_load S0, 1
        | --
        | // Check for __index if table value is nil.
        | cmpedb    3, S0, 0x0, pred0
        | ldbsm     5, S0, TAB->nomm, S0
        | wait_load S0, 0
        | --
        | cmpandedbsm 0, S0, 1<<MM_index, pred1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, p1, p4
        | pass      p4, pred0
        | wait_pred pred0, 0
        | --
        | pipe_bypass_some_if 0, RA_E, ~pred0
        | addd      3, ITYPE, 0, RESULT_E, ~pred0
        | --
        | std       5, BASE, RA_E, ITYPE, ~pred0
        | pipe_dispatch_if 0, ctpr3, ~pred0
        | --
        | ct        ctpr1                   // vmeta_tgetv(TODO), 'no __index' flag NOT set: check.
        | --
        |2: // String key?
        | cmpesb    3, ITYPE, LJ_TSTR, pred0
        | addd      4, 0x0, LJ_TSTR, T1
        | disp      ctpr2, ->BC_TGETS_Z
        | wait_pred pred0, 0
        | --
        | ldd       3, RB, TAB->node, T2
        | getfd     4, RC, (47 << 6), RC, pred0
        | --
        | ldw       3, RB, TAB->hmask, S0, pred0    // RB = GCtab *, RC = GCstr *
        | shld      4, T1, 0x2f, T1
        | ldw       5, RC, STR->hash, S1, pred0
        | ct        ctpr1, ~pred0           // vmeta_tgetv(TODO)
        | --
        | wait_load S0, 1
        | wait_load S1, 1
        | --
        | andd      4, S0, S1, S1           // idx = str->hash & tab->hmask
        | ct        ctpr2                   // BC_TGETS_Z(S1, RA_E, RC, T1, T2)
        | --
        break;

    case BC_TGETS:
        | // ins_ABC RA_E = dst*8, RB_E = table*8, RC_E = str_const*8 (~)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 1, RB_E, pred2
        | subd      4, KBASE, RC_E, RC
        | ldd       5, BASE, RB_E, RB       // GCtab *
        | disp      ctpr1, ->vmeta_tgets
        | --
        | pipe_scale 0, 1, 2, 3
        | ldd       5, RC, -8, RC           // GCstr *
        | --
        | pipe_bypass_none 0
        | pipe_bypass_use 5, RB, pred2
        | wait_load RB, 2
        | --
        | addd      0, 0x0, LJ_TSTR, T1
        | sard      4, RB, 47, ITYPE
        | getfd     5, RB, 47 << 6, RB
        | --
        | shld      0, T1, 47, T1
        | ldwsm     3, RB, TAB->hmask, S0
        | cmpesb    4, ITYPE, LJ_TTAB, pred0
        | ldwsm     5, RC, STR->hash, S1
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | lddsm     5, RB, TAB->node, T2
        | wait_pred_ct pred0, 1
        | wait_load S0, 1
        | --
        | andd      4, S0, S1, S1, pred0    // idx = str->hash & tab->hmask
        | ct        ctpr1, ~pred0           // vmeta_tgets(RB, RC)
        | --
        |->BC_TGETS_Z:
        | // (S1, RA_E, RC, T2, T1)
        | // S1 = idx = (str->hash & tab->hmask)
        | // RA_E = dst*8
        | // RC = GCstr *
        | // T2 = MRef *node
        | // T1 = LJ_TSTR << 47
        | // TODO: convert to standard calling convention
        | shld      3, S1, 0x5, S0
        | shld      4, S1, 0x3, S1
        | disp      ctpr1, <1
        | --
        | subd      3, S0, S1, S1           // idx*32 - idx*8 = idx * #NODE (24)
        | disp      ctpr2, >2
        | --
        | addd      3, T2, S1, S0           // node = tab->node + idx * #NODE
        | ord       4, RC, T1, ITYPE
        | --
        | ldd       3, S0, NODE->key, S1
        | lddsm     5, S0, NODE->next, T5
        | --
        |1:
        | lddsm     3, S0, NODE->val, T4    // Get node value.
        | wait_load S1, 1
        | --
        | cmpedbsm  3, T5, 0x0, pred2
        | cmpedb    4, S1, ITYPE, pred3
        | --
        | pass      pred3, p0
        | pass      pred2, p1
        | landp     ~p0, ~p1, p4
        | landp     ~p0, p1, p5
        | pass      p4, pred4
        | pass      p5, pred2
        | --
        | addd      3, T5, 0x0, S0, ~pred3  // Follow hash chain.
        | addd      4, T4, 0x0, ITYPE, pred3
        | wait_pred_ct pred4, 1
        | --
        | ldd       3, S0, NODE->key, S1, pred4
        | cmpedbsm  4, ITYPE, LJ_TNIL, pred1
        | lddsm     5, S0, NODE->next, T5, pred4
        | ct        ctpr1, pred4            // <1
        | --
        | addd      3, 0x0, LJ_TNIL, ITYPE, pred2 // End of hash chain: key not found, nil result.
        | ct        ctpr2, pred2            // >2
        | wait_pred pred1, 1
        | --
        | pipe_bypass_some_if 0, RA_E, ~pred1
        | addd      5, ITYPE, 0, RESULT_E, ~pred1
        | --
        | std       5, BASE, RA_E, ITYPE, ~pred1
        | pipe_dispatch_if 0, ctpr3, ~pred1
        | --
        |2:
        | disp      ctpr1, ->vmeta_tgets
        | ldd       3, RB, TAB->metatable, S0   //  Check for __index if table value is nil
        | wait_load S0, 0
        | --
        | ldbsm     3, S0, TAB->nomm, S1
        | cmpedb    4, S0, 0x0, pred0
        | wait_load S1, 0
        | --
        | cmpandedbsm 4, S1, 1<<MM_index, pred1
        | --
        | pass      pred0, p0               // No metatable: done
        | pass      pred1, p1               // 'no __index' flag set: done.
        | landp     ~p0, p1, p4
        | pass      p4, pred0
        | wait_pred pred0, 0
        | --
        | pipe_bypass_some_if 0, RA_E, ~pred0
        | addd      5, ITYPE, 0, RESULT_E, ~pred0
        | --
        | std       5, BASE, RA_E, ITYPE, ~pred0
        | pipe_dispatch_if 0, ctpr3, ~pred0
        | --
        | ct        ctpr1                   // vmeta_tgets(RB, RC)
        | --
        break;

    case BC_TGETB:
        | // ins_ABC RA_E = dst*8, RB_E = table*8, RC_E = index*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 4, RB_E, pred2
        | ldd       5, BASE, RB_E, RB
        | disp      ctpr1, ->vmeta_tgetb
        | --
        | pipe_scale 0, 1, 2, 3
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_bypass_use 5, RB, pred2
        | wait_load RB, 2
        | --
        | sard      3, RB, 0x2f, ITYPE
        | getfd     4, RB, (47 << 6), RB
        | --
        | ldwsm     3, RB, TAB->asize, T1
        | lddsm     5, RB, TAB->array, T3
        | --
        | lddsm     3, RB, TAB->metatable, T4
        | sard      4, RC_E, 0x3, T2
        | wait_load T1, 1
        | --
        | cmpesb    3, ITYPE, LJ_TTAB, pred0
        | cmpbdbsm  4, T2, T1, pred1
        | --
        | ldbsm     0, T4, TAB->nomm, T5
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     p0, p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
        | addd      3, RC_E, T3, RC_E, pred0
        | ct        ctpr1, ~pred0           // vmeta_tgetb(TODO)
        | --
        | // Get array slot.
        | ldd       3, RC_E, 0x0, ITYPE
        | --
        | cmpedbsm  0, T4, 0x0, pred1       // Check for __index if table value is nil.
        | cmpedb    3, ITYPE, LJ_TNIL, pred0
        | cmpandedbsm 4, T5, 1<<MM_index, pred2
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | pass      pred2, p2
        | landp     p0, ~p1, p4
        | landp     p4, p2, p5
        | pass      p5, pred0
        | wait_pred pred0, 0
        | --
        | pipe_bypass_some_if 0, RA_E, ~pred0
        | addd      5, ITYPE, 0, RESULT_E, ~pred0
        | --
        | std       5, BASE, RA_E, ITYPE, ~pred0
        | pipe_dispatch_if 0, ctpr3, ~pred0
        | --
        | ct        ctpr1                   // vmeta_tgetb, 'no __index' flag NOT set: check.
        | --
        break;

    case BC_TGETR:
        | // ins_ABC RA_E = dst*8, RB_E = table*8, RC_E = key*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_bypass_check 1, RB_E, pred2
        | pipe_bypass_check 4, RC_E, pred3
        | ldd       3, BASE, RB_E, RB
        | ldd       5, BASE, RC_E, RC
        | disp      ctpr1, ->vmeta_tgetr
        | --
        | pipe_dispatch_load 5
        | --
        | pipe_bypass_none 0
        | pipe_bypass_use 3, RB, pred2
        | pipe_bypass_use 5, RC, pred3
        | wait_load RC, 2
        | --
        | getfd     3, RB, (47 << 6), RB
        | fdtoistr  4, RC, RC
        | --
        | ldw       3, RB, TAB->asize, T1
        | lddsm     5, RB, TAB->array, T2
        | wait_load T1, 0
        | wait      RC, 1, 4 + 2            // fp->int cross domain penalty
        | --
        | cmpbsb    3, RC, T1, pred0
        | shls      4, RC, 0x3, T3
        | addd      5, RA_E, 0, RA
        | --
        | pipe_scale 0, 1, 2, 3
        | sxt       5, 0x2, T3, T3
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | addd      5, T2, T3, T3
        | --
        | ldd       3, T3, 0x0, RESULT_E, pred0 // Get array slot.
        | ct        ctpr1, ~pred0           // vmeta_tgetr(RA, RB, RC), Not in array part? Use fallback.
        | --
        | pipe_bypass_some 0, RA_E
        | wait_load RESULT_E, 1
        | --
        | std       5, BASE, RA_E, RESULT_E
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_TSETV:
        | // ins_ABC RA_E = src*8, RB_E = table*8, RC_E = key*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_dispatch_load 2
        | pipe_bypass_check 1, RB_E, pred2
        | pipe_bypass_check 4, RC_E, pred3
        | ldd       3, BASE, RB_E, RB
        | ldd       5, BASE, RC_E, RC
        | disp      ctpr1, ->vmeta_tsetv
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | pipe_fetch 5
        | disp      ctpr2, ->BC_TSETS_Z
        | --
        | pipe_scale 0, 1, 2, 3
        | pipe_bypass_use 4, RB, pred2
        | pipe_bypass_use 5, RC, pred3
        | wait_load RB, 2
        | --
        | pipe_bypass_none 0
        | sard      3, RB, 0x2f, T1
        | fdtoistr  4, RC, S0
        | getfd     5, RB, (47 << 6), RB
        | wait      S0, 0, 4
        | --
        | cmpesb    3, T1, LJ_TTAB, pred0
        | istofd    4, S0, S1
        | sard      5, RC, 0x2f, ITYPE
        | wait      S1, 0, 4
        | --
        | fcmpeqdb  3, RC, S1, pred2        // Integer key?  Convert number to int and back and compare.
        | cmpbsb    4, ITYPE, LJ_TISNUM, pred1
        | ldwsm     5, RB, TAB->asize, T2
        | --
        | lddsm     3, RB, TAB->array, T3
        | cmpesb    4, ITYPE, LJ_TSTR, pred3
        | lddsm     5, RB, TAB->metatable, S1
        | wait      pred2, 1, 3
        | --
        | addd      1, RA_E, 0, RA
        | pass      pred0, p0
        | pass      pred2, p1
        | pass      pred3, p2
        | landp     p0, p1, p4
        | landp     p4, p2, p5
        | pass      p5, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, ~pred0           // vmeta_tsetv
        | --
        | getfd     3, RC, (47 << 6), RC, ~pred1
        | sxt       4, 0x2, S0, RC, pred2
        | ldbsm     5, RB, TAB->marked, T1
        | ct        ctpr2, ~pred1           // BC_TSETS_Z(RA, RB, RC), String key?
        | --
        | cmpbsb    3, RC, T2, pred0
        | shld      4, RC, 0x3, RC
        | ldbsm     5, S1, TAB->nomm, T4
        | wait_pred_ct pred0, 0
        | --
        | cmpedbsm  3, S1, 0x0, pred1
        | cmpandedbsm 4, T4, 1<<MM_newindex, pred2 // 'no __newindex' flag NOT set: check.
        | addd      5, RC, T3, RC, pred0
        | ct        ctpr1, ~pred0           // vmeta_tsetv
        | --
        | ldw       3, RC, 0x0, S0
        | lddsm     5, BASE, RA, T0
        | wait_load S0, 0
        | --
        | cmpesb    4, S0, LJ_TNIL, pred0   // Previous value is nil?
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | pass      pred2, p2
        | landp     p0, ~p1, p4
        | landp     p4, p2, p5
        | pass      p5, pred0
        | wait_pred_ct pred0, 0
        | --
        | cmpandedbsm 3, T1, LJ_GC_BLACK, pred1 // isblack(table)
        | ct        ctpr1, pred0            // vmeta_tsetv
        | --
        | wait_pred_ct pred1, 1
        | --
        | std       5, RC, 0x0, T0, pred1   // Set array slot
        | pipe_dispatch_if 0, ctpr3, pred1
        | --
        | // Possible table write barrier for the value. Skip valiswhite check.
        | ldd       0, DISPATCH, DISPATCH_GL(gc.grayagain), S1
        | ldb       3, RB, TAB->marked, S0
        | wait_load S0, 0
        | --
        | std       2, DISPATCH, DISPATCH_GL(gc.grayagain), RB
        | andd      3, S0, ~LJ_GC_BLACK, S0 // black2gray(tab)
        | std       5, RB, TAB->gclist, S1
        | --
        | std       2, RC, 0x0, T0, pred1   // Set array slot
        | stb       5, RB, TAB->marked, S0
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_TSETS:
        | // ins_ABC  RA_E = src*8, RB_E = table*8, RC_E = str_const*8 (~)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 1, RB_E, pred2
        | subd      4, KBASE, RC_E, S0
        | ldd       5, BASE, RB_E, RB
        | disp      ctpr2, ->vmeta_tsets
        | --
        | pipe_scale 0, 1, 2, 4
        | ldd       3, S0, -8, RC
        | addd      5, RA_E, 0, RA
        | --
        | pipe_bypass_none 0
        | pipe_bypass_use 5, RB, pred2
        | wait_load RB, 2
        | --
        | sard      3, RB, 0x2f, ITYPE
        | getfd     4, RB, (47 << 6), RB
        | --
        | pipe_extract 0, 1, 2, 3, 5
        | cmpesb    4, ITYPE, LJ_TTAB, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr2, ~pred0           // vmeta_tsets(RA, RB, RC)
        | --
        |->BC_TSETS_Z:
        | // RA = src*8, RB = GCtab *, RC = GCstr *
        | ldw       3, RB, TAB->hmask, S0
        | addd      4, 0x0, LJ_TSTR, ITYPE
        | ldw       5, RC, STR->hash, S1
        | disp      ctpr2, >1
        | --
        | shld      4, ITYPE, 0x2f, ITYPE
        | ldd       5, RB, TAB->node, T2
        | disp      ctpr1, >2
        | wait_load S0, 1
        | --
        | andd      3, S0, S1, S1           // idx = str->hash & tab->hmask
        | ord       4, ITYPE, RC, ITYPE
        | addd      2, 0x0, 0x0, T1
        | --
        | lddsm     0, DISPATCH, DISPATCH_GL(gc.grayagain), T7
        | stb       2, RB, TAB->nomm, T1    // Clear metamethod cache.
        | smulx     4, S1, #NODE, S0
        | lddsm     5, RB, TAB->metatable, T3
        | wait_load T3, 0
        | --
        | ldbsm     5, T3, TAB->nomm, T4
        | wait      S0, LATENCY_LOAD, 4 + 2 // fp->int cross domain transfer
        | --
        | addd      3, T2, S0, S0
        | --
        | ldd       3, S0, NODE->key, S1
        | lddsm     5, S0, NODE->next, T1
        | wait_load T1, 0
        | --
        |1:
        | cmpedb 3, S1, ITYPE, pred0
        | cmpedbsm  4, T1, 0x0, pred1
        | --
        | ldbsm     3, RB, TAB->marked, T2
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, ~p1, p4
        | landp     ~p0, p1, p5
        | pass      p4, pred2
        | pass      p5, pred3
        | wait_pred pred2, 0
        | --
        | ldd       3, T1, NODE->key, S1, pred2
        | addd      4, T1, 0x0, S0, pred2
        | ldd       5, S0, 0x0, S1, ~pred2
        | --
        | lddsm     5, S0, NODE->next, T1, pred2
        | ct        ctpr2, pred2            // <1
        | wait_load T1, 0
        | --
        | cmpedb    3, S1, LJ_TNIL, pred0
        | cmpedb    4, T3, 0x0, pred1
        | anddsm    5, T2, ~LJ_GC_BLACK, T2 // black2gray(tab)
        | disp      ctpr2, ->vmeta_tsets
        | ct        ctpr1, pred3            // >2
        | --
        | cmpandedbsm 3, T4, 1<<MM_newindex, pred2
        | ldbsm     5, RB, TAB->marked, S1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | pass      pred2, p2
        | landp     p0, ~p1, p4
        | landp     p4, p2, p5
        | pass      p5, pred0
        | wait_pred_ct pred0, 0
        | wait_load S1, 1
        | --
        |// Possible table write barrier for the value. Skip valiswhite check.
        | cmpandedb 3, S1, LJ_GC_BLACK, pred1
        | ct        ctpr1, pred0            // vmeta_tsets(TODO), 'no __newindex' flag NOT set: check.
        | --
        | ldd       0, BASE, RA, ITYPE
        | addd      5, RB, 0x0, S1
        | --
        | std       5, DISPATCH, DISPATCH_GL(gc.grayagain), S1, ~pred1
        | --
        | stb       2, S1, TAB->marked, T2, ~pred1
        | std       5, S1, TAB->gclist, T7, ~pred1
        | --
        | std       5, S0, 0x0, ITYPE       // Set node value.
        | pipe_dispatch 0, ctpr3
        | --
        |2:
        | setwd_call
        | --
        | // End of hash chain: key not found, add a new one.
        | // But check for __newindex first.
        | ldd       0, STACK, SAVE_L, CARG1
        | addd      1, DISPATCH, DISPATCH_GL(tmptv), CARG3
        | ldd       3, RB, TAB->metatable, S0
        | --
        | disp      ctpr1, extern lj_tab_newkey
        | wait_load S0, 1
        | --
        | addd      0, RB, 0x0, CARG2
        | ldbsm     3, S0, TAB->nomm, S1
        | cmpedb    4, S0, 0x0, pred0
        | wait_load S1, 0
        | --
        | cmpandedbsm 0, S1, 1<<MM_newindex, pred1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr2, pred0            // vmeta_tsets(TODO), 'no __newindex' flag NOT set: check.
        | std       2, CARG1, L->base, BASE
        | --
        | std       2, CARG3, 0x0, ITYPE
        | std       5, STACK, SAVE_PC, PC
        | call      ctpr1, wbs = 0x8        // lj_tab_newkey(lua_State *L, GCtab *t, TValue *k)
        | --
        | // Handles write barrier for the new key. TValue * returned.
        | ldd       0, STACK, SAVE_L, S1
        | addd      1, CRET1, 0x0, S0
        | ldb       5, PC, PREV_PC_RA, RA
        | wait_load S1, 0
        | --
        | ldbsm     0, RB, TAB->marked, T2
        | ldd       3, S1, L->base, BASE
        | ldb       5, RB, TAB->marked, T1  // Must check write barrier for value.
        | wait_load RA, 1
        | --
        | ldd       0, DISPATCH, DISPATCH_GL(gc.grayagain), T3
        | shld      3, RA, 0x3, RA
        | --
        | ldd       3, BASE, RA, ITYPE
        | cmpandedb 4, T1, LJ_GC_BLACK, pred0
        | wait_pred pred0, 0
        | --
        | andd      1, T2, ~LJ_GC_BLACK, T2 // black2gray(tab)
        | std       2, DISPATCH, DISPATCH_GL(gc.grayagain), RB, ~pred0
        | disp      ctpr1, ->vm_restart_pipeline    // TODO: inline or do not clear pipeline state
        | --
        | std       2, RB, TAB->gclist, T3, ~pred0
        | stb       5, RB, TAB->marked, T2, ~pred0
        | --
        | std       5, S0, 0x0, ITYPE
        | ct        ctpr1                   // vm_restart_pipeline
        | --
        break;

    case BC_TSETB:
        | // ins_ABC RA_E = src*8, RB_E = table*8, RC_E = byte_literal*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | pipe_bypass_check 1, RB_E, pred2
        | addd      4, RC_E, 0, RC
        | ldd       5, BASE, RB_E, RB
        | disp      ctpr1, ->vmeta_tsetb
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | --
        | pipe_bypass_none 0
        | pipe_bypass_use 5, RB, pred2
        | wait_load RB, 2
        | --
        | pipe_scale 0, 1, 2, 3
        | sard      4, RB, 0x2f, ITYPE
        | getfd     5, RB, (47 << 6), RB
        | --
        | ldwsm     3, RB, TAB->asize, S1
        | cmpesb    4, ITYPE, LJ_TTAB, pred0
        | lddsm     5, RB, TAB->array, S0
        | --
        | lddsm     3, RB, TAB->metatable, T2
        | ldbsm     5, RB, TAB->marked, T4
        | wait_pred_ct pred0, 1
        | --
        | shld      3, S1, 0x3, S1, pred0
        | ct        ctpr1, ~pred0           // vmeta_tsetb(TODO)
        | --
        | cmpbdb    3, RC, S1, pred0
        | wait_pred_ct pred0, 0
        | --
        | cmpedbsm  3, T2, 0x0, pred1
        | addd      4, RC, S0, RC, pred0
        | ldbsm     5, T2, TAB->nomm, T3
        | ct        ctpr1, ~pred0           // vmeta_tsetb(TODO)
        | --
        | ldd       3, RC, 0x0, S0
        | cmpandedbsm 4, T4, LJ_GC_BLACK, pred3
        | --
        | cmpedb    3, S0, LJ_TNIL, pred0   // Previous value is nil?
        | cmpandedbsm 4, T3, 1<<MM_newindex, pred2 // 'no __newindex' flag NOT set: check.
        | lddsm     5, BASE, RA_E, ITYPE
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | pass      pred2, p2
        | landp     p0, ~p1, p4
        | landp     p4, p2, p5
        | pass      p5, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, pred0            // vmeta_tsetb(TODO)
        | --
        | std       5, RC, 0x0, ITYPE, pred3
        | pipe_dispatch_if 0, ctpr3, pred3
        | --
        | // Possible table write barrier for the value. Skip valiswhite check.
        | ldd       3, DISPATCH, DISPATCH_GL(gc.grayagain), T0
        | ldb       5, RB, TAB->marked, T1
        | wait_load T0, 0
        | --
        | std       2, DISPATCH, DISPATCH_GL(gc.grayagain), RB
        | andd      3, T1, ~LJ_GC_BLACK, T1 // black2gray(tab)
        | std       5, RB, TAB->gclist, T0
        | --
        | std       2, RC, 0x0, ITYPE
        | stb       5, RB, TAB->marked, T1
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_TSETR:
        | // ins_ABC RA_E = src*8, RB_E = table*8, RC_E = key*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_bypass_check 1, RB_E, pred2
        | pipe_bypass_check 4, RC_E, pred3
        | ldd       3, BASE, RB_E, RB
        | ldd       5, BASE, RC_E, RC
        | disp      ctpr1, ->vmeta_tsetr
        | --
        | pipe_scale 0, 1, 2, 4
        | pipe_dispatch_load 3
        | ldd       5, DISPATCH, DISPATCH_GL(gc.grayagain), T3
        | --
        | pipe_bypass_none 0
        | pipe_bypass_use 3, RB, pred2
        | pipe_bypass_use 5, RC, pred3
        | wait_load RB, 2
        | --
        | getfd     3, RB, (47 << 6), RB
        | fdtoistr  4, RC, RC
        | lddsm     5, RB, TAB->array, T5
        | --
        | addd      0, RA_E, 0, RA
        | ldb       3, RB, TAB->marked, T1
        | ldbsm     5, RB, TAB->marked, T2
        | wait_load T1, 0
        | --
        | cmpandedb 3, T1, LJ_GC_BLACK, pred0
        | anddsm    4, T2, ~LJ_GC_BLACK, T2 // black2gray(tab)
        | ldwsm     5, RB, TAB->asize, T4
        | --
        | std       2, DISPATCH, DISPATCH_GL(gc.grayagain), RB, ~pred0
        | stb       5, RB, TAB->marked, T2, ~pred0
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | shls      5, RC, 0x3, T1
        | wait_load T4, 2
        | --
        | ldd       3, BASE, RA_E, ITYPE
        | cmpbsbsm  4, RC, T4, pred1
        | std       5, RB, TAB->gclist, T3, ~pred0
        | wait_pred_ct pred1, 0
        | --
        | sxt       3, 0x2, T1, T1
        | ct        ctpr1, ~pred1           // vmeta_tsetr(TODO)
        | --
        | std       5, T5, T1, ITYPE
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_TSETM:
        | // ins_AD RA_E = base*8 (table at base-1), RD_E = num_const*8 (start_index)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | addd      4, BASE, RA_E, RA
        | ldd       5, DISPATCH, DISPATCH_GL(gc.grayagain), T3
        | disp      ctpr2, >4
        | --
        | ldw       2, STACK, MULTRES, RD
        | ldw       3, KBASE, RD_E, T5      // Integer constant is in lo-word.
        | ldd       5, RA, -8, RB           // Guaranteed to be a table.
        | disp      ctpr1, >2
        | --
        | pipe_scale 0, 1, 2, 4
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load RB, 2
        | --
        | pipe_bypass_none 0
        | subd      2, RD, 0x8, RD
        | shld      3, T5, 0x3, T5
        | getfd     4, RB, (47 << 6), RB
        | --
        | ldb       3, RB, TAB->marked, T1
        | ldbsm     5, RB, TAB->marked, T2
        | --
        | ldwsm     3, RB, TAB->asize, T4
        | lddsm     5, RB, TAB->array, T6
        | wait_load T1, 1
        | --
        | cmpandedb 3, T1, LJ_GC_BLACK, pred0
        | cmpedb    4, RD, 0x0, pred1
        | andd      5, T2, ~LJ_GC_BLACK, T2 // black2gray(tab)
        | wait_pred pred0, 0
        | --
        | std       2, DISPATCH, DISPATCH_GL(gc.grayagain), RB, ~pred0
        | addd      3, RD, T5, RD           // Compute needed size.
        | shldsm    4, T4, 0x3, T4
        | stb       5, RB, TAB->marked, T2, ~pred0
        | --
        | cmpbedbsm 3, RD, T4, pred2
        | std       5, RB, TAB->gclist, T3, ~pred0
        | pipe_dispatch_if 0, ctpr3, pred1  // Nothing to copy?
        | --
        | wait_pred_ct pred2, 1
        | --
        | subd      3, RD, T5, RD, pred2
        | addd      4, T5, T6, T5, pred2
        | ct        ctpr2, ~pred2           // >4, Doesn't fit into array part?
        | --
        |2: // Copy result slots to table.
        | ldd       3, RA, 0x0, RB
        | addd      4, RA, 0x8, RA
        | subd      5, RD, 0x8, RD
        | --
        | cmpedb    3, RD, 0x0, pred0
        | wait_pred_ct pred0, 0
        | wait_load RB, 1
        | --
        | addd      4, T5, 0x8, T5
        | std       5, T5, 0x0, RB
        | ct        ctpr1, ~pred0           // <2
        | --
        | pipe_dispatch 0, ctpr3
        | --
        |4: // Need to resize array part.
        | --
        | setwd_call
        | ldd       3, STACK, SAVE_L, T1
        | disp      ctpr1, extern lj_tab_reasize
        | wait_load T1, 0
        | --
        | shrd      0, RD, 3, CARG3
        | addd      1, RB, 0, CARG2
        | addd      3, T1, 0, CARG1
        | addd      4, T1, 0, RB
        | std       5, T1, L->base, BASE
        | --
        | std       2, STACK, SAVE_PC, PC
        | call      ctpr1, wbs = 0x8        // lj_tab_reasize(lua_State *L, GCtab *t, int nasize)
        | --
        | ldd       3, RB, L->base, BASE
        | disp      ctpr2, ->vm_restart_pipeline    // TODO: inline
        | --
        | subd      0, PC, 4, PC            // Retry this instruction.
        | ct        ctpr2                   // vm_restart_pipeline
        | --
        break;

    /* -- Calls and vararg handling ----------------------------------------- */

    case BC_CALL: case BC_CALLM:
        | // ins_A_C  RA_E = base*8, (RB_E = (nresults+1)*8,) RD_E = (nargs+1)*8 | extra_nargs*8
        | ldd       0, BASE, RA_E, RB
        | addd      1, RA_E, 0x10, RA
        | ldw       2, STACK, MULTRES, S0
        | andd      3, RD_E, 0x7f8, RD
        | disp      ctpr1, ->vmeta_call
        | wait_load RB, 0
        | --
        |// XXX: DO NOT USE IF INSIDE A BUNDLE!!!
        if (op == BC_CALLM) {
          | sard    0, RB, 0x2f, ITYPE
          | getfd   1, RB, (47 << 6), RB
          | addd    2, RD, S0, RD
          | disp    ctpr2, ->vm_enter_pipeline // TODO: inline
          | --
        } else {
          | sard    0, RB, 0x2f, ITYPE
          | getfd   1, RB, (47 << 6), RB
          | disp    ctpr2, ->vm_enter_pipeline // TODO: inline
          | --
        }
        | lddsm     0, RB, LFUNC->pc, RARG1
        | cmpesb    1, ITYPE, LJ_TFUNC, pred0
        | addd      2, BASE, RA, T1
        | wait_pred_ct pred0, 0
        | --
        | addd      0, BASE, RA, BASE, pred0
        | addd      1, BASE, RA, RA, ~pred0
        | ct        ctpr1, ~pred0           // vmeta_call(BASE, RA, RD)
        | --
        | std       2, T1, -8, PC
        | ct        ctpr2                   // vm_enter_pipeline
        | wait_load RARG1, 2
        | --
        break;

    case BC_CALLMT:
        | // ins_AD RA_E = base*8, RD_E = extra_nargs*8
        | ldw       0, STACK, MULTRES, S0
        | wait_load S0, 0
        | --
        | addd      3, RD_E, S0, RD_E
        | --
        | // Fall through. Assumes BC_CALLT follows and ins AD is a no-op.
        break;

    case BC_CALLT:
        | // ins_AD RA_E = base*8, RD_E = (nargs+1)*8
        | addd      0, RD_E, 0, RD
        | ldd       3, BASE, RA_E, RB
        | addd      4, BASE, RA_E, RA
        | addd      5, BASE, 0x0, KBASE          // Use KBASE for move + vmeta_call hint.
        | disp      ctpr1, ->vmeta_call
        | wait_load RB, 0
        | --
        | sard      3, RB, 0x2f, ITYPE
        | addd      4, RA, 0x10, RA
        | --
        | cmpesb 3, ITYPE, LJ_TFUNC, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, ~pred0               // vmeta_call(RA, RD)
        | --
        |->BC_CALLT_Z:
        | ldd       3, BASE, -8, PC
        | disp      ctpr1, >3
        | --
        | disp      ctpr2, >2
        | wait_load PC, 1
        | --
        | stw       2, STACK, MULTRES, RD
        | cmpandedb 3, PC, FRAME_TYPE, pred0
        | subd      4, RD, 0x8, RD
        | wait_pred pred0, 0
        | --
        | subd      3, PC, FRAME_VARG, PC, ~pred0 // Tailcall from a vararg function.
        | cmpedb    4, RD, 0x0, pred2
        | --
        | cmpandedb 3, PC, FRAME_TYPEP, pred1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, ~p1, p4
        | landp     ~p0, p1, p5
        | pass      p4, pred0               // Vararg frame below?
        | pass      p5, pred1
        | wait_pred pred1, 0
        | --
        | subd      3, BASE, PC, BASE, pred1    // Need to relocate BASE/KBASE down.
        | subd      4, BASE, PC, KBASE, pred1
        | --
        | ldd       3, BASE, -8, PC, pred1
        | addd      4, PC, FRAME_VARG, PC, pred0
        | --
        | std       5, BASE, -16, RB        // Copy func+tag down, reloaded below.
        | ct        ctpr1, pred2            // >3
        | --
        |2: // Move args down.
        | ldd       3, RA, 0x0, RB
        | addd      4, RA, 0x8, RA
        | subd      5, RD, 0x8, RD
        | --
        | cmpedb    3, RD, 0x0, pred0
        | wait_pred_ct pred0, 0
        | --
        | addd      4, KBASE, 0x8, KBASE
        | std       5, KBASE, 0x0, RB
        | ct        ctpr2, ~pred0           // <2
        | --
        | ldd       3, BASE, -16, RB
        | wait_load RB, 0
        |3:
        | cmpandedb 1, PC, FRAME_TYPE, pred1
        | ldbsm     2, PC, PREV_PC_RA, T1
        | getfd     3, RB, (47 << 6), RB
        | disp      ctpr1, >4
        | --
        | ldw       0, STACK, MULTRES, RD
        | ldb       3, RB, LFUNC->ffid, S0
        | ldd       5, RB, LFUNC->pc, RARG1
        | wait_load S0, 0
        | --
        | cmpbedb   3, S0, 0x1, pred0       // (> FF_C) Calling a fast function?
        | shldsm    4, T1, 0x3, T1
        | --
        | subdsm    3, BASE, T1, T2
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, p1, p4
        | pass      p4, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, pred0            // >4
        | --
        | disp      ctpr2, ->vm_enter_pipeline  // TODO: inline
        | --
        | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, [BASE-8] = PC
        | ct        ctpr2                   // vm_enter_pipeline(RARG1)
        | --
        |4: // Tailcall to a fast function.
        | ldd       3, T2, -32, KBASE    // Need to prepare KBASE.
        | disp      ctpr2, ->vm_enter_pipeline  // TODO: inline
        | wait_load KBASE, 0
        | --
        | getfd     3, KBASE, (47 << 6), KBASE
        | --
        | ldd       3, KBASE, LFUNC->pc, KBASE
        | wait_load KBASE, 0
        | --
        | ldd       3, KBASE, PC2PROTO(k), KBASE
        | ct        ctpr2                   // vm_enter_pipeline(RARG1)
        | --
        break;

    case BC_ITERC:
        | // ins_A RA_E = base*8, RB_E = (nresults+1)*8, RD_E=(nargs+1)*8 (2+1)*8
        | addd      4, BASE, RA_E, RA       // fb = base+2
        | addd      5, 0x0, 0x18, RD        // Handle like a regular 2-arg call.
        | disp      ctpr1, ->vmeta_call
        | --
        | addd      5, RA, 0x10, RA
        | disp      ctpr2, ->vm_enter_pipeline // TODO: inline
        | --
        | ldd       3, RA, -32, RB          // Copy state. fb[0] = fb[-4].
        | ldd       5, RA, -24, RC          // Copy control var. fb[1] = fb[-3].
        | --
        | ldd       3, RA, -40, T1          // Copy callable. fb[-2] = fb[-5]
        | wait_load RB, 1
        | --
        | std       5, RA, 0x0, RB
        | --
        | std       5, RA, 0x8, RC
        | --
        | sard      3, T1, 0x2f, ITYPE
        | getfd     4, T1, (47 << 6), T1
        | std       5, RA, -16, T1
        | --
        | lddsm     3, T1, LFUNC->pc, RARG1
        | cmpesb    4, ITYPE, LJ_TFUNC, pred0
        | wait_pred_ct pred0, 0
        | --
        | addd      4, RA, 0x0, BASE, pred0
        | ct        ctpr1, ~pred0           // vmeta_call(RA, RD)
        | --
        | std       5, BASE, -8, PC
        | ct        ctpr2                   // vm_enter_pipeline(RARG1, RD, RB)
        | --
        break;

    case BC_ITERN:
        | // ins_A RA = base*8, (RB = (nresults+1)*8, RC = (nargs+1)*8 (2+1)*8)
        | addd      0, RA_E, 0, RA
        | addd      2, PC, 0x4, PC
        | addd      3, BASE, RA_E, S0
        | disp      ctpr1, >3
        | --
        | ldd       3, S0, -16, RB
        | ldw       5, S0, -8, RC           // Get index from control var.
        | disp      ctpr2, >1
        | wait_load RB, 0
        | --
        | getfd     3, RB, (47 << 6), RB
        | disp      ctpr3, >2
        | --
        | ldw       3, RB, TAB->asize, S1
        | sxt       4, 6, RC, T4
        | ldd       5, RB, TAB->array, ITYPE
        | --
        | shls      3, T4, 0x3, T4
        | wait_load ITYPE, 1
        | --
        |1: // Traverse array part.
        | lddsm     3, ITYPE, T4, S0
        | cmpbsb    4, RC, S1, pred0
        | wait_load S0, 0
        | --
        | subs      3, RC, S1, RC, ~pred0
        | cmpedbsm  4, S0, LJ_TNIL, pred1
        | ct        ctpr1, ~pred0           // >3, Index points after array part?
        | --
        | wait_pred_ct pred1, 1
        | --
        | adds      3, RC, 0x1, RC, pred1   // Skip holes in array part.
        | addd      4, T4, 0x8, T4, pred1
        | ct        ctpr2, pred1            // <1
        | --
        | // Copy array slot to returned value.
        | // Return array index as a numeric key
        | subd      1, PC, BCBIAS_J*4, PC
        | ldh       2, PC, PREV_PC_RD, RD   // Get target from ITERL.
        | addd      3, S0, 0x0, RB
        | istofd    4, RC, S1
        | addd      5, BASE, RA, S0         // FIXME: duplicated
        | --
        | adds      4, RC, 0x1, RC
        | std       5, S0, 0x8, RB
        | wait_load RD, 1
        | --
        | shld      0, RD, 0x2, RD
        | std       5, S0, 0x0, S1
        | --
        | addd      0, PC, RD, PC
        | stw       2, S0, -8, RC           // Update control var.
        |2:
        | disp      ctpr1, ->vm_restart_pipeline
        | --
        | ct        ctpr1                   // vm_restart_pipeline(PC)
        | --
        |3: // Traverse hash part.
        | ldw       3, RB, TAB->hmask, S0
        | smulx     4, RC, #NODE, ITYPE
        | lddsm     5, RB, TAB->node, T1
        | wait_load S0, 0
        | --
        | cmpbesb   3, RC, S0, pred0
        | wait_pred_ct pred0, 0
        | --
        | adddsm    3, ITYPE, T1, ITYPE
        | // TODO: pipe_dispatch
        | ct        ctpr3, ~pred0           // <2, End of iteration? Branch to ITERL+1.
        | --
        | ldd       3, ITYPE, NODE->val, T3
        | lddsm     5, ITYPE, NODE->key, T2
        | wait_load T3, 0
        | --
        | cmpedb    3, T3, LJ_TNIL, pred0
        | wait_pred_ct pred0, 0
        | --
        | adds      3, RC, 0x1, RC, pred0   // Skip holes in hash part.
        | ct        ctpr1, pred0            // <3
        | --
        | // Copy key and value from hash slot.
        | ldh       0, PC, PREV_PC_RD, RD   // Get target from ITERL.
        | subd      1, PC, BCBIAS_J*4, PC
        | addd      3, BASE, RA, S0         // FIXME: duplicated
        | wait_load RD, 1
        | --
        | adds      4, RC, S1, S1
        | std       5, S0, 0x0, T2
        | --
        | shld      0, RD, 0x2, RD
        | adds      4, S1, 0x1, S1
        | std       5, S0, 0x8, T3
        | --
        | addd      0, PC, RD, PC
        | stw       5, S0, -8, S1
        | ct        ctpr3                   // <2
        | --
        break;

    case BC_ISNEXT:
        | // ins_AD RA_E = base*8, RD_E = target*8 (points to ITERN)
        | addd      1, PC, 0x0, T3
        | subd      2, PC, BCBIAS_J*4, PC
        | shrd      3, RD_E, 0x1, RD
        | addd      4, BASE, RA_E, S0
        | disp      ctpr1, ->vm_restart_pipeline // TODO: inline
        | --
        | addd      1, PC, RD, PC
        | ldd       2, S0, -8, T2
        | ldd       3, S0, -24, T1
        | ldd       5, S0, -16, S1
        | wait_load T1, 0
        | --
        | getfd     3, T1, (47 << 6), RB
        | sard      4, T1, 0x2f, ITYPE
        | sard      5, S1, 0x2f, S1
        | --
        | cmpedb    0, T2, LJ_TNIL, pred2
        | cmpesb    3, ITYPE, LJ_TFUNC, pred0
        | cmpesb    4, S1, LJ_TTAB, pred1
        | ldbsm     5, RB, CFUNC->ffid, T6
        | wait_load T6, 0
        | --
        | cmpedbsm  3, T6, FF_next_N, pred3
        | pass      pred0, p0
        | pass      pred1, p1
        | pass      pred2, p2
        | landp     p0, p1, p4
        | landp     p4, p2, p5
        | pass      p5, pred0
        | --
        | addd      0, 0x0, BC_ITERC, T5
        | addd      3, 0x0, U64x(0xfffe7fff,0x00000000), S1
        | pass      pred0, p0
        | pass      pred3, p1
        | landp     p0, p1, p4
        | pass      p4, pred0
        | wait_pred pred0, 0
        | --
        | // Despecialize bytecode if any of the checks fail.
        | addd      0, 0x0, BC_JMP, T4
        | stb       2, PC, 0x0, T5, ~pred0
        | std       5, S0, -8, S1, pred0    // Initialize control var.
        | --
        | stb       2, T3, PREV_PC_OP, T4, ~pred0
        | ct        ctpr1                   // vm_restart_pipeline(PC)
        | --
        break;

    case BC_VARG:
        | // ins_ABC RA_E = base*8, RB_E = (nresults+1)*8, RC_E = numparams*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | --
        | pipe_scale 0, 1, 2, 3
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | --
        | addd      0, RB_E, 0, RB          // TODO: remove me
        | addd      3, BASE, RC_E, S1
        | cmpedb    4, RB_E, 0x0, pred0
        | ldd       5, BASE, -8, S0
        | disp      ctpr1, >5
        | --
        | addd      3, S1, FRAME_VARG+0x10, S1
        | addd      4, BASE, RA_E, RA
        | addd      5, 0x0, LJ_TNIL, T4
        | disp      ctpr2, >2
        | wait_load S0, 1
        | --
        | subd      3, S1, S0, S1   // S1 may now be even _above_ BASE if nargs was < numparams.
        | addd      4, RA, RB, T3
        | --
        | subd      3, T3, 0x8, RB, ~pred0
        | cmpbdb    4, S1, BASE, pred1
        | ct        ctpr1, pred0            // >5, Copy all varargs?
        | --
        | ct        ctpr2, ~pred1           // >2, No vrarg slots?
        |1: // Copy vararg slots to destination slots.
        | ldd       3, S1, -16, RC
        | addd      4, S1, 0x8, S1
        | addd      5, RA, 0x8, T3
        | disp      ctpr1, <1
        | --
        | cmpbdb    3, T3, RB, pred0
        | cmpbdb    4, S1, BASE, pred1
        | wait_pred_ct pred0, 0
        | --
        | addd      4, T3, 0x0, RA
        | std       5, RA, 0x0, RC
        | pipe_dispatch_if 0, ctpr3, ~pred0 // All destination slots filled?
        | --
        | ct        ctpr1, pred1            // <1, No more vararg slots?
        | --
        |2: // Fill up remainder with nil.
        | addd      4, RA, 0x8, RA
        | std       5, RA, 0x0, T4
        | --
        | cmpbdb    3, RA, RB, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr2, pred0
        | --
        |5: // Copy all varargs.
        | addd      0, 0x0, (0+1)*8, S0
        | ldd       2, STACK, SAVE_L, RB
        | addd      3, BASE, 0x0, RC
        | disp      ctpr2, >6
        | --
        | stw       2, STACK, MULTRES, S0
        | cmpbedb   3, RC, S1, pred0
        | wait_load RB, 1
        | --
        | lddsm     3, RB, L->maxstack, S0
        | --
        | subd      4, RC, S1, RC
        | pipe_dispatch_if 0, ctpr3, pred0  // No vararg slots?
        | --
        | addd      3, RC, 0x8, T3
        | addd      4, RC, RA, RC
        | --
        | cmpbedb   3, RC, S0, pred0
        | stw       2, STACK, MULTRES, T3 // (#varargs+1)*8
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr2, pred0            // >6, Need to grow stack?
        | --
        | disp      ctpr1, extern lj_state_growstack
        | --
        | setwd_call
        | ldw       0, STACK, MULTRES, T2
        | --
        | std       2, STACK, SAVE_PC, PC
        | subd      3, S1, BASE, S1         // Need delta, because BASE may change.
        | std       5, RB, L->base, BASE
        | wait_load T2, 1
        | --
        | subd      0, T2, 0x8, T2
        | std       5, RB, L->top, RA
        | --
        | shrd      0, T2, 0x3, CARG2
        | addd      3, RB, 0x0, CARG1
        | call      ctpr1, wbs = 0x8        // lj_state_growstack(lua_State *L, int n)
        | --
        | ldd       3, RB, L->base, BASE
        | ldd       5, RB, L->top, RA
        | disp      ctpr2, >6
        | --
        | addd      3, S1, BASE, S1
        | --
        |6: // Copy all vararg slots.
        | ldd       3, S1, -16, RC
        | addd      4, S1, 0x8, S1
        | --
        | cmpbdb    3, S1, BASE, pred0
        | wait_pred_ct pred0, 0
        | --
        | addd      4, RA, 0x8, RA
        | std       5, RA, 0x0, RC
        | ct        ctpr2, pred0            // <6
        | --
        | disp      ctpr1, ->vm_restart_pipeline // TODO: inline
        | --
        | ct        ctpr1                   // vm_restart_pipeline
        | --
        break;

    /* -- Returns ----------------------------------------------------------- */

    case BC_RETM:
        | // ins_AD RA_E = results*8, RD_E = extra_nresults*8
        | ldw       0, STACK, MULTRES, T0
        | wait_load T0, 0
        | --
        | addd      0, RD_E, T0, RD_E       // MULTRES >=8, so RD_E >= 8
        | --
        | // Fall through. Assumes BC_RET follows and ins_AD is a no-op.
        break;

    case BC_RET:
        | // ins_AD RA_E = results*8, RD_E = (nresults+1)*8
        | addd      0, RA_E, 0, RA
        | addd      1, RD_E, 0, RD
        |1:
        | stw       2, STACK, MULTRES, RD_E // Save (nresults+1)*8.
        | ldd       5, BASE, -8, PC
        | disp      ctpr3, ->vm_return
        | wait_load PC, 0
        | --
        | cmpandedb 3, PC, FRAME_TYPE, pred0   // Check frame type marker.
        | subdsm    4, PC, FRAME_VARG, RB
        | disp      ctpr1, <1
        | --
        | cmpandedbsm 3, RB, FRAME_TYPEP, pred1
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | landp     ~p0, ~p1, p4
        | pass      p4, pred1
        | wait_pred_ct pred1, 0
        | --
        | ct        ctpr3, pred1            // vm_return(RA, RD)
        | --
        | subd      3, BASE, RB, BASE, ~pred0 // Return from vararg function: relocate BASE down and RA up.
        | addd      4, RA, RB, RA, ~pred0
        | ct        ctpr1, ~pred0           // <1
        | --
        |->BC_RET_Z:
        | // BASE = base, RA = resultptr, RD = (nresults+1)*8, PC = return
        | ldb       0, PC, PREV_PC_RB, T2
        | ldw       2, STACK, MULTRES, T1   // Note: MULTRES may be >255.
        | addd      3, BASE, 0x0, KBASE     // Use KBASE for result move.
        | subd      4, RD, 0x8, RD
        | ldb       5, PC, PREV_PC_RA, T3
        | disp ctpr1, >3
        | --
        | cmpedb    3, RD, 0x0, pred0
        | addd      4, 0x0, LJ_TNIL, T0
        | disp      ctpr2, >2
        | wait_pred_ct pred0, 0
        | --
        | shld      0, T2, 0x3, T2
        | shld      3, T3, 0x3, T3
        | ct        ctpr1, pred0            // >3
        |2:                                 // Move results down.
        | ldd       3, KBASE, RA, RB
        | subd      4, RD, 0x8, RD
        | --
        | cmpedb    3, RD, 0x0, pred0
        | wait_load RB, 1
        | --
        | addd      4, KBASE, 0x8, KBASE
        | std       5, KBASE, -16, RB
        | ct        ctpr2, ~pred0           // <2
        |3:
        | cmpbedb   0, T2, T1, pred0
        | disp      ctpr2, >4
        | wait_pred_ct pred0, 0
        | --
        | subd      3, BASE, T3, BASE, pred0
        | ct        ctpr2, ~pred0           // >4, More results expected?
        | --
        | subd      3, BASE, 0x10, BASE     // base = base - (RA+2)*8
        | disp      ctpr3, ->vm_restart_pipeline
        | --
        | ldd       3, BASE, -16, KBASE
        | wait_load KBASE, 0
        | --
        | getfd     3, KBASE, (47 << 6), KBASE
        | --
        | ldd       3, KBASE, LFUNC->pc, KBASE
        | wait_load KBASE, 0
        | --
        | ldd       5, KBASE, PC2PROTO(k), KBASE
        | ct        ctpr3                   // vm_restart_pipeline
        | --
        |4:                                 // Fill up results with nil.
        | addd      0, T1, 0x8, T1
        | addd      4, KBASE, 0x8, KBASE
        | std       5, KBASE, -16, T0       // Note: relies on shifted base.
        | ct        ctpr1                   // <3
        | --
        break;

    case BC_RET0: case BC_RET1:
        | // ins_AD RA = results*8, RD = (nresults+1)*8
        | addd      3, RA_E, 0, RA
        | addd      4, RD_E, 0, RD
        | --
        |1:
        | ldd 0, BASE, -8, PC
        | disp ctpr3, ->vm_return
        | nop 2
        | --
        | stw 2, STACK, MULTRES, RD            // Save (nresults+1)*8.
        | disp ctpr1, <1
        | --
        | cmpandedb 1, PC, FRAME_TYPE, pred0   // Check frame type marker.
        | subdsm 4, PC, FRAME_VARG, RB
        | disp ctpr2, >3
        | --
        | cmpandedbsm 3, RB, FRAME_TYPEP, pred1
        | --
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred1
        | --
        | ct        ctpr3, pred1            // vm_return(RA, RD)
        | --
        |// XXX: DO NOT USE IF INSIDE A BUNDLE!!!
        if (op == BC_RET1) {
          | subd    3, BASE, RB, BASE, ~pred0   // Return from vararg function: relocate BASE down and RA up.
          | addd    4, RA, RB, RA, ~pred0
          | ldd     5, BASE, RA, RB, pred0
          | ct      ctpr1, ~pred0           // <1
          | --
        } else {
          | subd    3, BASE, RB, BASE, ~pred0   // Return from vararg function: relocate BASE down and RA up.
          | ct      ctpr1, ~pred0           // <1
          | --
        }
        if (op == BC_RET1) {
          | std 5, BASE, -16, RB
          | --
        }
        |2:
        | ldb 0, PC, PREV_PC_RB, S0
        | ldb 3, PC, PREV_PC_RA, RA
        | disp ctpr1, <2
        | --
        | andd 4, RD, 0x7f8, S1
        | wait_load S0, 1
        | --
        | shld 0, S0, 0x3, S0
        | --
        | cmpbedb 0, S0, S1, pred0
        | wait_pred_ct pred0, 0
        | --
        | shld 3, RA, 0x3, RA, pred0
        | subd 4, BASE, 0x10, BASE, pred0
        | ct        ctpr2, ~pred0           // >3, More results expected?
        | --
        | subd 3, BASE, RA, BASE            // base = base - (RA+2)*8
        | disp   ctpr1, ->vm_restart_pipeline // TODO: inline
        | --
        | ldd 3, BASE, -16, KBASE
        | wait_load KBASE, 0
        | --
        | getfd 3, KBASE, (47 << 6), KBASE
        | --
        | ldd 3, KBASE, LFUNC->pc, KBASE
        | wait_load KBASE, 0
        | --
        | ldd 3, KBASE, PC2PROTO(k), KBASE
        | ct        ctpr1                   // vm_restart_pipeline
        |3:                                 // Fill up results with nil.
        | subd 3, BASE, 0x18, S0
        | addd 4, 0x0, LJ_TNIL, S1
        | --
        | addd 3, RD, 0x8, RD
        | std 5, S0, RD, S1
        | ct        ctpr1                   // <2
        | --
        break;

    /* -- Loops and branches ------------------------------------------------ */

    case BC_FORL:
        | // Fall through. Assumes BC_IFORL follows and ins_AJ is a no-op.
        break;

    case BC_JFORI: case BC_JFORL:
        | // Unsupported
        break;

    case BC_IFORL:
        | // ins_AJ RA_E = base*8, RD_E = target*8 (after end of loop or start of loop)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_dispatch_load 3
        | subd      1, PC, BCBIAS_J*4, T3
        | shrd      2, RD_E, 1, T2          // RD*4
        | addd      4, BASE, RA_E, RA
        | disp      ctpr1, ->vm_restart_pipeline_fast
        | --
        | pipe_fetch 2
        | ldbsm     0, T3, T2, RARG1        // Branch target insn opcode.
        | ldd       3, RA, 0x10, RB
        | ldd       5, RA, 0x0, S0
        | --
        | pipe_scale 0, 1, 2, 3
        | pipe_bypass_none 4
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load S0, 2
        | --
        | shld      0, RARG1, 3, RARG1
        | faddd     3, S0, RB, S0
        | fcmpltdb  4, RB, 0x0, pred2
        | ldd       5, RA, 0x8, S1
        | --
        | ldd       0, RARG1, DISPATCH, RARG1   // Load dispath for branch target.
        | wait_load S1, 1
        | wait      S0, 1, 4
        | --
        | fcmpltdb  3, S1, S0, pred0
        | fcmpltdb  4, S0, S1, pred1        // Invert comparison if step is negative.
        | --
        | std       2, RA, 0x0, S0
        | std       5, RA, 0x18, S0
        | wait      pred0, 1, 3
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | pass      pred2, p2
        | landp     ~p0, ~p2, p4
        | landp     ~p1, p2, p5
        | landp     ~p4, ~p5, p6
        | pass      p6, pred0
        | wait_pred pred0, 0
        | --
        | addd      0, T3, T2, PC, ~pred0   // Set PC to branch target if taken.
        | --
        | ct        ctpr1, ~pred0           // vm_restart_pipeline_fast(RARG1)
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_FORI:
        | // ins_AJ RA_E = base*8, RD_E = target*8 (after end of loop or start of loop)
        | pipe_dispatch_prep 0, ctpr3
        | pipe_dispatch_load 3
        | addd      1, BASE, RA_E, RA
        | addd      4, BASE, RA_E, T0
        | disp      ctpr2, ->vmeta_for
        | --
        | subd      0, PC, BCBIAS_J*4, T3
        | shrd      1, RD_E, 1, T4          // RD*4
        | ldd       2, RA, 0x10, RB
        | ldd       3, T0, 0x0, S0
        | ldd       5, T0, 0x8, S1
        | disp      ctpr1, ->vm_restart_pipeline_fast
        | --
        | pipe_scale 1, 2, 4, 5
        | pipe_fetch 3
        | ldb       0, T3, T4, RARG1        // Branch target insn opcode for fast restart.
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load RB, 2
        | --
        | pipe_bypass_none 0
        | sard      1, RB, 47, ITYPE
        | sard      3, S0, 47, T1
        | sard      4, S1, 47, T2
        | --
        | cmplsb    0, ITYPE, LJ_TISNUM, pred3
        | shld      2, RARG1, 3, RARG1
        | cmpbsb    1, ITYPE, LJ_TISNUM, pred0
        | cmpbsb    3, T1, LJ_TISNUM, pred1
        | cmpbsb    4, T2, LJ_TISNUM, pred2
        | --
        | ldd       0, RARG1, DISPATCH, RARG1   // Dispatch for branch target.
        | pass      pred0, p0
        | pass      pred1, p1
        | pass      pred2, p2
        | landp     p0, p1, p4
        | landp     p4, p2, p5
        | pass      p4, pred0               // FIXME: unused?
        | pass      p5, pred2
        | --
        | fcmpltdb  3, S1, S0, pred0
        | fcmpltdb  4, S0, S1, pred1        // Invert comparison if step is negative.
        | wait_pred_ct pred2, 1
        | --
        | std       5, RA, 0x18, S0, pred2
        | ct        ctpr2, ~pred2           // vmeta_for(RA)
        | --
        | pass      pred0, p0
        | pass      pred1, p1
        | pass      pred3, p3
        | landp     ~p0, ~p3, p4
        | landp     ~p1, p3, p5
        | landp     ~p4, ~p5, p6
        | pass      p6, pred0
        | wait_pred_ct pred0, 0
        | --
        | addd      0, T3, T4, PC, pred0    // Set PC to branch target if taken.
        | ct        ctpr1, pred0            // vm_restart_pipeline_fast(RARG1)
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_ITERL:
        | // Fall through. Assumes BC_IITERL follows and ins_AJ is a no-op.
        break;

    case BC_JITERL:
        | // Unsupported
        break;

    case BC_IITERL:
        | // ins_AJ RA_E = base*8, RD_E = target*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_dispatch_load 3
        | subd      1, PC, BCBIAS_J*4, T1
        | shrd      2, RD_E, 1, RD          // RD*4
        | addd      4, BASE, RA_E, RA
        | ldd       5, BASE, RA_E, RB
        | disp      ctpr1, ->vm_restart_pipeline_fast
        | --
        | pipe_scale 1, 2, 3, 4
        | pipe_fetch 5
        | ldb       0, T1, RD, RARG1        // Branch target insn opcode for fast restart.
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load RB, 2
        | --
        | pipe_bypass_none 0
        | cmpedb    3, RB, LJ_TNIL, pred0
        | --
        | shld      0, RARG1, 3, RARG1
        | wait_pred pred0, 1
        | --
        | ldd       0, RARG1, DISPATCH, RARG1   // Dispatch for branch target.
        | addd      1, T1, RD, PC, ~pred0   // Otherwise save control var + branch.
        | std       2, RA, -8, RB, ~pred0
        | wait_load RARG1, 1                // Must be ready for vm_restart_pipeline_fast.
        | --
        | ct        ctpr1, ~pred0           // vm_restart_pipeline_fast(RARG1)
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_LOOP:
        | // ins_A RA_E = base*8, RD_E = target*8 (loop extent)
        | // Note: RA/RD is only used by trace recorder to determine scope/extent
        | // This opcode does NOT jump, it's only purpose is to detect a hot loop.
        | //Fall through. Assumes BC_ILOOP follows and ins_A is a no-op.
        break;

    case BC_ILOOP:
        | // ins_A RA_E = base*8, RD_E = target*8 (loop extent)
        | pipe_next
        break;

    case BC_JLOOP:
        | // Unsupported
        break;

    case BC_JMP:
        | // ins_AJ RA_E = unused, RD_E = target*8
        | subd      0, PC, BCBIAS_J*4, PC
        | shrd      1, RD_E, 1, T0
        | disp      ctpr1, ->vm_restart_pipeline_fast
        | --
        | ldb       0, PC, T0, RARG1
        | addd      1, PC, T0, PC
        | wait_load RARG1, 0
        | --
        | shld      0, RARG1, 3, RARG1
        | --
        | ldd       0, RARG1, DISPATCH, RARG1
        | wait_load RARG1, 0                // Must be ready for vm_restart_pipeline_fast.
        | ct        ctpr1                   // vm_restart_pipeline_fast(BCOp*)
        | --
        break;

    /* -- Function headers -------------------------------------------------- */

    /*
    ** Reminder: A function may be called with func/args above L->maxstack,
    ** i.e. occupying EXTRA_STACK slots. And vmeta_call may add one extra slot,
    ** too. This means all FUNC* ops (including fast functions) must check
    ** for stack overflow _before_ adding more slots!
    */

    case BC_FUNCF:
    case BC_FUNCV: /* NYI: compiled vararg functions. */
        | // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow and ins_AD is a no-op.
        break;

    case BC_JFUNCF:
        | // Unsupported
        break;

    case BC_IFUNCF:
        | // ins_AD BASE = new_base*8, RA_E = framesize*8, RD_E = (nargs+1)*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_dispatch_load 2
        | ldd       3, PC, PC2PROTO(k)-4, KBASE
        | addd      4, BASE, RA_E, RA       // Top of frame.
        | ldd       5, STACK, SAVE_L, RB
        | disp      ctpr1, ->vm_growstack_f
        | --
        | pipe_scale 0, 1, 2, 4
        | pipe_fetch 5
        | ldbsm     3, PC, PC2PROTO(numparams)-4, T6
        | disp      ctpr2, >1
        | --
        | pipe_extract 0, 1, 2, 3, 4
        | wait_load RB, 2
        | --
        | addd      0, RD_E, 0, RD
        | ldd       3, RB, L->maxstack, S0
        | wait_load S0, 0
        | --
        | cmpbedb   3, RA, S0, pred0
        | wait_pred_ct pred0, 0
        | --
        | shld      3, T6, 0x3, RA, pred0
        | ct        ctpr1, ~pred0           // vm_growstack_f(BASE, RD, RB, PC)
        | --
        | cmpbedb   3, RD, RA, pred1        // Check for missing parameters.
        | wait_pred_ct pred1, 0
        | --
        | addd      1, 0x0, LJ_TNIL, S1, pred1
        | pipe_dispatch_if 0, ctpr3, ~pred1
        | --
        |1: // Clear missing parameters.
        | subd      3, RD, 0x8, S0
        | addd      4, RD, 0x8, RD
        | --
        | cmpbedb   3, RD, RA, pred0
        | wait_pred_ct pred0, 0
        | --
        | std       5, BASE, S0, S1
        | ct        ctpr2, pred0            // <1
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_JFUNCV:
        | // Unsupported
        break;

    case BC_IFUNCV:
        | // ins_AD
        | // BASE = new base
        | // RA_E = framesize*8
        | // RB_E = LFUNC (but we need tagged)
        | // RD_E = (nargs+1)*8
        | pipe_dispatch_prep 0, ctpr3
        | pipe_bypass_none 1
        | pipe_fetch 2
        | pipe_dispatch_load 3
        | ldd       5, BASE, -16, KBASE
        | disp      ctpr1, ->vm_growstack_v
        | --
        | pipe_scale 0, 1, 2, 3
        | addd      4, RD_E, FRAME_VARG+0x8, S0
        | addd      5, RD_E, BASE, RD
        | --
        | pipe_extract 1, 2, 3, 4, 5
        | ldbsm     0, PC, PC2PROTO(numparams)-4, T1
        | --
        | ldd       3, STACK, SAVE_L, RB
        | addd      4, RD, 0x8, RD
        | --
        | addd      3, RA_E, RD, RA
        | std       5, RD, -8, S0           // Store delta + FRAME_VARG
        | --
        | std       5, RD, -16, KBASE       // Store copy of LFUNC
        | --
        | ldd       3, RB, L->maxstack, S0
        | wait_load S0, 0
        | --
        | cmpedbsm  1, T1, 0x0, pred1
        | cmpbedb   3, RA, S0, pred0
        | wait_pred_ct pred0, 0
        | --
        | addd      3, BASE, 0x0, RA, pred0
        | addd      0, RD, 0x0, BASE, pred0
        | ct        ctpr1, ~pred0           // vm_growstack_v(PC, RD, RB)
        |                                   // Need to grow stack?
        | --
        | addd      3, RA, 0x8, RA, ~pred1
        | ldd       5, PC, PC2PROTO(k)-4, KBASE
        | pipe_dispatch_if 0, ctpr3, pred1
        |1:                                 // Copy fixarg slots up to new frame.
        | addd      3, RA, 0x8, RA
        | addd      4, 0x0, LJ_TNIL, S1
        | disp      ctpr1, >3
        | --
        | cmpbdb    3, RA, BASE, pred0
        | disp      ctpr2, <1
        | wait_pred pred0, 0
        | --
        | ldd       3, RA, -16, T4, pred0
        | subd      0, T1, 0x1, T1, pred0
        | --
        | ct        ctpr1, ~pred0           // >3, Less args than parameters?
        | --
        | cmpedb    0, T1, 0x0, pred0
        | addd      3, RD, 0x8, RD
        | std       5, RD, 0x0, T4
        | wait_pred_ct pred0, 0
        | --
        | std       5, RA, -16, S1          // Clear old fixarg slot (help the GC).
        | ct        ctpr2, ~pred0           // <1
        | --
        | pipe_dispatch 0, ctpr3
        | --
        |3:                                 // Clear missing parameters.
        | subd      0, T1, 0x1, T1
        | addd      3, RD, 0x8, RD
        | std       5, RD, 0x0, S1
        | --
        | cmpedb    0, T1, 0x0, pred0
        | wait_pred_ct pred0, 0
        | --
        | ct        ctpr1, ~pred0           // <3
        | --
        | pipe_dispatch 0, ctpr3
        | --
        break;

    case BC_FUNCC:
        | // ins_AD BASE = new base, RA_E = framesize*8, RD_E = (nargs+1)*8
        | setwd_call
        | ldd       0, BASE, -16, KBASE
        | addd      1, RA_E, 0, RA
        | addd      4, BASE, RD_E, RD
        | ldd       5, STACK, SAVE_L, RB
        | disp      ctpr1, ->vm_growstack_c
        | wait_load KBASE, 0
        | --
        | getfd     0, KBASE, (47 << 6), KBASE
        | subd      4, RD, 0x8, RD
        | std       5, RB, L->base, BASE
        | --
        | ldd       0, KBASE, CFUNC->f, KBASE
        | ldd       3, RB, L->maxstack, S1
        | addd      4, RD, 8*LUA_MINSTACK, S0
        | wait_load KBASE, 0
        | --
        | movtd     0, KBASE, ctpr2
        | addd      1, 0x0, ~LJ_VMST_C, S0
        | cmpbedb   3, S0, S1, pred0
        | addd      4, RB, 0x0, CARG1
        | std       5, RB, L->top, RD
        | wait_pred_ct pred0, 0
        | --
        | stw       2, DISPATCH, DISPATCH_GL(vmstate), S0, pred0
        | ct        ctpr1, ~pred0           // vm_growstack_c(RB)
        |                                   // Need to grow stack?
        | --
        | call      ctpr2, wbs = 0x8        // (lua_State *L)
        | --
        | ldd       3, RB, L->base, BASE
        | shld      4, CRET1, 0x3, RD       // return nresults
        | addd      5, 0x0, ~LJ_VMST_INTERP, S0
        | disp      ctpr1, ->vm_returnc
        | --
        | std       2, DISPATCH, DISPATCH_GL(cur_L), RB
        | addd      3, BASE, RD, RA
        | stw       5, DISPATCH, DISPATCH_GL(vmstate), S0
        | --
        | ldd       0, BASE, -8, PC         // Fetch PC of caller
        | ldd       3, RB, L->top, S0
        | wait_load S0, 0
        | --
        | subd      3, S0, RA, RA           // RA = (L->top - (L->base+nresults))*8
        | ct        ctpr1                   // vm_returnc(RA, RD, PC)
        | --
        break;

    case BC_FUNCCW:
        | // ins_AD BASE = new base, RA_E = framesize*8, RD_E = (nargs+1)*8
        | setwd_call
        | addd      0, RA_E, 0, RA          // FIXME: unused
        | ldd       2, BASE, -16, T2
        | addd      4, BASE, RD_E, RD
        | ldd       5, STACK, SAVE_L, RB
        | disp      ctpr1, ->vm_growstack_c
        | wait_load T2, 0
        | --
        | getfd     2, T2, (47 << 6), T2
        | subd      4, RD, 0x8, RD
        | std       5, RB, L->base, BASE
        | --
        | ldd       0, T2, CFUNC->f, CARG2
        | ldd       2, DISPATCH, DISPATCH_GL(wrapf), T3
        | ldd       3, RB, L->maxstack, S1
        | addd      4, RD, 8*LUA_MINSTACK, S0
        | --
        | addd      1, 0x0, ~LJ_VMST_C, S0
        | cmpbedb   3, S0, S1, pred0
        | wait_load CARG2, 1
        | --
        | addd      0, CARG2, 0x0, KBASE
        | addd      4, RB, 0x0, CARG1
        | std       5, RB, L->top, RD
        | wait_pred_ct pred0, LATENCY_LOAD
        | --
        | stw       2, DISPATCH, DISPATCH_GL(vmstate), S0, pred0
        | ct        ctpr1, ~pred0           // vm_growstack_c(RB), Need to grow stack?
        | --
        | movtd     0, T3, ctpr1
        | --
        | call      ctpr1, wbs = 0x8        // (lua_State *L, lua_CFunction f)
        | --
        | ldd       3, RB, L->base, BASE
        | shld      4, CRET1, 0x3, RD       // return nsresult
        | addd      5, 0x0, ~LJ_VMST_INTERP, S0
        | disp      ctpr1, ->vm_returnc
        | --
        | std       2, DISPATCH, DISPATCH_GL(cur_L), RB
        | addd      3, BASE, RD, RA
        | stw       5, DISPATCH, DISPATCH_GL(vmstate), S0
        | --
        | ldd       0, BASE, -8, PC         // Fetch PC of caller
        | ldd       3, RB, L->top, S0
        | wait_load S0, 0
        | --
        | subd      3, S0, RA, RA           // RA = (L->top - (L->base+nresults))*8
        | ct        ctpr1                   // vm_returnc(BASE, RA, RD, PC)
        | --
        break;

    /* ---------------------------------------------------------------------- */
    default:
        fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
        exit(2);
        break;
    }
}

static int build_backend(BuildCtx *ctx)
{
    int op;
    dasm_growpc(Dst, BC__MAX);
    build_subroutines(ctx);
    |.code_op
    for (op = 0 ; op < BC__MAX; op++)
        build_ins(ctx, (BCOp)op, op);
    return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions */
static void emit_asm_debug(BuildCtx* ctx)
{
    int fcofs = (int)((uint8_t *)ctx->glob[GLOB_vm_ffi_call] - ctx->code);
    switch  (ctx->mode) {
    case BUILD_elfasm:
        fprintf(ctx->fp, "\t.section .debug_frame,\"\",@progbits\n");
        fprintf(ctx->fp,
        ".Lframe0:\n"
        "\t.long .LECIE0-.LSCIE0\n"
        ".LSCIE0:\n"
        "\t.long 0xffffffff\n"
        "\t.byte 0x1\n"
        "\t.string \"\"\n"
        "\t.uleb128 0x1\n"
        "\t.sleb128 -8\n"
        "\t.byte 0x8c\n"
        "\t.byte 0xc\n\t.uleb128 0x19\n\t.uleb128 0\n"
        "\t.byte 0x9\n\t.uleb128 0x8c\n\t.uleb128 0\n"
        "\t.align 8\n"
        ".LECIE0:\n\n");
        fprintf(ctx->fp,
        ".LSFDE0:\n"
        "\t.long .LEFDE0-.LASFDE0\n"
        ".LASFDE0:\n"
        "\t.long .Lframe0\n"
        "\t.quad .Lbegin\n"
        "\t.quad %d\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE0:\n\n", fcofs);
#if LJ_HASFFI
        fprintf(ctx->fp,
        ".LSFDE1:\n"
        "\t.long .LEFDE1-.LASFDE1\n"
        ".LASFDE1:\n"
        "\t.long .Lframe0\n"
        "\t.quad lj_vm_ffi_call\n"
        "\t.quad %d\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
#endif
#if !LJ_NO_UNWIND
        fprintf(ctx->fp, "\t.section .eh_frame,\"a\",@progbits\n");
        fprintf(ctx->fp,
        "\t.globl lj_err_unwind_dwarf\n"
        ".Lframe1:\n"
        "\t.long .LECIE1-.LSCIE1\n"
        ".LSCIE1:\n"
        "\t.long 0\n"
        "\t.byte 0x1\n"
        "\t.string \"zPR\"\n"
        "\t.uleb128 0x1\n"
        "\t.sleb128 -8\n"
        "\t.byte 0x8c\n"
        "\t.uleb128 0xa\n"
        "\t.byte 0\n"
        "\t.quad lj_err_unwind_dwarf\n"
        "\t.byte 0\n"
        "\t.byte 0xc\n\t.uleb128 0x19\n\t.uleb128 0\n"
        "\t.byte 0x9\n\t.uleb128 0x8c\n\t.uleb128 0\n"
        "\t.align 8\n"
        ".LECIE1:\n\n");
        fprintf(ctx->fp,
        ".LSFDE2:\n"
        "\t.long .LEFDE2-.LASFDE2\n"
        ".LASFDE2:\n"
        "\t.long .LASFDE2-.Lframe1\n"
        "\t.quad .Lbegin\n"
        "\t.quad %d\n"
        "\t.uleb128 0\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE2:\n\n", fcofs);
#if LJ_HASFFI
        fprintf(ctx->fp,
        ".Lframe2:\n"
        "\t.long .LECIE2-.LSCIE2\n"
        ".LSCIE2:\n"
        "\t.long 0\n"
        "\t.byte 0x1\n"
        "\t.string \"zR\"\n"
        "\t.uleb128 0x1\n"
        "\t.sleb128 -8\n"
        "\t.byte 0x8c\n"
        "\t.uleb128 1\n"
        "\t.byte 0\n"
        "\t.byte 0xc\n\t.uleb128 0x19\n\t.uleb128 0\n"
        "\t.byte 0x9\n\t.uleb128 0x8c\n\t.uleb128 0\n"
        "\t.align 8\n"
        ".LECIE2:\n\n");
        fprintf(ctx->fp,
        ".LSFDE3:\n"
        "\t.long .LEFDE3-.LASFDE3\n"
        ".LASFDE3:\n"
        "\t.long .LASFDE3-.Lframe2\n"
        "\t.quad lj_vm_ffi_call\n"
        "\t.quad %d\n"
        "\t.uleb128 0\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE3:\n\n", (int)ctx->codesz - fcofs);
#endif
#endif
        break;
    default:
        break;
    }
}
