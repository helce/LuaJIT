|// Low-level VM code for E2K CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2021 Mike Pall. See Copyright Notice in luajit.h
|
|.arch e2k
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|.define RRET1,     r0
|.define RARG1,     r0
|.define RARG2,     r1
|.define RARG3,     r2
|.define RARG4,     r3
|.define RARG5,     r4
|.define RARG6,     r5
|.define RARG7,     r6
|.define RARG8,     r7
|
|.define CRET1,     b0
|.define CRET2,     b1
|.define CRET3,     b2
|.define CRET4,     b3
|.define CRET5,     b4
|.define CRET6,     b5
|.define CRET7,     b6
|.define CRET8,     b7
|.define CARG1,     b0
|.define CARG2,     b1
|.define CARG3,     b2
|.define CARG4,     b3
|.define CARG5,     b4
|.define CARG6,     b5
|.define CARG7,     b6
|.define CARG8,     b7
|
|.define BASE,      r4
|.define KBASE,     r5
|.define STACK,     r6
|.define PC,        r7
|.define DISPATCH,  r8
|
|.define TMP0,      r9
|.define TMP1,      r10
|
|.define RA,        r11
|.define RB,        r12
|.define RC,        r13
|.define RD,        r14
|.define ITYPE,     r15
|
|.macro do_fault
| addd 0, 0x0, 0x0, RARG1
| ldd 0, RARG1, 0x0, RARG1
|.endmacro
|.macro set_frame
| setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
| setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
|.endmacro
|.macro set_frame_4
| setwd wsz = 0x4, nfx = 0x1, dbl = 0x0
|.endmacro
|
|// Type definitions. Some of these are only used for documentation.
|.type L,           lua_State
|.type GL,          global_State
|.type TVALUE,      TValue
|.type GCOBJ,       GCobj
|.type STR,         GCstr
|.type TAB,         GCtab
|.type LFUNC,       GCfuncL
|.type CFUNC,       GCfuncC
|.type PROTO,       GCproto
|.type UPVAL,       GCupval
|.type NODE,        Node
|.type NARGS,       int
|.type TRACE,       GCtrace
|.type SBUF,        SBuf
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|//-----------------------------------------------------------------------
|.define CFRAME_SPACE,  0x30                // 8*6
|.define STACK_SPACE,   0xffffffd0          // -(8*6)
|.define MULTRES,       0x0
|.define SAVE_NRES,     0x8
|.define SAVE_ERRF,     0xc
|.define SAVE_L,        0x10
|.define SAVE_PC,       0x18
|.define SAVE_CFRAME,   0x20
|.define STACK_TMP,     0x28
|
|//-----------------------------------------------------------------------
|
|// Instruction headers.
|.macro ins_A; .endmacro
|.macro ins_AD; .endmacro
|.macro ins_AJ; .endmacro
|.macro ins_ABC
| andd 0, RD, 0x7f800, RB
| shrd 0, RB, 0x8, RB
| andd 0, RD, 0x7f8, RC
|.endmacro
|.macro ins_AND; .endmacro
|
|// Instruction decode+dispatch.
|.macro ins_NEXT             // AD = {D |A|OP}, ABC = {B|C|A|OP}, AC = {lo_D|A|OP}
|<
| ldw 0, PC, 0x0, TMP0
| ldb 2, PC, 0x0, TMP1
| addd 1, PC, 0x4, PC
| nop 2
|>
|<
| shld 2, TMP1, 0x3, TMP1
| shrd 3, TMP0, 0xd, RD
| shrd 4, TMP0, 0x15, RB
| shrd 5, TMP0, 0x5, RA
|>
|<
| andd 3, RD, 0x7fff8, RD
| andd 4, RA, 0x7f8, RA
|>
|<
| ldd 2, TMP1, DISPATCH, TMP1
| andd 3, RB, 0x7f8, RB
| andd 4, RD, 0x7f8, RC
| nop 2
|>
| movtd 0, TMP1, ctpr1
| ct ctpr1
|.endmacro
|
|// Instruction footer.
|.if 1
| // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
| .define ins_next, ins_NEXT
| .define ins_next_, ins_NEXT
|.else
| // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
| // Affects only certain kinds of benchmarks (and only with -j off).
| // Around 10%-30% slower on Core2, a lot more slower on P4.
| .macro ins_next
|   disp ctpr1, ->ins_next
| .endmacro
| .macro ins_next_
| ->ins_next:
|   ins_NEXT
| .endmacro
|.endif
| 
|// Call decode and dispatch.
|.macro ins_callt
| // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, [BASE-8] = PC
| ldd 0, RB, LFUNC->pc, PC
| ldw 0, PC, 0x0, RA
| andd 0, RA, 0xff, TMP0
| shrd 0, RA, 0x5, RA
| andd 0, RA, 0x7f8, RA
| addd 0, PC, 0x4, PC
| shld 0, TMP0, 0x3, TMP0                      // jmp to [DISPATCH+OP*8]
| ldd 0, TMP0, DISPATCH, TMP0
| movtd 0, TMP0, ctpr1
| ct ctpr1
|.endmacro
|
|.macro ins_call
| // BASE = new base, RB = LFUNC, RD = (nargs+1)*8, PC = caller PC
| std 2, BASE, 0xfffffff8, PC
| ins_callt
|.endmacro
|
|//-----------------------------------------------------------------------
|
|// Macros to clear or set tags.
|.macro cleartp, reg
| shld 0, reg, 0x11, reg
| shrd 0, reg, 0x11, reg
|.endmacro
|.macro settp, reg, tp
| addd 0, 0x0, tp, ITYPE
| shld 0, ITYPE, 0x2f, ITYPE
| ord 0, reg, ITYPE, reg
|.endmacro
|.macro settp, dst, reg, tp
| addd 0, 0x0, tp, dst
| shld 0, dst, 0x2f, dst
| ord 0, dst, reg, dst
|.endmacro
|
|// Macros to test operand types.
|.macro checktp_nc, reg, tp, target
| addd 0, reg, 0x0, ITYPE
| sard 0, ITYPE, 0x2f, ITYPE
| cmpesb 0, ITYPE, tp, pred0
| disp ctpr1, target
| ct ctpr1, ~pred0
|.endmacro
|.macro checktp, reg, tp, target
| addd 0, reg, 0x0, ITYPE
| cleartp reg
| sard 0, ITYPE, 0x2f, ITYPE
| cmpesb 0, ITYPE, tp, pred0
| disp ctpr1, target
| ct ctpr1, ~pred0
|.endmacro
|.macro checktptp, src, tp, target
| addd 0, src, 0x0, ITYPE
| sard 0, ITYPE, 0x2f, ITYPE
| cmpesb 0, ITYPE, tp, pred0
| disp ctpr1, target
| ct ctpr1, ~pred0
|.endmacro
|
|.macro checknumx, reg, target, cmp, pred
| addd 0, reg, 0x0, ITYPE
| sard 0, ITYPE, 0x2f, ITYPE
| cmp 0, ITYPE, LJ_TISNUM, pred0
| disp ctpr1, target
| ct ctpr1, pred
|.endmacro
|.macro checkstr, reg, target; checktp reg, LJ_TSTR, target; .endmacro
|.macro checktab, reg, target; checktp reg, LJ_TTAB, target; .endmacro
|.macro checkfunc, reg, target; checktp reg, LJ_TFUNC, target; .endmacro
|.macro checknum, reg, target; checknumx reg, target, cmpbsb, ~pred0; .endmacro
|.macro checknumtp, src, target; checknumx src, target, cmpbsb, ~pred0; .endmacro
|.macro checknumber, src, target; checknumx src, target, cmpbesb, ~pred0; .endmacro
|
|.macro mov_false, reg
| addd 0, 0x0, U64x(0xffff7fff,0xffffffff), reg
|.endmacro
|.macro mov_true, reg
| addd 0, 0x0, U64x(0xfffeffff,0xffffffff), reg
|.endmacro
|
|.define PC_OP, 0xfffffffc                  // Byte
|.define PC_RA, 0xfffffffd                  // Byte
|.define PC_RB, 0xffffffff                  // Byte
|.define PC_RC, 0xfffffffe                  // Byte
|.define PC_RD, 0xfffffffe                  // Halfword
|.macro branchPC, reg
| shld 0, reg, 0x2, reg
| addd 0, PC, reg, PC
| subd 0, PC, BCBIAS_J*4, PC
|.endmacro
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)      (GG_DISP2G + (int)offsetof(global_State, field))
#define PC2PROTO(field)         ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|
|// Set current VM state.
|.macro set_vmstate, st
| addd 0, 0x0, ~LJ_VMST_..st, TMP0
| stw 2, DISPATCH, DISPATCH_GL(vmstate), TMP0
|.endmacro
|
|// Move table write barrier back. Overwrites reg.
|.macro barrierback, tab, reg, tmp
| ldb 0, tab, TAB->marked, tmp
| andd 0, tmp, ~LJ_GC_BLACK, tmp               // black2gray(tab)
| stb 2, tab, TAB->marked, tmp
| ldd 0, DISPATCH, DISPATCH_GL(gc.grayagain), reg
| std 2, DISPATCH, DISPATCH_GL(gc.grayagain), tab
| std 2, tab, TAB->gclist, reg
|.endmacro
|
|//-----------------------------------------------------------------------

/* Generate subroutines used by opcodes and other parts of the VM */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
    |.code_sub
    |
    |//-----------------------------------------------------------------------
    |//-- Return handling ----------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_returnp:
    | cmpandesb 0, PC, FRAME_P, pred0
    | disp ctpr1, ->cont_dispatch
    | ct ctpr1, pred0
    |
    | // Return from pcall or xpcall fast func
    | andd 0, PC, 0xfffffff8, PC
    | subd 0, BASE, PC, BASE                   // Restore caller base.
    | addd 0, RA, PC, RA                       // Rebase RA and prepend one result.
    | subd 0, RA, 0x8, RA
    | ldd 0, BASE, 0xfffffff8, PC              // Fetch PC of previous frame.
    | // Prepending may overwrite the pcall frame, so do it at the end.
    | mov_true ITYPE
    | std 2, BASE, RA, ITYPE                   // Prepend true to results.
    |
    |->vm_returnc:
    | addd 0, RD, 0x8, RD                      // RD = (nresults+1)*8
    | cmpedb 0, RD, 0x0, pred0
    | addd 0, 0x0, LUA_YIELD, RRET1
    | disp ctpr1, ->vm_unwind_c_eh
    | ct ctpr1, pred0
    | stw 2, STACK, MULTRES, RD
    | cmpandedb 0, PC, FRAME_TYPE, pred0
    | disp ctpr1, ->BC_RET_Z
    | ct ctpr1, pred0                       // Handle regular return to Lua.
    |
    |->vm_return:
    | // BASE = base, RA = resultofs, RD/MULTRES = (nresults+1)*8, PC = return
    | xord 0, PC, FRAME_C, PC
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | disp ctpr1, ->vm_returnp
    | ct ctpr1, ~pred0
    |
    | // Return to C.
    | set_vmstate C
    | subd 0, 0x0, 0x8, TMP0
    | andd 0, PC, TMP0, PC
    | subd 0, PC, BASE, PC
    | subd 0, 0x0, PC, PC                      // Previous base = BASE - delta
    | subd 0, RD, 0x8, RD
    | cmpedb 0, RD, 0x0, pred0
    | disp ctpr1, >2
    | ct ctpr1, pred0
    |1:                                     // Move results down.
    | ldd 0, BASE, RA, RB
    | subd 0, BASE, 0x10, TMP0
    | std 2, TMP0, 0x0, RB
    | addd 0, BASE, 0x8, BASE
    | subd 0, RD, 0x8, RD
    | cmpedb 0, RD, 0x0, pred0
    | disp ctpr1, <1
    | ct ctpr1, ~pred0
    |2:
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, PC
    |3:
    | ldw 0, STACK, MULTRES, RD
    | ldw 0, STACK, SAVE_NRES, RA
    | shld 0, RA, 0x3, RA                      // RA = wanted (nresults+1)*8
    |4:
    | cmpesb 0, RA, RD, pred0
    | disp ctpr1, >6
    | ct ctpr1, ~pred0                      // More/less results wanted?
    |5:
    | subd 0, BASE, 0x10, BASE
    | std 2, RB, L->top, BASE
    | ldd 0, STACK, SAVE_CFRAME, TMP0          // Restore previous C frame.
    | std 2, RB, L->cframe, TMP0
    | addd 0, 0x0, 0x0, RRET1                  // Ok return status for vm_pcall.
    | return ctpr3
    | ct ctpr3
    |
    |6:
    | cmpbsb 0, RA, RD, pred0
    | disp ctpr1, >7                        // Less results wanted?
    | ct ctpr1, pred0
    | // More results wanted. Check stack size and fill up results with nil.
    | ldd 0, RB, L->maxstack, TMP0
    | cmpbedb 0, BASE, TMP0, pred0
    | disp ctpr1, >8
    | ct ctpr1, ~pred0
    | subd 0, BASE, 0x10, TMP0
    | addd 0, 0x0, LJ_TNIL, TMP1
    | std 2, TMP0, 0x0, TMP1
    | addd 0, BASE, 0x8, BASE
    | adds 0, RD, 0x8, RD
    | disp ctpr1, <4
    | ct ctpr1
    |
    |7:                                     // Less results wanted.
    | cmpesb 0, RA, 0x0, pred0
    | disp ctpr1, <5
    | ct ctpr1, pred0
    | subd 0, RA, RD, RA                       // Negative result!
    | addd 0, BASE, RA, BASE                   // Correct top.
    | disp ctpr1, <5
    | ct ctpr1
    |
    |8:
    | // Corner case: need to grow stack for filling up results.
    | // This can happen if:
    | // - A C function grows the stack (a lot).
    | // - The GC shrinks the stack in between.
    | // - A return back from a lua_call() with (high) nresults adjustment.
    | std 2, RB, L->top, BASE                  // Save current top held in BASE (yes).
    | stw 2, STACK, MULTRES, RD
    | adds 0, RA, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    | call ctpr1, wbs = 0x8
    | ldd 0, RB, L->top, BASE                  // Need the (realloced) L->top in BASE
    | disp ctpr1, <3
    | ct ctpr1
    |
    |->vm_unwind_c:                         // Unwind C stack, return from vm_pcall.
    | // (void *cframe, int errcode)
    | set_frame
    | addd 0, RARG1, 0x0, STACK
    | addd 0, RARG2, 0x0, RRET1                // Error return status for vm_pcall.
    |->vm_unwind_c_eh:                      // Landing pad for external unwinder.
    | ldd 0, STACK, SAVE_L, RB
    | ldd 0, RB, L->glref, RB
    | addd 0, 0x0, ~LJ_VMST_C, TMP0
    | stw 2, RB, GL->vmstate, TMP0
    | return ctpr3
    | ct ctpr3
    |
    |->vm_unwind_ff:                        // Unwind C stack, return from ff pcall.
    | // (void *cframe)
    | set_frame
    | andd 0, RARG1, CFRAME_RAWMASK, RARG1
    | addd 0, RARG1, 0x0, STACK
    |->vm_unwind_ff_eh:                     //  Landing pad for external unwinder.
    | ldd 0, STACK, SAVE_L, RB
    | addd 0, 0x0, (1+1)*8, RD                 // Really 1+2 results, incr. later.
    | ldd 0, RB, L->base, BASE
    | ldd 0, RB, L->glref, DISPATCH            // Setup pointer to dispatch table.
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | ldd 0, BASE, 0xfffffff8, PC              // Fetch PC of previous frame.
    | mov_false RA
    | ldd 0, BASE, 0x0, RB
    | std 2, BASE, 0xfffffff0, RA              // Prepend false to error message.
    | std 2, BASE, 0xfffffff8, RB
    | subd 0, 0x0, 0x10, RA                    // Results start at BASE+RA = BASE-16.
    | set_vmstate INTERP
    | disp ctpr1, ->vm_returnc              // Increments RD/MULTRES and returns.
    | ct ctpr1
    |
    |//-----------------------------------------------------------------------
    |//-- Grow stack for calls -----------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_growstack_c:                      // Grow stack for C function.
    | addd 0, 0x0, LUA_MINSTACK, CARG2
    | disp ctpr1, >2
    | ct ctpr1
    |
    |->vm_growstack_v:                      // Grow stack for vararg Lua function.
    | subd 0, RD, 0x10, RD                     // LJ_FR2
    | disp ctpr1, >1
    | ct ctpr1
    |
    |->vm_growstack_f:                      // Grow stack for fixarg Lua function.
    | // BASE = new base, RD = (nargs+1)*8, RB = L, PC = first PC
    | addd 0, BASE, RD, RD
    | subd 0, RD, 0x8, RD
    |1:
    | ldb 0, PC, PC2PROTO(framesize)-4, RA
    | addd 0, PC, 0x4, PC                      // Must point after first instruction.
    | std 2, RB, L->base, BASE
    | std 2, RB, L->top, RD
    | std 2, STACK, SAVE_PC, PC
    | addd 0, RA, 0x0, CARG2
    |2:
    | // RB = L, L->base = new base, L->top = top 
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    | call ctpr1, wbs = 0x8
    | ldd 0, RB, L->base, BASE
    | ldd 0, RB, L->top, RD
    | ldd 0, BASE, 0xfffffff0, RB
    | cleartp RB
    | subd 0, RD, BASE, RD
    | addd 0, RD, 0x8, RD
    |
    | // BASE = new base, RB = LFUNC, RD = (nargs+1)*8
    | ins_callt                             // Just retry the call
    |
    |//-----------------------------------------------------------------------
    |//-- Entry points into the assembler VM ---------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_resume:                           // Setup C frame and resume thread.
    | // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
    | set_frame
    | addd 0, RARG1, 0x0, RB
    | getsp 0, STACK_SPACE, STACK
    | std 2, STACK, SAVE_L, RARG1
    | addd 0, RARG2, 0x0, RA
    | addd 0, 0x0, FRAME_CP, PC
    | addd 0, 0x0, 0x0, RD
    | addd 0, STACK, CFRAME_RESUME, KBASE
    | ldd 0, RB, L->glref, DISPATCH            // Setup pointer to dispatch table.
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | std 2, STACK, SAVE_PC, RD                // Any value outside of bytecode is ok.
    | std 2, STACK, SAVE_CFRAME, RD
    | stw 2, STACK, SAVE_NRES, RD
    | stw 2, STACK, SAVE_ERRF, RD
    | std 2, RB, L->cframe, KBASE
    | ldb 0, RB, L->status, TMP0
    | cmpedb 0, TMP0, 0x0, pred0
    | disp ctpr1, >2
    | ct ctpr1, pred0                       // Initial resume (like a call).
    | 
    | // Resume after yield (like a return).
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    | set_vmstate INTERP
    | stb 2, RB, L->status, RD
    | ldd 0, RB, L->base, BASE
    | ldd 0, RB, L->top, RD
    | subd 0, RD, RA, RD
    | addd 0, RD, 0x8, RD                      // RD = (nresults+1)*8
    | subd 0, RA, BASE, RA                     // RA = resultofs
    | ldd 0, BASE, 0xfffffff8, PC
    | stw 2, STACK, MULTRES, RD
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | disp ctpr1, ->BC_RET_Z
    | ct ctpr1, pred0
    | disp ctpr1, ->vm_return
    | ct ctpr1
    |
    |->vm_pcall:                            // Setup protected C frame and enter VM.
    | // (lua_State *L, TValue *base, int news1, ptrdiff_t ef)
    | set_frame
    | addd 0, 0x0, FRAME_CP, PC
    | getsp 0, STACK_SPACE, STACK
    | stw 2, STACK, SAVE_ERRF, RARG4
    | disp ctpr1, >1
    | ct ctpr1
    |
    |->vm_call:                             // Setup C frame and enter VM.
    | // (lua_State *L, TValue *base, int nres1)
    | set_frame
    | getsp 0, STACK_SPACE, STACK
    | addd 0, 0x0, FRAME_C, PC
    |
    |1: // Entry point for vm_pcall above (PC = ftype)
    | stw 2, STACK, SAVE_NRES, RARG3
    | std 2, STACK, SAVE_L, RARG1
    | addd 0, RARG1, 0x0, RB
    | addd 0, RARG2, 0x0, RA
    | ldd 0, RB, L->glref, DISPATCH            // Setup pointer to dispatch table.
    | ldd 0, RB, L->cframe, KBASE              // Add our C frame to cframe chain.
    | std 2, STACK, SAVE_CFRAME, KBASE
    | std 2, STACK, SAVE_PC, RB                // Any value outsize of bytecode is ok.
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | std 2, RB, L->cframe, STACK
    |
    |2: // Entry point for vm_resume/vm_cpcall (RA = base, RB = L, PC = ftype)
    |<
    | addd 0, PC, RA, PC
    | addd 1, 0x0, ~LJ_VMST_INTERP, TMP0
    | ldd 3, RB, L->base, BASE              // BASE = old base (used in vmeta_call).
    | ldd 5, RB, L->top, RD
    | disp ctpr1,  ->vmeta_call
    |>
    |<
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    |>
    |<
    | ldd 0, RA, 0xfffffff0, RB             // RB = LFUNC
    | stw 2, DISPATCH, DISPATCH_GL(vmstate), TMP0
    | nop 1
    |>
    |<
    | subd 0, PC, BASE, PC                  // PC = frame delta + frame type
    | addd 3, RA, 0x0, CARG2
    |>
    |<
    | sard 0, RB, 0x2f, ITYPE
    | andd 1, RB, U64x(0x00007fff,0xffffffff), RB
    | subd 3, RD, CARG2, RD
    |>
    |<
    | lddsm 0, RB, LFUNC->pc, CARG1
    | cmpesb 1, ITYPE, LJ_TFUNC, pred0
    | addd 3, RD, 0x8, RD                   // RD = (nargs+1)*8
    | nop 1
    |>
    |<
    | addd 3, CARG2, 0x0, BASE, pred0       // BASE = new base
    | ct ctpr1, ~pred0
    |>
    |<
    | ldb 2, CARG1, 0x0, TMP1
    | ldw 3, CARG1, 0x0, RA
    | nop 2
    |>
    |<
    | shld 0, TMP1, 0x3, TMP1               // jmp to [DISPATCH+OP*8]
    | std 2, BASE, 0xfffffff8, PC           // [BASE-8] = PC
    |>
    |<
    | ldd 0, TMP1, DISPATCH, TMP1
    | addd 1, CARG1, 0x4, PC
    | shrd 3, RA, 0x5, RA
    | nop 2
    |>
    |<
    | movtd 0, TMP1, ctpr1
    | andd 3, RA, 0x7f8, RA
    |>
    | ct ctpr1
    |
    |->vm_cpcall:                           // Setup protected C frame, call C.
    | // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
    |<
    | setwd wsz = 0xc, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x8, rcur = 0x0
    |>
    |<
    | getsp 0, STACK_SPACE, STACK
    | addd 1, RARG1, 0x0, RB
    | ldd 2, RARG1, L->top, TMP1
    |>
    |<
    | ldd 0, RB, L->stack, TMP0
    | ldd 2, RB, L->glref, DISPATCH         // Setup pointer to dispatch table.
    | nop 1
    |>
    |<
    | movtd 0, RARG4, ctpr1
    | std 2, STACK, SAVE_L, RB
    |>
    |<
    | subd 0, TMP0, TMP1, TMP0
    | addd 1, 0x0, 0x0, TMP1
    | std 2, STACK, SAVE_PC, RB
    |>
    |<
    | addd 0, DISPATCH, GG_G2DISP, DISPATCH
    | stw 2, STACK, SAVE_ERRF, TMP1         // No error function.
    |>
    |<
    | ldd 0, RB, L->cframe, TMP0
    | stw 2, STACK, SAVE_NRES, TMP0         // Neg. delta means cframe w/o frame.
    |>
    |<
    | addd 0, RARG1, 0x0, CARG1
    | std 2, STACK, SAVE_CFRAME, TMP0
    |>
    |<
    | addd 0, RARG2, 0x0, CARG2
    | std 2, RB, L->cframe, STACK
    |>
    |<
    | addd 0, RARG3, 0x0, CARG3
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    | call ctpr1, wbs = 0x8                 // (lua_State *L, lua_CFunction func, void *ud)
    |>
    | // TValue * (new base) or NULL returned.
    | lddsm 0, STACK, SAVE_CFRAME, TMP0     // Restore previous C frame.
    | disp ctpr1, <2
    | nop 1
    |<
    | cmpedb 1, CRET1, 0x0, pred0
    | return ctpr3
    |>
    |<
    | addd 0, 0x0, 0x0, RRET1, pred0        // Ok return status for vm_pcall.
    | std 2, RB, L->cframe, TMP0, pred0
    |>
    | ct ctpr3, pred0
    |<
    | addd 0, CRET1, 0x0, RA
    | addd 1, 0x0, FRAME_CP, PC
    | ct ctpr1                              // Else continue with the call.
    |>
    |
    |//-----------------------------------------------------------------------
    |//-- Metamethod handling ------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |//-- Continuation dispatch ----------------------------------------------
    |
    |->cont_dispatch:
    | // BASE = meta base, RA = resultofs, RD = (nresults+1)*8 (also in MULTRES)
    | addd 0, BASE, RA, RA
    | andd 0, PC, 0xfffffff8, PC
    | addd 0, BASE, 0x0, RB
    | subd 0, BASE, PC, BASE                   // Restore caller BASE.
    | addd 0, 0x0, LJ_TNIL, TMP0
    | addd 0, RA, RD, TMP1
    | std 2, TMP1, 0xfffffff8, TMP0            // Ensure one valid arg.
    | addd 0, RA, 0x0, CRET1
    | ldd 0, RB, 0xffffffe8, PC                // Restore PC from [cont|PC].
    | ldd 0, RB, 0xffffffe0, RA
    |.if FFI
    | cmpbedb 0, RA, 0x1, pred0
    | disp ctpr1, >1
    | ct ctpr1, pred0
    |.endif
    | ldd 0, BASE, 0xfffffff0, KBASE
    | cleartp KBASE
    | ldd 0, KBASE, LFUNC->pc, KBASE
    | ldd 0, KBASE, PC2PROTO(k), KBASE
    | // BASE = base, CRET1 = result, RB = meta base
    | movtd 0, RA, ctpr1
    | ct ctpr1                              // Jump to continuation.
    |
    |.if FFI
    |1:
    | cmpedb 0, RA, 0x1, pred0
    | disp ctpr1, ->cont_ffi_callback       // cont = 1: return from FFI callback.
    | ct ctpr1, pred0
    | // cont = 0: Tail call from C function.
    | subd 0, RB, BASE, RB
    | subd 0, RB, 0x18, RD
    | disp ctpr1, ->vm_call_tail
    | ct ctpr1
    |.endif
    |
    |->cont_cat:                            // BASE = base, CRET1 = result, RB = mbase
    | ldb 0, PC, PC_RB, RA
    | subd 0, RB, 0x20, RB
    | shld 0, RA, 0x3, RA
    | addd 0, BASE, RA, RA
    | subd 0, RA, RB, RA
    | cmpedb 0, RA, 0x0, pred0
    | disp ctpr1, ->cont_ra
    | ct ctpr1, pred0
    | subd 0, 0x0, RA, RA
    | shrd 0, RA, 0x3, RA
    | addd 0, RA, 0x0, CARG3
    | ldd 0, CRET1, 0x0, RA
    | std 2, RB, 0x0, RA
    | addd 0, RB, 0x0, CARG2
    | ldd 0, STACK, SAVE_L, CARG1
    | std 2, CARG1, L->base, BASE
    | disp ctpr1, ->BC_CAT_Z
    | ct ctpr1
    |
    |//-- Table indexing metamethods -----------------------------------------
    |
    |->vmeta_tgets:
    | settp RC, LJ_TSTR                     // RC = GCstr *
    | addd 0, DISPATCH, DISPATCH_GL(tmptv), TMP0 // Store GStr * in g->tmptv
    | std 2, TMP0, 0x0, RC
    | addd 0, TMP0, 0x0, RC
    | ldb 0, PC, PC_OP, TMP1
    | cmpedb 0, TMP1, BC_GGET, pred0
    | disp ctpr1, >1
    | ct ctpr1, ~pred0
    | settp RA, RB, LJ_TTAB                 // RB = GCtab *
    | addd 0, DISPATCH, DISPATCH_GL(tmptv2), RB // Store fn->l.env in g->tmptv2.
    | std 2, RB, 0x0, RA
    | disp ctpr1, >2
    | ct ctpr1
    |
    |->vmeta_tgetb:
    | ldb 0, PC, PC_RC, RC
    | istofd 0, RC, TMP0
    | addd 0, DISPATCH, DISPATCH_GL(tmptv), RC
    | std 2, RC, 0x0, TMP0
    | disp ctpr1, >1
    | ct ctpr1
    |
    |->vmeta_tgetv:
    | ldb 0, PC, PC_RC, RC                     // Reload TValue *k from RC.
    | shld 0, RC, 0x3, RC
    | addd 0, BASE, RC, RC
    |1:
    | ldb 0, PC, PC_RB, RB                     // Reload TValue *t from RB.
    | shld 0, RB, 0x3, RB
    | addd 0, BASE, RB, RB
    |2:
    | ldd 0, STACK, SAVE_L, CARG1
    | std 2, CARG1, L->base, BASE
    | addd 0, RB, 0x0, CARG2
    | addd 0, RC, 0x0, CARG3
    | addd 0, CARG1, 0x0, RB
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_tget       // (lua_State *L, TValue *o, TValue *k)
    | call ctpr1, wbs = 0x8
    | // TValue * (finished) or NULL (metamethod) returned.
    | ldd 0, RB, L->base, BASE
    | cmpedb 0, CRET1, 0x0, pred0
    | disp ctpr1, >3
    | ct ctpr1, pred0
    |
    |->cont_ra:                             // BASE = base, CRET1 = result
    | ldb 0, PC, PC_RA, RA
    | shld 0, RA, 0x3, RA
    | ldd 0, CRET1, 0x0, RB
    | std 2, BASE, RA, RB
    | ins_next
    |
    |3:                                     // Call __index metamethod. 
    | // BASE = base, L->top = new base, stack = cont/func/t/k
    | ldd 0, RB, L->top, RA
    | std 2, RA, 0xffffffe8, PC                // [RA-24] cont|PC
    | addd 0, RA, FRAME_CONT, PC
    | subd 0, PC, BASE, PC
    | ldd 0, RA, 0xfffffff0, RB                // [RA-16] Guaranteed to be a function here.
    | addd 0, 0x0, (2+1)*8, RD                 // (2+1)*8 args for func(t, k)
    | cleartp RB
    | addd 0, RA, 0x0, BASE
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |
    |->vmeta_tgetr:
    | addd 0, RB, 0x0, CARG1
    | adds 0, RC, 0x0, CARG2
    | disp ctpr1, extern lj_tab_getinth     // // (GCtab *t, int32_t key)
    | call ctpr1, wbs = 0x8
    | // cTValue * or NULL returned.
    | ldb 0, PC, PC_RA, RA
    | shld 0, RA, 0x3, RA
    | cmpedb 0, CRET1, 0x0, pred0
    | disp ctpr1, >1
    | ct ctpr1, ~pred0
    | addd 0, 0x0, LJ_TNIL, ITYPE
    | disp ctpr1, >2
    | ct ctpr1
    |1:
    | ldd 0, CRET1, 0x0, ITYPE
    |2:
    | std 2, BASE, RA, ITYPE
    | ins_next
    |
    |//-----------------------------------------------------------------------
    |
    |->vmeta_tsets:
    | settp RC, LJ_TSTR                     // STR:RC = GCstr *
    | std 2, STACK, STACK_TMP, RC
    | addd 0, STACK, STACK_TMP, RC
    | ldb 0, PC, PC_OP, TMP0
    | cmpedb 0, TMP0, BC_GSET, pred0
    | disp ctpr1, >1
    | ct ctpr1, ~pred0
    | settp RA, RB, LJ_TTAB                 // RB = GCtab *
    | addd 0, DISPATCH, DISPATCH_GL(tmptv), RB // Store fn->l.env in g->tmptv
    | std 2, RB, 0x0, RA
    | disp ctpr1, >2
    | ct ctpr1
    |
    |->vmeta_tsetb:
    | ldb 0, PC, PC_RC, RC
    | istofd 0, RC, RC
    | std 2, STACK, STACK_TMP, RC
    | addd 0, STACK, STACK_TMP, RC
    | disp ctpr1, >1
    | ct ctpr1
    |
    |->vmeta_tsetv:
    | ldb 0, PC, PC_RC, RC                     // Reload TValue *k from RC.
    | shld 0, RC, 0x3, RC
    | addd 0, BASE, RC, RC
    |1:
    | ldb 0, PC, PC_RB, RB                     // Reload TValue *t from RB.
    | shld 0, RB, 0x3, RB
    | addd 0, BASE, RB, RB
    |2:
    | ldd 0, STACK, SAVE_L, CARG1
    | std 2, CARG1, L->base, BASE
    | addd 0, RB, 0x0, CARG2
    | addd 0, RC, 0x0, CARG3
    | addd 0, CARG1, 0x0, RB
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_tset      // (lua_State *L, TValue *o, TValue *k)
    | call ctpr1, wbs = 0x8
    | // TValue * (finished) or NULL (metamethod) returned.
    | ldd 0, RB, L->base, BASE
    | cmpedb 0, CRET1, 0x0, pred0
    | disp ctpr1, >3
    | ct ctpr1, pred0
    | // NOBARRIER: lj_meta_tset ensures the table is not black.
    | ldb 0, PC, PC_RA, RA
    | shld 0, RA, 0x3, RA
    | ldd 0, BASE, RA, RB
    | std 2, CRET1, 0x0, RB
    |->cont_nop:                            // BASE = base, (CRET1 = result)
    | ins_next
    |
    |3: // Call __newindex metamethod
    | // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
    | ldd 0, RB, L->top, RA
    | std 2, RA, 0xffffffe8, PC                // [cont|PC]
    | ldb 0, PC, PC_RA, RC
    | // Copy value to third argument.
    | shld 0, RC, 0x3, RC
    | ldd 0, BASE, RC, RB
    | std 2, RA, 0x10, RB
    | addd 0, RA, FRAME_CONT, PC
    | subd 0, PC, BASE, PC
    | ldd 0, RA, 0xfffffff0, RB                // Guaranteed to be a function here.
    | addd 0, 0x0, (3+1)*8, RD                 // 3 args for func (t, k, v)
    | cleartp RB
    | addd 0, RA, 0x0, BASE
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |
    |->vmeta_tsetr:
    | ldd 0, STACK, SAVE_L, CARG1
    | addd 0, RB, 0x0, CARG2
    | std 2, CARG1, L->base, BASE
    | adds 0, RC, 0x0, CARG3
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_tab_setinth     // (lua_State *L, GCtab *t, int32_t key)
    | call ctpr1, wbs = 0x8
    | // TValue * returned.
    | ldb 0, PC, PC_RA, RA
    | shld 0, RA, 0x3, RA
    | ldd 0, BASE, RA, ITYPE
    | std 2, CRET1, 0x0, ITYPE
    | ins_next
    |
    |//-- Comparison metamethods ---------------------------------------------
    |
    |->vmeta_comp:
    | ldh 0, PC, PC_RD, RD
    | shld 0, RD, 0x3, RD
    | ldb 0, PC, PC_RA, RA
    | shld 0, RA, 0x3, RA
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | addd 0, BASE, RA, CARG2
    | addd 0, BASE, RD, CARG3
    | addd 0, RB, 0x0, CARG1
    | ldb 0, PC, PC_OP, CARG4
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_comp       // (lua_State *L, TValue *o1, *o2, int op)
    | call ctpr1, wbs = 0x8
    | // 0/1 or TValue * (metamethod) returned.
    |3:
    | ldd 0, RB, L->base, BASE
    | cmpbedb 0, CRET1, 0x1, pred0
    | disp ctpr1, ->vmeta_binop
    | ct ctpr1, ~pred0
    |4:
    | addd 0, PC, 0x4, PC
    | cmpbdb 0, CRET1, 0x1, pred0
    | disp ctpr1, >6
    | ct ctpr1, pred0
    |5:
    | ldh 0, PC, PC_RD, RD
    | branchPC RD
    |6:
    | ins_next
    |
    |->cont_condt:
    | // BASE = base, CRET1 = result
    | addd 0, PC, 0x4, PC
    | ldd 0, CRET1, 0x0, ITYPE
    | sard 0, ITYPE, 0x2f, ITYPE
    | cmpbsb 0, ITYPE, LJ_TISTRUECOND, pred0
    | disp ctpr1, <5                        // Branch if result is true.
    | ct ctpr1, pred0
    | disp ctpr1, <6
    | ct ctpr1
    |
    |->cont_condf:                          // BASE = base, CRET1 = result
    | addd 0, PC, 0x4, PC
    | ldd 0, CRET1, 0x0, ITYPE
    | sard 0, ITYPE, 0x2f, ITYPE
    | cmpbsb 0, ITYPE, LJ_TISTRUECOND, pred0   // Branch if result is false.
    | disp ctpr1, <6
    | ct ctpr1, pred0
    | disp ctpr1, <5
    | ct ctpr1
    |
    |->vmeta_equal:
    | cleartp RD
    | subd 0, PC, 0x4, PC
    | addd 0, RA, 0x0, CARG2
    | addd 0, RB, 0x0, CARG4
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | addd 0, RD, 0x0, CARG3
    | addd 0, RB, 0x0, CARG1
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_equal      // (lua_State *L, GCobj *o1, *o2, int ne)
    | call ctpr1, wbs = 0x8
    | // 0/1 or TValue * (metamethod) returned.
    | disp ctpr1, <3
    | ct ctpr1
    |
    |->vmeta_equal_cd:
    |.if FFI
    | subd 0, PC, 0x4, PC
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | addd 0, RB, 0x0, CARG1
    | ldw 0, PC, 0xfffffffc, CARG2
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_equal_cd   // (lua_State *L, BCIns ins)
    | call ctpr1, wbs = 0x8
    | // 0/1 or TValue * (metamethod) returned.
    | disp ctpr1, <3
    | ct ctpr1
    |.endif
    |
    |->vmeta_istype:
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | shrd 0, RD, 0x3, CARG3
    | shrd 0, RA, 0x3, CARG2
    | addd 0, RB, 0x0, CARG1
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_istype     // (lua_State *L, BCReg ra, BCReg tp)
    | call ctpr1, wbs = 0x8
    | ldd 0, RB, L->base, BASE
    | disp ctpr1, <6
    | ct ctpr1
    |
    |//-- Arithmetic metamethods ---------------------------------------------
    |
    |->vmeta_arith_vn:
    | addd 0, KBASE, RC, RC
    | disp ctpr1, >1
    | ct ctpr1
    |
    |->vmeta_arith_nv:
    | addd 0, KBASE, RC, TMP0
    | addd 0, BASE, RB, RC
    | addd 0, TMP0, 0x0, RB
    | disp ctpr1, >2
    | ct ctpr1
    |
    |->vmeta_unm:
    | addd 0, BASE, RD, RC
    | addd 0, RC, 0x0, RB
    | disp ctpr1, >2
    | ct ctpr1
    |
    |->vmeta_arith_vv:
    | addd 0, BASE, RC, RC
    |1:
    | addd 0, BASE, RB, RB
    |2:
    | addd 0, BASE, RA, RA
    | ldb 0, PC, PC_OP, CARG5
    | addd 0, RA, 0x0, CARG2
    | addd 0, RC, 0x0, CARG4
    | ldd 0, STACK, SAVE_L, CARG1
    | std 2, CARG1, L->base, BASE
    | addd 0, RB, 0x0, CARG3
    | addd 0, CARG1, 0x0, RB
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_arith      // (lua_State *L, TValue *ra, *rb, *rc, BCReg op)
    | call ctpr1, wbs = 0x8
    | // NULL (finished) or TValue * (metamethod) returned.
    | ldd 0, RB, L->base, BASE
    | cmpedb 0, CRET1, 0x0, pred0
    | disp ctpr1, ->cont_nop
    | ct ctpr1, pred0
    |
    | // Call metamethod for binary op.
    |->vmeta_binop:
    | // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
    | addd 0, CRET1, 0x0, RA
    | subd 0, CRET1, BASE, CRET1
    | std 2, RA, 0xffffffe8, PC                // [cont|PC]
    | addd 0, CRET1, FRAME_CONT, PC
    | addd 0, 0x0, (2+1)*8, RD                 // 2 args for func(o1, o2).
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    | ldd 0, RA, 0xfffffff0, RB
    | checkfunc RB, ->vmeta_call
    | addd 0, RA, 0x0, BASE
    | ins_call
    |
    |->vmeta_len:
    | ldh 0, PC, PC_RD, RD
    | shld 0, RD, 0x3, RD
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | addd 0, BASE, RD, CARG2
    | addd 0, RB, 0x0, CARG1
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_len        // (lua_State *L, TValue *o)
    | call ctpr1, wbs = 0x8
    | // NULL (retry) or TValue * (metamethod) returned.
    | ldd 0, RB, L->base, BASE
#if LJ_52
    | cmpedb 0, CRET1, 0x0, pred0
    | disp ctpr1, ->vmeta_binop             // Binop call for compatibility.
    | ct ctpr1, ~pred0
    | ldh 0, PC, PC_RD, RD
    | shld 0, RD, 0x3, RD
    | ldd 0, BASE, RD, CARG1
    | cleartp CARG1
    | disp ctpr1, ->BC_LEN_Z
    | ct ctpr1
#else
    | disp ctpr1, ->vmeta_binop             // Binop call for compatibility.
    | ct ctpr1
#endif
    |
    |//-- Call metamethod ----------------------------------------------------
    |
    |->vmeta_call:                          // Resolve and call __call metamethod.
    | // BASE = old base, RA = new base, RD = (nargs+1)*8
    | ldd 0, STACK, SAVE_L, CARG1
    | std 2, CARG1, L->base, BASE
    | subd 0, RA, 0x10, CARG2
    | addd 0, RA, RD, CARG3
    | subd 0, CARG3, 0x8, CARG3
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_call       // (lua_State *L, TValue *func, TValue *top)
    | call ctpr1, wbs = 0x8
    | ldd 0, STACK, SAVE_L, RB
    | ldd 0, RB, L->base, BASE
    | ldd 0, RA, 0xfffffff0, RB
    | addd 0, RD, 0x8, RD
    | // This is fragile. L->base must not move, KBASE must always be defined.
    | cmpedb 0, KBASE, BASE, pred0
    | disp ctpr1, ->BC_CALLT_Z              // Continue with CALLT if flag set.
    | ct ctpr1, pred0
    | cleartp RB
    | addd 0, RA, 0x0, BASE
    | ins_call                              // Otherwise call resolved metamethod.
    |
    |//-- Argument coercion for 'for' statement ------------------------------
    |
    |->vmeta_for:
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | addd 0, RA, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_meta_for        // (lua_State *L, TValue *base)
    | call ctpr1, wbs = 0x8
    | ldd 0, RB, L->base, BASE
    | ldw 0, PC, 0xfffffffc, TMP0
    | shrd 0, TMP0, 0x5, RA
    | andd 0, RA, 0x7f8, RA
    | andd 0, TMP0, 0xff, TMP1
    | shld 0, TMP1, 0x3, TMP1
    | addd 0, DISPATCH, TMP1, TMP1
    | ldd 0, TMP1, GG_DISP2STATIC, TMP1
    | movtd 0, TMP1, ctpr1
    | ct ctpr1
    |
    |//-----------------------------------------------------------------------
    |//-- Fast functions -----------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |.macro .ffunc, name
    |->ff_ .. name:
    |.endmacro
    |
    |.macro .ffunc_1, name
    |->ff_ .. name:
    | cmpbdb 0, RD, (1+1)*8, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, pred0
    |.endmacro
    |
    |.macro .ffunc_2, name
    |->ff_ .. name:
    | cmpbdb 0, RD, (2+1)*8, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, pred0
    |.endmacro
    |
    |.macro .ffunc_n, name
    | .ffunc_1 name
    | ldd 0, BASE, 0x0, CARG1
    | checknumtp CARG1, ->fff_fallback
    |.endmacro
    |
    |.macro .ffunc_nn, name
    | .ffunc_2 name
    | ldd 0, BASE, 0x0, CARG1
    | checknumtp CARG1, ->fff_fallback
    | ldd 0, BASE, 0x8, CARG2
    | checknumtp CARG2, ->fff_fallback
    |.endmacro
    |
    |// Inlined GC threshold check.
    |.macro ffgccheck
    | ldd 0, DISPATCH, DISPATCH_GL(gc.total), RB
    | ldd 0, DISPATCH, DISPATCH_GL(gc.threshold), TMP0
    | cmpbdb 0, RB, TMP0, pred0
    | disp ctpr1, >1
    | ct ctpr1, pred0
    |
    | ldd 0, STACK, SAVE_L, RB
    | std 2, STACK, SAVE_PC, PC
    | std 2, RB, L->base, BASE
    | addd 0, BASE, RD, RD
    | subd 0, RD, 0x8, RD
    | addd 0, RB, 0x0, CARG1
    | std 2, RB, L->top, RD
    | disp ctpr1, extern lj_gc_step         // (lua_State *L)
    | call ctpr1, wbs = 0x8
    | ldd 0, RB, L->base, BASE
    | ldd 0, RB, L->top, RD
    | subd 0, RD, BASE, RD
    | addd 0, RD, 0x8, RD
    |1:
    |.endmacro
    |
    |//-- Base library: checks -----------------------------------------------
    |
    |.ffunc_1 assert
    | ldd 0, BASE, 0x0, ITYPE
    | addd 0, ITYPE, 0x0, RB
    | sard 0, ITYPE, 0x2f, ITYPE
    | cmpbsb 0, ITYPE, LJ_TISTRUECOND, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, ~pred0
    | ldd 0, BASE, 0xfffffff8, PC
    | stw 2, STACK, MULTRES, RD
    | std 2, BASE, 0xfffffff0, RB
    | subd 0, RD, 0x10, RD
    | cmpedb 0, RD, 0x0, pred0
    | disp ctpr1, >2
    | ct ctpr1, pred0
    | addd 0, BASE, 0x0, RA
    |1:
    | addd 0, RA, 0x8, RA
    | ldd 0, RA, 0x0, RB
    | std 2, RA, 0xfffffff0, RB
    | subd 0, RD, 0x8, RD
    | cmpedb 0, RD, 0x0, pred0
    | disp ctpr1, <1
    | ct ctpr1, ~pred0
    |2:
    | ldw 0, STACK, MULTRES, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc_1 type
    | ldd 0, BASE, 0x0, RC
    | sard 0, RC, 0x2f, RC
    | adds 0, 0x0, LJ_TISNUM, RB
    | cmpbsb 0, RC, RB, pred0
    | disp ctpr1, >1
    | ct ctpr1, ~pred0
    | adds 0, RB, 0x0, RC
    |1:
    | xors 0, RC, 0xffffffff, RC
    | shls 0, RC, 0x3, RC
    | sxt 0, 0x6, RC, RC
    |2:
    | ldd 0, BASE, 0xfffffff0, RB
    | cleartp RB
    | addd 0, RB, RC, TMP0
    | ldd 0, TMP0, ((char *)(&((GCfuncC *)0)->upvalue)), RC
    | ldd 0, BASE, 0xfffffff8, PC
    | settp RC, LJ_TSTR
    | std 2, BASE, 0xfffffff0, RC
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |//-- Base library: getters and setters ---------------------------------
    |
    |.ffunc_1 getmetatable
    | ldd 0, BASE, 0x0, RB
    | ldd 0, BASE, 0xfffffff8, PC
    | checktab RB, >6
    |1: // Field metatable must be at same offset for GCtab and GCudata!
    | ldd 0, RB, TAB->metatable, RB
    |2:
    | cmpedb 0, RB, 0x0, pred0
    | addd 0, 0x0, LJ_TNIL, TMP0
    | std 2, BASE, 0xfffffff0, TMP0
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1, pred0
    | settp RC, RB, LJ_TTAB
    | std 2, BASE, 0xfffffff0, RC              // Store metatable as default result.
    | ldd 0, DISPATCH, DISPATCH_GL(gcroot)+8*(GCROOT_MMNAME+MM_metatable), RC
    | ldw 0, RB, TAB->hmask, RA
    | ldw 0, RC, STR->sid, TMP0
    | andd 0, RA, TMP0, RA
    | settp RC, LJ_TSTR
    | smulx 0, RA, #NODE, RA
    | ldd 0, RB, TAB->node, TMP0
    | addd 0, RA, TMP0, RA
    |3: // Rearranged logic, because we expect _not_ to find the key.
    | ldd 0, RA, NODE->key, TMP0
    | cmpedb 0, TMP0, RC, pred0
    | disp ctpr1, >5
    | ct ctpr1, pred0
    |4:
    | ldd 0, RA, NODE->next, RA
    | cmpedb 0, RA, 0x0, pred0
    | disp ctpr1, <3
    | ct ctpr1, ~pred0
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res                 // Not found, keep default result.
    | ct ctpr1
    |5:
    | ldd 0, RA, NODE->val, RB
    | cmpedb 0, RB, LJ_TNIL, pred0
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res                 // Ditto for nil value.
    | ct ctpr1, pred0
    | std 2, BASE, 0xfffffff0, RB           // Return value of mt.__metatable.
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |6:
    | cmpesb 0, ITYPE, LJ_TUDATA, pred0
    | disp ctpr1, <1
    | ct ctpr1, pred0
    | cmpbesb 0, ITYPE, LJ_TISNUM, pred0
    | disp ctpr1, >7
    | ct ctpr1, ~pred0
    | addd 0, 0x0, LJ_TISNUM, ITYPE
    |7:
    | xord 0, ITYPE, U64x(0xffffffff,0xffffffff), ITYPE
    | shld 0, ITYPE, 0x3, TMP0
    | addd 0, TMP0, DISPATCH_GL(gcroot[GCROOT_BASEMT]), TMP0
    | ldd 0, DISPATCH, TMP0, RB
    | disp ctpr1, <2
    | ct ctpr1
    |
    |.ffunc_2 setmetatable
    | ldd 0, BASE, 0x0, RB
    | addd 0, RB, 0x0, TMP1
    | checktab RB, ->fff_fallback
    | // Fast path: no mt for table yet and not clearing the mt.
    | ldd 0, RB, TAB->metatable, TMP0
    | cmpedb 0, TMP0, 0x0, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, ~pred0
    | ldd 0, BASE, 0x8, RA
    | checktab RA, ->fff_fallback
    | std 2, RB, TAB->metatable, RA
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff0, TMP1            // Return original table.
    | ldb 0, RB, TAB->marked, TMP0
    | cmpandedb 0, TMP0, LJ_GC_BLACK, pred0    // isblack(table)
    | disp ctpr1, >1
    | ct ctpr1, pred0
    | // Possible write barrier. Table is black, but skip iswhite(mt) check.
    | barrierback RB, TMP0, TMP1
    |1:
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc_2 rawget
    | ldd 0, BASE, 0x0, CARG2
    | checktab CARG2, ->fff_fallback
    | addd 0, BASE, 0x8, CARG3
    | ldd 0, STACK, SAVE_L, CARG1
    | disp ctpr1, extern lj_tab_get         // (lua_State *L, GCtab *t, cTValue *key)
    | call ctpr1, wbs = 0x8
    | // cTValue * returned.
    | ldd 0, CRET1, 0x0, RB
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff0, RB
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |//-- Base library: conversions ------------------------------------------
    |
    |.ffunc tonumber
    | // Only handles the number case inline (without a base argument).
    | cmpedb 0, RD, (1+1)*8, pred0
    | disp ctpr1, ->fff_fallback            // Exactly one argument.
    | ct ctpr1, ~pred0
    | ldd 0, BASE, 0x0, RB
    | checknumber RB, ->fff_fallback
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff0, RB
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc_1 tostring
    | // Only handles the string or number case inline.
    | ldd 0, BASE, 0xfffffff8, PC
    | ldd 0, BASE, 0x0, RB
    | checktp_nc RB, LJ_TSTR, >3
    | // A __tostring method in the string base metatable is ignored.
    |2:
    | std 2, BASE, 0xfffffff0, RB
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |3: // Handle numbers inline, unless a number base metatable is present.
    | cmpbesb 0, ITYPE, LJ_TISNUM, pred0
    | disp ctpr1, ->fff_fallback_1
    | ct ctpr1, ~pred0
    | ldd 0, DISPATCH, DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM]), TMP0
    | cmpedb 0, TMP0, 0x0, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, ~pred0
    | ffgccheck
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE                 // Add frame since C call can throw.
    | std 2, STACK, SAVE_PC, PC                // Redundant (but a defined value).
    | addd 0, BASE, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_strfmt_num      // (lua_State *L, lua_Number *np)
    | call ctpr1, wbs = 0x8
    | // GCstr returned.
    | ldd 0, RB, L->base, BASE
    | settp RB, CRET1, LJ_TSTR
    | disp ctpr1, <2
    | ct ctpr1
    |
    |//-- Base library: iterators -------------------------------------------
    |
    |.ffunc_1 next
    | cmpedb 0, RD, (1+1)*8, pred0
    | disp ctpr1, >2                        // Missing 2nd arg?
    | ct ctpr1, pred0
    |1:
    | ldd 0, BASE, 0x0, CARG2
    | checktab CARG2, ->fff_fallback
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | std 2, RB, L->top, BASE
    | ldd 0, BASE, 0xfffffff8, PC
    | addd 0, BASE, 0x8, CARG3
    | addd 0, RB, 0x0, CARG1
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_tab_next        // (lua_State *L, GCtab *t, TValue *key)
    | call ctpr1, wbs = 0x8
    | // Flag returned.
    | ldd 0, RB, L->base, BASE
    | cmpedb 0, CRET1, 0x0, pred0
    | disp ctpr1, >3                        // End of traversal?
    | ct ctpr1, pred0
    | // Copy key and value to results.
    | ldd 0, BASE, 0x8, RB
    | ldd 0, BASE, 0x10, RD
    | std 2, BASE, 0xfffffff0, RB
    | std 2, BASE, 0xfffffff8, RD
    | addd 0, 0x0, (1+2)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |2: // Set missing 2nd arg to nil
    | addd 0, 0x0, LJ_TNIL, TMP0
    | std 2, BASE, 0x8, TMP0
    | disp ctpr1, <1
    | ct ctpr1
    |3: // End of traversal: return nil.
    | addd 0, 0x0, LJ_TNIL, TMP0
    | std 2, BASE, 0xfffffff0, TMP0
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc_1 pairs
    | ldd 0, BASE, 0x0, RB
    | addd 0, RB, 0x0, TMP1
    | checktab RB, ->fff_fallback
#if LJ_52
    | ldd 0, RB, TAB->metatable, TMP0
    | cmpedb 0, TMP0, 0x0, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, ~pred0
#endif
    | ldd 0, BASE, 0xfffffff0, RD
    | cleartp RD
    | ldd 0, RD, CFUNC->upvalue[0], RD
    | settp RD, LJ_TFUNC
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff0, RD
    | std 2, BASE, 0xfffffff8, TMP1
    | addd 0, 0x0, LJ_TNIL, TMP0
    | std 2, BASE, 0x0, TMP0
    | addd 0, 0x0, (1+3)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc_2 ipairs_aux
    | ldd 0, BASE, 0x0, RB
    | checktab RB, ->fff_fallback
    | ldd 0, BASE, 0x8, TMP0
    | checknumtp TMP0, ->fff_fallback
    | ldd 0, BASE, 0xfffffff8, PC
    | faddd 0, TMP0, U64x(0x3ff00000,0x00000000), TMP0   // +1.0e0
    | fdtoistr 0, TMP0, RA
    | std 2, BASE, 0xfffffff0, TMP0
    | ldw 0, RB, TAB->asize, TMP0
    | cmpbsb 0, RA, TMP0, pred0
    | disp ctpr1, >2                        // Not in array part?
    | ct ctpr1, ~pred0
    | ldd 0, RB, TAB->array, RD
    | sxt 0, 0x2, RA, RA
    | shld 0, RA, 0x3, RA
    | addd 0, RD, RA, RD
    |1:
    | ldw 0, RD, 0x0, TMP0
    | cmpesb 0, TMP0, LJ_TNIL, pred0
    | disp ctpr1, ->fff_res0
    | ct ctpr1, pred0
    | // Copy array slot.
    | ldd 0, RD, 0x0, RB
    | std 2, BASE, 0xfffffff8, RB
    | addd 0, 0x0, (1+2)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |2: // Check for empty hash part first. Otherwise call C function.
    | ldw 0, RB, TAB->hmask, TMP0
    | cmpedb 0, TMP0, 0x0, pred0
    | disp ctpr1, ->fff_res0
    | ct ctpr1, pred0
    | addd 0, RB, 0x0, CARG1
    | addd 0, RA, 0x0, CARG2
    | disp ctpr1, extern lj_tab_getinth     // (GCtab *t, int32_t key)
    | call ctpr1, wbs = 0x8
    | // cTValue * or NULL returned.
    | cmpedb 0, CRET1, 0x0, pred0
    | disp ctpr1, <1
    | ct ctpr1, ~pred0
    |->fff_res0:
    | addd 0, 0x0, (0+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc_1 ipairs
    | ldd 0, BASE, 0x0, RB
    | addd 0, RB, 0x0, TMP1
    | checktab RB, ->fff_fallback
#if LJ_52
    | ldd 0, RB, TAB->metatable, TMP0
    | cmpedb 0, TMP0, 0x0, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, ~pred0
#endif
    | ldd 0, BASE, 0xfffffff0, RD
    | cleartp RD
    | ldd 0, RD, CFUNC->upvalue[0], RD
    | settp RD, LJ_TFUNC
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff0, RD
    | std 2, BASE, 0xfffffff8, TMP1
    | addd 0, 0x0, 0x0, TMP0
    | std 2, BASE, 0x0, TMP0
    | addd 0, 0x0, (1+3)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |//-- Base library: catch errors ----------------------------------------
    |
    |.ffunc_1 pcall
    | addd 0, BASE, 0x10, RA
    | subd 0, RD, 0x8, RD
    | addd 0, 0x0, 16+FRAME_PCALL, PC
    |1:
    | ldb 0, DISPATCH, DISPATCH_GL(hookmask), RB
    | shrd 0, RB, HOOK_ACTIVE_SHIFT, RB
    | andd 0, RB, 0x1, RB
    | addd 0, PC, RB, PC                       // Remember active hook before pcall.
    | // Note: this does a (harmless) copy of the function to the PC slot, too.
    | addd 0, RD, 0x0, KBASE
    |2:
    | addd 0, RA, KBASE, TMP0
    | ldd 0, TMP0, 0xffffffe8, RB
    | std 2, TMP0, 0xfffffff0, RB
    | subd 0, KBASE, 0x8, KBASE
    | cmpbedb 0, KBASE, 0x0, pred0
    | disp ctpr1, <2
    | ct ctpr1, ~pred0
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    | ldd 0, RA, 0xfffffff0, RB
    | checkfunc RB, ->vmeta_call
    | addd 0, RA, 0x0, BASE
    | ins_call
    |
    |.ffunc_2 xpcall
    | ldd 0, BASE, 0x8, RA
    | checktp_nc RA, LJ_TFUNC, ->fff_fallback
    | ldd 0, BASE, 0x0, RB                     // Swap function and traceback.
    | std 2, BASE, 0x0, RA
    | std 2, BASE, 0x8, RB
    | addd 0, BASE, 0x18, RA
    | subd 0, RD, 0x10, RD
    | addd 0, 0x0, 0x18+FRAME_PCALL, PC
    | disp ctpr1, <1
    | ct ctpr1
    |
    |//-- Coroutine library --------------------------------------------------
    |
    |.macro coroutine_resume_wrap, resume
    |.if resume
    |.ffunc_1 coroutine_resume
    | ldd 0, BASE, 0x0, RB
    | cleartp RB
    |.else
    |.ffunc coroutine_wrap_aux
    | ldd 0, BASE, 0xfffffff0, RB
    | cleartp RB
    | ldd 0, RB, CFUNC->upvalue[0].gcr, RB
    | cleartp RB
    |.endif
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, STACK, SAVE_PC, PC
    | addd 0, RB, 0x0, TMP1
    |.if resume
    | ldd 0, BASE, 0x0, TMP0
    | checktptp, TMP0, LJ_TTHREAD, ->fff_fallback
    |.endif
    | disp ctpr1, ->fff_fallback
    | ldd 0, RB, L->cframe, TMP0
    | cmpedb 0, TMP0, 0x0, pred0
    | ct ctpr1, ~pred0
    | ldb 0, RB, L->status, TMP0
    | cmpbedb 0, TMP0, LUA_YIELD, pred0
    | ct ctpr1, ~pred0
    | ldd 0, RB, L->top, RA
    | cmpedb 0, TMP0, LUA_YIELD, pred0
    | disp ctpr1, >1                        // Status != LUA_YIELD (i.e. 0)?
    | ct ctpr1, pred0
    | ldd 0, RB, L->base, TMP0
    | cmpbedb 0, RA, TMP0, pred0               // Check for presence of initial func.
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, pred0
    | ldd 0, RA, 0xfffffff8, PC                // Move initial function up.
    | std 2, RA, 0x0, PC
    | addd 0, RA, 0x8, RA
    |1:
    |.if resume
    | addd 0, RA, RD, PC                       // Check stack space (-1-thread).
    | subd 0, PC, 0x10, PC
    |.else
    | addd 0, RA, RD, PC                       // Check stack space (-1).
    | subd 0, PC, 0x8, PC
    |.endif
    | ldd 0, RB, L->maxstack, TMP0
    | cmpbedb 0, PC, TMP0, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, ~pred0
    | std 2, RB, L->top, PC
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    |.if resume
    | addd 0, BASE, 0x8, BASE                  // Keep resumed thread in stack for GC.
    |.endif
    | std 2, RB, L->top, BASE
    |.if resume
    | addd 0, BASE, RD, RB                     // RB = end of source for stack move.
    | subd 0, RB, 0x18, RB
    |.else
    | addd 0, BASE, RD, RB                     // RB = end of source for stack move.
    | subd 0, RB, 0x10, RB
    |.endif
    | subd 0, RB, PC, RB                       // Relative to PC.
    | cmpedb 0, PC, RA, pred0
    | disp ctpr1, >3
    | ct ctpr1, pred0
    |2: // Move args to coroutine.
    | ldd 0, PC, RB, RC
    | std 2, PC, 0xfffffff8, RC
    | subd 0, PC, 0x8, PC
    | cmpedb 0, PC, RA, pred0
    | disp ctpr1, <2
    | ct ctpr1, ~pred0
    |3:
    | addd 0, RA, 0x0, CARG2
    | addd 0, TMP1, 0x0, CARG1
    | disp ctpr1, ->vm_resume               // (lua_State *L, TValue *base, 0, 0)
    | call ctpr1, wbs = 0x8
    | ldd 0, STACK, SAVE_L, RB
    | addd 0, TMP1, 0x0, PC
    | ldd 0, RB, L->base, BASE
    | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
    | set_vmstate INTERP
    | cmpbedb 0, CRET1, LUA_YIELD, pred0
    | disp ctpr1, >8
    | ct ctpr1, ~pred0
    |4:
    | ldd 0, PC, L->base, RA
    | ldd 0, PC, L->top, KBASE
    | std 2, PC, L->top, RA                    // Clear coroutine stack.
    | addd 0, KBASE, 0x0, PC
    | subd 0, PC, RA, PC
    | cmpedb 0, PC, 0x0, pred0
    | disp ctpr1, >6                        // No results?
    | ct ctpr1, pred0
    | addd 0, BASE, PC, RD
    | ldd 0, RB, L->maxstack, TMP0
    | cmpbedb 0, RD, TMP0, pred0
    | disp ctpr1, >9                        // Need to grow stack?
    | ct ctpr1, ~pred0
    | addd 0, BASE, 0x0, RB
    | subd 0, RB, RA, RB
    |5: // Move results from coroutine.
    | ldd 0, RA, 0x0, RD
    | std 2, RA, RB, RD
    | addd 0, RA, 0x8, RA
    | cmpedb 0, RA, KBASE, pred0
    | disp ctpr1, <5
    | ct ctpr1, ~pred0
    |6:
    |.if resume
    | addd 0, PC, (1+1)*8, RD                  // (nresults+1)*8 = (1 + true)*8 + results*8.
    | mov_true ITYPE                        // Prepend true to results.
    | std 2, BASE, 0xfffffff8, ITYPE
    |.else
    | addd 0, PC, 1*8, RD                      // (nresults+1)*8 = 8 + results*8.
    |.endif
    |7:
    | ldd 0, STACK, SAVE_PC, PC
    | stw 2, STACK, MULTRES, RD
    |.if resume
    | subd 0, 0x0, 0x8, RA
    |.else
    | addd 0, 0x0, 0x0, RA
    |.endif
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | disp ctpr1, ->BC_RET_Z
    | ct ctpr1, pred0
    | disp ctpr1, ->vm_return
    | ct ctpr1
    |8: // Coroutine returned with error (at co->top-1).
    |.if resume
    | mov_false ITYPE                       // Prepend false to results.
    | std 2, BASE, 0xfffffff8, ITYPE
    | ldd 0, PC, L->top, RA
    | subd 0, RA, 0x8, RA
    | std 2, PC, L->top, RA                    // Clear error from coroutine stack.
    | // Copy error message.
    | ldd 0, RA, 0x0, RD
    | std 2, BASE, 0x0, RD
    | addd 0, 0x0, (1+2)*8, RD                 // (nresults+1)*8 = (1 + false + error)*8.
    | disp ctpr1, <7
    | ct ctpr1
    |.else
    | addd 0, PC, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_ffh_coroutine_wrap_err // (lua_State *L, lua_State *co)
    | call ctpr1, wbs = 0x8
    | // Error function does not return.
    |.endif
    |9:  // Handle stack expansion on return from yield.
    | addd 0, TMP1, 0x0, RA
    | std 2, RA, L->top, KBASE                 // Undo coroutine stack clearing.
    | shrd 0, PC, 0x3, PC
    | addd 0, PC, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    | call ctpr1, wbs = 0x8
    | addd 0, TMP1, 0x0, PC
    | ldd 0, RB, L->base, BASE
    | disp ctpr1, <4                        // Retry the stack move.
    | ct ctpr1
    |.endmacro
    |
    | coroutine_resume_wrap 1        // coroutine.resume
    | coroutine_resume_wrap 0        // coroutine.wrap
    |
    |.ffunc coroutine_yield
    | ldd 0, STACK, SAVE_L, RB
    | ldd 0, RB, L->cframe, TMP0
    | cmpandedb 0, TMP0, CFRAME_RESUME, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, pred0
    | std 2, RB, L->base, BASE
    | addd 0, BASE, RD, RD
    | subd 0, RD, 0x8, RD
    | std 2, RB, L->top, RD
    | addd 0, 0x0, 0x0, RD
    | std 2, RB, L->cframe, RD
    | addd 0, 0x0, LUA_YIELD, RRET1
    | stb 2, RB, L->status, RRET1
    | return ctpr3
    | ct ctpr3
    |
    |//-- Math library -------------------------------------------------------
    |
    |.ffunc_1 math_abs
    | ldd 0, BASE, 0x0, RB
    | checknum RB, ->fff_fallback
    | shld 0, RB, 0x1, RB
    | shrd 0, RB, 0x1, RB
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff0, RB
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc_n math_sqrt
    | fsqrtid 5, CARG1, TMP1
    | fsqrttd 5, CARG1, TMP1, TMP0
    | // fallthrough
    |
    |->fff_resb:
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff0, TMP0
    | addd 0, 0x0, (1+1)*8, RD
    | // fallthrough
    |
    |->fff_res:
    |<
    | cmpandedb 0, PC, FRAME_TYPE, pred0
    | ldbsm 2, PC, 0x0, CARG4
    | addd 3, 0x0, LJ_TNIL, TMP1
    | stw 5, STACK, MULTRES, RD
    | disp ctpr1, ->vm_return
    |>
    |<
    | ldb 3, PC, PC_RB, RB, pred0
    | ldw 5, PC, 0x0, CARG3, pred0
    | disp ctpr2, >2
    | nop 1
    |>
    | ldb 3, PC, PC_RA, RA, pred0
    |<
    | shld 0, CARG4, 0x3, CARG4, pred0
    | addd 1, PC, 0x4, PC, pred0
    | subd 3, 0x0, 0x10, RA, ~pred0         // Results start at BASE+RA = BASE-16
    | shld 4, RB, 0x3, RB, pred0
    | disp ctpr3, >1
    |>
    |<
    | ldd 0, CARG4, DISPATCH, CARG4, pred0
    | cmpbedbsm 3, RB, RD, pred1            // More results expected?
    | ct ctpr1, ~pred0                      // Non-standard return case.
    |>
    |<
    | shld 3, RA, 0x3, CARG5
    | ct ctpr2, pred1
    |>
    |1:                                     // Fill up results with nil.
    |<
    | subd 3, RD, 0x18, TMP0
    | addd 4, RD, 0x8, RD
    |>
    |<
    | cmpbedb 3, RB, RD, pred1
    | std 5, BASE, TMP0, TMP1
    |>
    | ct ctpr3, ~pred1
    |2:
    |<
    | movtd 0, CARG4, ctpr1
    | subd 3, BASE, 0x10, BASE
    |>
    |<
    | shrd 3, CARG3, 0x5, RA
    | shrd 4, CARG3, 0x15, RB
    | shrd 5, CARG3, 0xd, RD
    |>
    |<
    | subd 3, BASE, CARG5, BASE                   // base = base - (RA+2)*8
    | andd 4, RD, 0x7fff8, RD
    | andd 5, RA, 0x7f8, RA
    |>
    |<
    | andd 3, RB, 0x7f8, RB
    | andd 4, RD, 0x7f8, RC
    | ct ctpr1
    |>
    |
    |.macro math_round, func
    |.ffunc math_ .. func
    | ldd 0, BASE, 0x0, CARG1
    | checknumtp CARG1, ->fff_fallback
    | disp ctpr1, ->vm_ .. func
    | call ctpr1, wbs = 0x8
    | addd 0, CRET1, 0x0, TMP0
    | disp ctpr1, ->fff_resb
    | ct ctpr1
    |.endmacro
    |
    | math_round floor
    | math_round ceil
    |
    |.ffunc math_log
    | cmpedb 0, RD, (1+1)*8, pred0
    | disp ctpr1, ->fff_fallback            // Exactly one argument.
    | ct ctpr1, ~pred0
    | ldd 0, BASE, 0x0, CARG1
    | checknumtp CARG1, ->fff_fallback
    | disp ctpr1, extern log
    | call ctpr1, wbs = 0x8
    | addd 0, CRET1, 0x0, TMP0
    | disp ctpr1, ->fff_resb
    | ct ctpr1
    |
    |.macro math_extern, func
    |.ffunc_n math_ .. func
    | disp ctpr1, extern func
    | call ctpr1, wbs = 0x8
    | addd 0, CRET1, 0x0, TMP0
    | disp ctpr1, ->fff_resb
    | ct ctpr1
    |.endmacro
    |
    |.macro math_extern2, func
    |.ffunc_nn math_ .. func
    | disp ctpr1, extern func
    | call ctpr1, wbs = 0x8
    | addd 0, CRET1, 0x0, TMP0
    | disp ctpr1, ->fff_resb
    | ct ctpr1
    |.endmacro
    |
    | math_extern log10
    | math_extern exp
    | math_extern sin
    | math_extern cos
    | math_extern tan
    | math_extern asin
    | math_extern acos
    | math_extern atan
    | math_extern sinh
    | math_extern cosh
    | math_extern tanh
    | math_extern2 pow
    | math_extern2 atan2
    | math_extern2 fmod
    |
    |.ffunc_2 math_ldexp
    | ldd 0, BASE, 0x0, TMP0
    | ldd 0, BASE, 0x8, TMP1
    | checknumtp TMP0, ->fff_fallback
    | checknumtp TMP1, ->fff_fallback
    | fdtoidtr 0, TMP1, TMP1
    | fscaled 1, TMP0, TMP1, TMP0
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff0, TMP0
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc_n math_frexp
    | addd 0, STACK, STACK_TMP, CARG2
    | disp ctpr1, extern frexp
    | call ctpr1, wbs = 0x8
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff0, CRET1
    | ldw 0, STACK, STACK_TMP, TMP0
    | istofd 0, TMP0, TMP0
    | std 2, BASE, 0xfffffff8, TMP0
    | addd 0, 0x0, (1+2)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc_n math_modf
    | subd 0, BASE, 0x10, CARG2
    | disp ctpr1, extern modf
    | call ctpr1, wbs = 0x8
    | ldd 0, BASE, 0xfffffff8, PC
    | std 2, BASE, 0xfffffff8, CRET1
    | addd 0, 0x0, (1+2)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.macro math_minmax, name, ins
    | .ffunc_1 name
    | addd 0, 0x0, 0x10, RA
    | ldd 0, BASE, 0x0, TMP0
    | checknumtp TMP0, ->fff_fallback
    |1: //  Handle numbers or integers.
    | cmpbsb 0, RA, RD, pred0
    | disp ctpr1, ->fff_resb
    | ct ctpr1, ~pred0
    | addd 0, BASE, RA, TMP1
    | ldd 0, TMP1, 0xfffffff8, TMP1
    | checknumtp TMP1, ->fff_fallback
    | ins 0, TMP0, TMP1, TMP0
    | addd 0, RA, 0x8, RA
    | disp ctpr1, <1
    | ct ctpr1
    |.endmacro
    |
    | math_minmax math_min, fmind
    | math_minmax math_max, fmaxd
    |
    |//-- String library -----------------------------------------------------
    |
    |.ffunc string_byte                     // Only handle the 1-arg case here.
    | cmpedb 0, RD, (1+1)*8, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, ~pred0
    | ldd 0, BASE, 0x0, RB
    | checkstr RB, ->fff_fallback
    | ldd 0, BASE, 0xfffffff8, PC
    | ldw 0, RB, STR->len, TMP0
    | cmpbsb 0, TMP0, 0x1, pred0
    | disp ctpr1, ->fff_res0                // Return no results for empty string.
    | ct ctpr1, pred0
    | ldb 0, RB, STR[1], RB
    | istofd 0, RB, TMP0
    | disp ctpr1, ->fff_resb
    | ct ctpr1
    |
    |.ffunc string_char                     // Only handle the 1-arg case here.
    | ffgccheck
    | cmpedb 0, RD, (1+1)*8, pred0
    | disp ctpr1, ->fff_fallback            // *Exactly* 1 arg.
    | ct ctpr1, ~pred0
    | ldd 0, BASE, 0x0, TMP0
    | checknumtp TMP0, ->fff_fallback
    | fdtoistr 0, TMP0, RB
    | cmpbesb 0, RB, 255, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, ~pred0
    | stw 2, STACK, STACK_TMP, RB
    | addd 0, 0x0, 0x1, TMP1
    | addd 0, STACK, STACK_TMP, RD                 // Points to stack. Little-endian.
    |->fff_newstr:
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | sxt 0, 0x2, TMP1, CARG3               // Zero-extended to size_t.
    | addd 0, RD, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_str_new         // (lua_State *L, char *str, size_t l)
    | call ctpr1, wbs = 0x8
    | // GStr * returned.
    | ldd 0, RB, L->base, BASE
    | ldd 0, BASE, 0xfffffff8, PC
    | settp CRET1, LJ_TSTR
    | std 2, BASE, 0xfffffff0, CRET1
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |
    |.ffunc string_sub
    | ffgccheck
    | adds 0, 0x0, 0xffffffff, TMP1
    | cmpbdb 0, RD, (1+2)*8, pred0
    | disp ctpr1, ->fff_fallback
    | ct ctpr1, pred0
    | cmpbedb 0, RD, (1+2)*8, pred0
    | disp ctpr1, >2
    | ct ctpr1, pred0
    | ldd 0, BASE, 0x10, TMP0
    | checknumtp TMP0, ->fff_fallback
    | fdtoistr 0, TMP0, TMP1
    |2:
    | ldd 0, BASE, 0x0, RB
    | checkstr RB, ->fff_fallback
    | ldd 0, BASE, 0x8, TMP0
    | checknumtp TMP0, ->fff_fallback
    | addd 0, 0x0, 0x0, RA
    | fdtoistr 0, TMP0, RA
    | ldw 0, RB, STR->len, RC
    | cmpbsb 0, RC, TMP1, pred0
    | disp ctpr1, >6                        // len < end? (unsigned compare)
    | ct ctpr1, pred0
    |3:
    | cmplesb 0, RA, 0x0, pred0
    | disp ctpr1, >8                        // start <= 0?
    | ct ctpr1, pred0
    |4:
    | subs 0, TMP1, RA, TMP1
    | cmplsb 0, TMP1, 0x0, pred0
    | disp ctpr1, ->fff_emptystr            // start > end?
    | ct ctpr1, pred0
    | addd 0, RB, RA, RD
    | addd 0, RD, #STR-1, RD
    | adds 0, TMP1, 0x1, TMP1
    |5:
    | disp ctpr1, ->fff_newstr
    | ct ctpr1
    |6: // Negative end or overflow.
    | cmplsb 0, RC, TMP1, pred0
    | disp ctpr1, >7
    | ct ctpr1, pred0
    | adds 0, TMP1, RC, TMP1                   // end = end+(len+1)
    | adds 0, TMP1, 0x1, TMP1
    | disp ctpr1, <3
    | ct ctpr1
    |7: // Overflow.
    | adds 0, RC, 0x0, TMP1                    // end = len
    | disp ctpr1, <3
    | ct ctpr1
    |8: // Negative start or underflow.
    | cmpesb 0, RA, 0x0, pred0
    | disp ctpr1, >9
    | ct ctpr1, pred0
    | adds 0, RA, RC, RA                       // start = start+(len+1)
    | adds 0, RA, 0x1, RA
    | cmplesb 0, RA, 0x0, pred0
    | disp ctpr1, <4                        // start >0?
    | ct ctpr1, ~pred0
    |9: // Underflow.
    | adds 0, 0x0, 0x1, RA                     // start = 1
    | disp ctpr1, <4
    | ct ctpr1
    |
    |->fff_emptystr:                        // Range underflow.
    | xors 0, TMP1, TMP1, TMP1                 // Zero length. Any ptr in RD is ok.
    | disp ctpr1, <5
    | ct ctpr1
    |
    |.macro ffstring_op, name
    | .ffunc_1 string_ .. name
    | ffgccheck
    | ldd 0, BASE, 0x0, CARG2
    | checkstr CARG2, ->fff_fallback
    | ldd 0, STACK, SAVE_L, RB
    | addd 0, DISPATCH, DISPATCH_GL(tmpbuf), CARG1
    | std 2, RB, L->base, BASE
    | ldd 0, CARG1, SBUF->b, RC
    | std 2, CARG1, SBUF->L, RB
    | std 2, CARG1, SBUF->p, RC
    | std 2, STACK, SAVE_PC, PC
    | disp ctpr1, extern lj_buf_putstr_ .. name
    | call ctpr1, wbs = 0x8
    | addd 0, CRET1, 0x0, CARG1
    | disp ctpr1, extern lj_buf_tostr
    | call ctpr1, wbs = 0x8
    | // GStr * returned.
    | ldd 0, RB, L->base, BASE
    | ldd 0, BASE, 0xfffffff8, PC
    | settp CRET1, LJ_TSTR
    | std 2, BASE, 0xfffffff0, CRET1
    | addd 0, 0x0, (1+1)*8, RD
    | disp ctpr1, ->fff_res
    | ct ctpr1
    |.endmacro
    |
    | ffstring_op reverse
    | ffstring_op lower
    | ffstring_op upper
    |
    |//-- Bit library --------------------------------------------------------
    |
    |.macro .ffunc_bit, name, fdef
    | fdef bit_ .. name
    | ldd 0, BASE, 0x0, TMP0
    | checknumtp TMP0, ->fff_fallback
    | faddd 0, TMP0, U64x(0x43380000,0x00000000), TMP0
    | adds 0, TMP0, 0x0, RB
    |.endmacro
    |
    |.macro .ffunc_bit_op, name, ins
    | .ffunc_bit name, .ffunc_1
    | addd 0, RD, 0x0, TMP1                    // Save for fallback.
    | addd 0, BASE, RD, RD
    | subd 0, RD, 0x10, RD
    |1:
    | istofd 0, RB, TMP0
    | cmpbedb 0, RD, BASE, pred0
    | disp ctpr1, ->fff_resb
    | ct ctpr1, pred0
    | ldd 0, RD, 0x0, TMP0
    | checknumtp TMP0, ->fff_fallback_bit_op
    | faddd 0, TMP0, U64x(0x43380000,0x00000000), TMP0
    | adds 0, TMP0, 0x0, RA
    | ins 0, RB, RA, RB
    | subd 0, RD, 0x8, RD
    | disp ctpr1, <1
    | ct ctpr1
    |.endmacro
    |
    |.ffunc_bit_op band, ands
    |.ffunc_bit_op bor, ors
    |.ffunc_bit_op bxor, xors
    |
    |.ffunc_bit tobit, .ffunc_1
    | istofd 0, RB, TMP0
    | disp ctpr1, ->fff_resb
    | ct ctpr1
    |
    |.ffunc_bit bswap, .ffunc_1
    | sxt 0, 0x6, RB, RB
    | addd 0, 0x0, U64x(0x80808080,0x00010203), TMP0
    | pshufb 0, RB, RB, TMP0, RB
    | istofd 0, RB, TMP0
    | disp ctpr1, ->fff_resb
    | ct ctpr1
    |
    |.ffunc_bit bnot, .ffunc_1
    | xors 0, RB, 0xffffffff, RB
    | istofd 0, RB, TMP0
    | disp ctpr1, ->fff_resb
    | ct ctpr1
    |
    |->fff_fallback_bit_op:
    | addd 0, TMP1, 0x0, RD                    // Restore for fallback
    | disp ctpr1, ->fff_fallback
    | ct ctpr1
    |
    |.macro .ffunc_bit_sh, name, ins
    | .ffunc_nn bit_..name
    | faddd 0, CARG1, U64x(0x43380000,0x00000000), TMP0
    | faddd 0, CARG2, U64x(0x43380000,0x00000000), TMP1
    | adds 0, TMP0, 0x0, RB
    | adds 0, TMP1, 0x0, RA
    | ands 0, RA, 0xff, RA
    | ins 0, RB, RA, RB
    | istofd 0, RB, TMP0
    | disp ctpr1, ->fff_resb
    | ct ctpr1
    |.endmacro
    |
    |.ffunc_bit_sh lshift, shls
    |.ffunc_bit_sh rshift, shrs
    |.ffunc_bit_sh arshift, sars
    |.ffunc_bit_sh rol, scls
    |.ffunc_bit_sh ror, scrs
    |
    |//-----------------------------------------------------------------------
    |
    |->fff_fallback_1:
    | addd 0, 0x0, (1+1)*8, RD                 // Other args are ignored, anyway.
    |->fff_fallback:                        // Call fast function fallback handler.
    | // BASE = new base, RD = (nargs+1)*8
    | ldd 0, STACK, SAVE_L, RB
    | ldd 0, BASE, 0xfffffff8, PC              // Fallback may overwrite PC.
    | std 2, STACK, SAVE_PC, PC                // Redundant (but a defined value).
    | std 2, RB, L->base, BASE
    | addd 0, BASE, RD, RD
    | subd 0, RD, 0x8, RD
    | addd 0, RD, 8*LUA_MINSTACK, RA           // Ensure enough space for handler.
    | std 2, RB, L->top, RD
    | ldd 0, BASE, 0xfffffff0, RD
    | cleartp RD
    | ldd 0, RB, L->maxstack, TMP0
    | cmpbedb 0, RA, TMP0, pred0
    | disp ctpr1, >5                        // Need to grow stack.
    | ct ctpr1, ~pred0
    | addd 0, RB, 0x0, CARG1
    | ldd 0, RD, CFUNC->f, TMP0
    | movtd 0, TMP0, ctpr1
    | call ctpr1, wbs = 0x8                 // (lua_State *L)
    | // Either throws an error, or recovers and returns -1, 0 or nresults+1.
    | ldd 0, RB, L->base, BASE
    | shld 0, CRET1, 0x3, RD
    | cmpledb 0, CRET1, 0x0, pred0
    | disp ctpr1, ->fff_res                 // Returned nresults+1?
    | ct ctpr1, ~pred0
    |1:
    | ldd 0, RB, L->top, RA
    | subd 0, RA, BASE, RA
    | cmpedb 0, CRET1, 0x0, pred0
    | addd 0, RA, 0x8, RD
    | ldd 0, BASE, 0xfffffff0, RB
    | disp ctpr1, ->vm_call_tail            // Returned -1?
    | ct ctpr1, ~pred0
    | cleartp RB
    | ins_callt                             // Returned 0: retry fast path.
    |
    |// Reconstruct previous base for vmeta_call during tailcall.
    |->vm_call_tail:
    | addd 0, BASE, 0x0, RA
    | cmpandesb 0, PC, FRAME_TYPE, pred0
    | disp ctpr1, >3
    | ct ctpr1, ~pred0
    | ldb 0, PC, PC_RA, RB
    | subd 0, 0x0, RB, RB
    | shld 0, RB, 0x3, TMP0
    | addd 0, BASE, TMP0, BASE
    | subd 0, BASE, 0x10, BASE                 // base = base - (RB+2)*8
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    | ldd 0, RA, 0xfffffff0, RB
    | checkfunc RB, ->vmeta_call
    | addd 0, RA, 0x0, BASE
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |3:
    | addd 0, PC, 0x0, RB
    | andd 0, RB, 0xfffffff8, RB
    | subd 0, BASE, RB, BASE
    | // BASE = old base, RA = new base, RD = (nargs+1)*8, PC = caller PC
    | ldd 0, RA, 0xfffffff0, RB
    | checkfunc RB, ->vmeta_call
    | addd 0, RA, 0x0, BASE
    | ins_call
    | // BASE = new base, RB = func, RD = (nargs+1)*8, PC = caller PC
    |5: // Grow stack for fallback handler.
    | addd 0, 0x0, LUA_MINSTACK, CARG2
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
    | call ctpr1, wbs = 0x8
    | ldd 0, RB, L->base, BASE
    | addd 0, 0x0, 0x0, CRET1                  // Simulate a return 0.
    | disp ctpr1, <1                        // Dumb retry (goes through ff first).
    | ct ctpr1
    |
    |//-----------------------------------------------------------------------
    |//-- Special dispatch targets -------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->vm_record:                           // Dispatch target for recording phase.
    | do_fault
    |
    |->vm_rethook:                          // Dispatch target for return hooks.
    | ldb 0, DISPATCH, DISPATCH_GL(hookmask), RD
    | cmpandedb 0, RD, HOOK_ACTIVE, pred0
    | disp ctpr1, >5                        // Hook already active?
    | ct ctpr1, ~pred0
    | disp ctpr1, >1
    | ct ctpr1
    |
    |->vm_inshook:                          // Dispatch target for instr/line hooks.
    | ldb 0, DISPATCH, DISPATCH_GL(hookmask), RD
    | cmpandedb 0, RD, HOOK_ACTIVE, pred0
    | disp ctpr1, >5                        // Hook already active?
    | ct ctpr1, ~pred0
    | cmpandedb 0, RD, LUA_MASKLINE|LUA_MASKCOUNT, pred0
    | disp ctpr1, >5
    | ct ctpr1, pred0
    | ldw 0, DISPATCH, DISPATCH_GL(hookcount), TMP0
    | subd 0, TMP0, 0x1, TMP0
    | stw 2, DISPATCH, DISPATCH_GL(hookcount), TMP0
    | cmpedb 0, TMP0, 0x0, pred0
    | disp ctpr1, >1
    | ct ctpr1, pred0
    | cmpandedb 0, RD, LUA_MASKLINE, pred0
    | disp ctpr1, >5
    | ct ctpr1, pred0
    |1:
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | addd 0, PC, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
    | disp ctpr1, extern lj_dispatch_ins    // (lua_State *L, const BCIns *pc)
    | call ctpr1, wbs = 0x8
    |3:
    | ldd 0, RB, L->base, BASE
    |4:
    | ldb 0, PC, PC_RA, RA
    | shld 0, RA, 0x3, RA
    |5:
    | ldb 0, PC, PC_OP, TMP1
    | shld 0, TMP1, 0x3, TMP1
    | ldh 0, PC, PC_RD, RD
    | shrd 0, RD, 0x5, RB
    | shld 0, RD, 0x3, RD
    | andd 0, RB, 0x7f8, RB
    | andd 0, RD, 0x7f8, RC
    | addd 0, DISPATCH, TMP1, TMP1
    | ldd 0, TMP1, GG_DISP2STATIC, TMP1
    | movtd 0, TMP1, ctpr1
    | ct ctpr1
    |
    |->cont_hook:                           // Continue from hook yield.
    | do_fault
    |
    |->vm_callhook:                         // Dispatch target for call hooks.
    | std 2, STACK, SAVE_PC, PC
    |
    |->vm_hotcall:                          // Hot call counter underflow.
    | addd 0, BASE, RD, RD
    | subd 0, RD, 0x8, RD
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | std 2, RB, L->top, RD
    | addd 0, PC, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_dispatch_call   // (lua_State *L, const BCIns *pc)
    | call ctpr1, wbs = 0x8
    | // ASMFunction returned.
    | addd 0, 0x0, 0x0, TMP0
    | std 2, STACK, SAVE_PC, TMP0              // Invalidate for subsequent line hook.
    | ldd 0, RB, L->base, BASE
    | addd 0, CRET1, 0x0, RA
    | ldd 0, RB, L->top, RD
    | subd 0, RD, BASE, RD
    | movtd 0, RA, ctpr1
    | ldb 0, PC, PC_RA, RA
    | shld 0, RA, 0x3, RA
    | addd 0, RD, 0x8, RD
    | ct ctpr1
    |
    |->vm_profhook:                         // Dispatch target for profiler hook.
#if LJ_HASPROFILE
    | ldd 0, STACK, SAVE_L, RB
    | std 2, RB, L->base, BASE
    | addd 0, PC, 0x0, CARG2
    | addd 0, RB, 0x0, CARG1
    | disp ctpr1, extern lj_dispatch_profile // (lua_State *L, const BCIns *pc)
    | call ctpr1, wbs = 0x8
    | ldd 0, RB, L->base, BASE
    | // HOOK_PROFILE is off again, so re-dispatch to dynamic instruction.
    | subd 0, PC, 0x4, PC
    | ins_next
#endif
    |
    |//-----------------------------------------------------------------------
    |//-- Trace exit handler -------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    | // Unsupported
    |
    |//-----------------------------------------------------------------------
    |//-- Math helper functions ----------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |// FP value rounding. Called by math.floor/math.ceil fast functions.
    |.macro vm_round, name, mode
    |->name:
    | set_frame_4
    | andd 0, RARG1, U64x(0x80000000,0x00000000), RARG2 // Isolate sign bit.
    | andd 0, RARG1, U64x(0x7fffffff,0xffffffff), RARG3 // |x|
    | fcmpnltdb 0, RARG3, U64x(0x43300000,0x00000000), pred0 // No truncation if |x| >= 2^52.
    | disp ctpr1, >3
    | ct ctpr1, pred0
    |.if mode == 2                          // trunc(x)?
    | faddd 0, RARG3, U64x(0x43300000,0x00000000), RARG4 // (|x| + 2^52) - 2^52
    | fsubd 0, RARG4, U64x(0x43300000,0x00000000), RARG4
    | fcmpltdb 0, RARG3, RARG4, pred0          // |x| < result?
    | disp ctpr1, >1
    | ct ctpr1, ~pred0
    | fsubd 0, RARG4, U64x(0x3ff00000,0x00000000), RARG4 // if yes, substruct -1.
    |1:
    | ord 0, RARG4, RARG2, RARG4               // Merge sign bit back in.
    |.else
    | faddd 0, RARG3, U64x(0x43300000,0x00000000), RARG4 // (|x| + 2^52) - 2^52
    | fsubd 0, RARG4, U64x(0x43300000,0x00000000), RARG4
    | ord 0, RARG4, RARG2, RARG4               // Merge sign bit back in.
    | .if mode == 1                         // ceil(x)?
    |  fcmpnledb 0, RARG1, RARG4, pred0        // x > result?
    |  addd 0, 0x0, U64x(0xbff00000,0x00000000), RARG2
    | .else                                 // floor(x)?
    |  fcmpltdb 0, RARG1, RARG4, pred0         // x < result?
    |  addd 0, 0x0, U64x(0x3ff00000,0x00000000), RARG2
    | .endif
    | disp ctpr1, >2
    | ct ctpr1, ~pred0
    | fsubd 0, RARG4, RARG2, RARG4             // If yes, substruct +-1.
    |.endif
    |2:
    | addd 0, RARG4, 0x0, RRET1
    |3:
    | return ctpr3
    | ct ctpr3
    |.endmacro
    |
    | vm_round vm_floor, 0
    | vm_round vm_ceil,  1
    | vm_round vm_trunc, 2
    |
    |// modulo x%y. Called by BC_MOD* and vm_arith.
    |->vm_mod:
    | set_frame_4
    | fdivd 5, RARG1, RARG2, RARG3
    | andd 0, RARG3, U64x(0x7fffffff,0xffffffff), RARG4 // |x/y|
    | fcmpnltdb 0, RARG4, U64x(0x43300000,0x00000000), pred0 // |x/y| >= 2^52
    | disp ctpr1, >2
    | ct ctpr1, pred0
    | andd 0, RARG3, U64x(0x80000000,0x00000000), RARG5 // Isolate sign bit.
    | faddd 0, RARG4, U64x(0x43300000,0x00000000), RARG4 // (|x/y| + 2^52) - 2^52
    | fsubd 0, RARG4, U64x(0x43300000,0x00000000), RARG4
    | ord 0, RARG4, RARG5, RARG4               // Merge sign bit back in.
    | fcmpltdb 0, RARG3, RARG4, pred0
    | disp ctpr1, >1                        // x/y < result?
    | ct ctpr1, ~pred0
    | fsubd 0, RARG4, U64x(0x3ff00000,0x00000000), RARG4 // If yes, subtract 1.0.
    |1:
    | fmuld 0, RARG2, RARG4, RARG2
    | fsubd 0, RARG1, RARG2, RRET1
    | return ctpr3
    | ct ctpr3
    |2:
    | fmuld 0, RARG2, RARG3, RARG2
    | fsubd 0, RARG1, RARG2, RRET1
    | return ctpr3
    | ct ctpr3
    |
    |//-----------------------------------------------------------------------
    |//-- Miscellaneous functions --------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |//-----------------------------------------------------------------------
    |//-- Assertions ---------------------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |->assert_bad_for_arg_type:
    | addd 0, 0x5, 0x0, CARG1
    | disp ctpr1, extern raise              // sigtrap
    | call ctpr1, wbs = 0x8
    |
    |//-----------------------------------------------------------------------
    |//-- FFI helper functions -----------------------------------------------
    |//-----------------------------------------------------------------------
    |
    |// Handler for callback functions.
    |->vm_ffi_callback:
    |.if FFI
    | .type CTSTATE, CTState
    | // unsupported ??
    | addd 0, 0x0, 0x0, TMP0
    |.endif
    |
    |->cont_ffi_callback:                   // Return from FFI callback.
    |.if FFI
    | ldd 0, STACK, SAVE_L, RA
    | ldd 0, DISPATCH, DISPATCH_GL(ctype_state), PC
    | std 2, PC, CTSTATE->L, RA
    | std 2, RA, L->base, BASE
    | std 2, RA, L->top, RB
    | addd 0, PC, 0x0, CARG1
    | addd 0, CRET1, 0x0, CARG2
    | disp ctpr1, extern lj_ccallback_leave // (CTState *cts, TValue *o)
    | call ctpr1, wbs = 0x8
    | ldd 0, PC, CTSTATE->cb.gpr[0], RRET1
    | return ctpr3
    | ct ctpr3
    |.endif
    |
    |->vm_ffi_call:                         // Call C function via FFI.
    |.if FFI
    | setwd wsz = 0x8, nfx = 0x1, dbl = 0x0
    | setbn rsz = 0x3, rbs = 0x4, rcur = 0x0
    | .type CCSTATE, CCallState
    | ldw 0, RARG1, CCSTATE->spadj, RARG3
    | subd 0, 0x0, RARG3, RARG3
    | getsp 0, RARG3, RARG4                    // allocate stack for parameters and return value
    |
    | // Copy stack slots.
    | ldb 0, RARG1, CCSTATE->nsp, RARG5
    | subd 0, RARG5, 0x1, RARG5
    | cmpldb 0, RARG5, 0x0, pred0
    | disp ctpr1, >2
    | ct ctpr1, pred0
    | shld 0, RARG5, 0x3, RARG5
    |1:
    | addd 0, RARG5, 0x40, RARG2
    | addd 0, RARG1, offsetof(CCallState, stack), RARG6
    | ldd 0, RARG6, RARG5, RARG6               // read stack parameters
    | std 2, RARG4, RARG2, RARG6               // write to allocated stack
    | subd 0, RARG5, 0x8, RARG5
    | cmpldb 0, RARG5, 0x0, pred0
    | disp ctpr1, <1
    | ct ctpr1, ~pred0
    |2: // wrire register parameters on stack too
    | ldd 0, RARG1, CCSTATE->gpr[0], CARG1
    | std 2, RARG4, 0x0, CARG1
    | ldd 0, RARG1, CCSTATE->gpr[1], CARG2
    | std 2, RARG4, 0x8, CARG2
    | ldd 0, RARG1, CCSTATE->gpr[2], CARG3
    | std 2, RARG4, 0x10, CARG3
    | ldd 0, RARG1, CCSTATE->gpr[3], CARG4
    | std 2, RARG4, 0x18, CARG4
    | ldd 0, RARG1, CCSTATE->gpr[4], CARG5
    | std 2, RARG4, 0x20, CARG5
    | ldd 0, RARG1, CCSTATE->gpr[5], CARG6
    | std 2, RARG4, 0x28, CARG6
    | ldd 0, RARG1, CCSTATE->gpr[6], CARG7
    | std 2, RARG4, 0x30, CARG7
    | ldd 0, RARG1, CCSTATE->gpr[7], CARG8
    | std 2, RARG4, 0x38, CARG8
    | // Now we are ready to call
    | ldd 0, RARG1, CCSTATE->func, RARG2
    | movtd 0, RARG2, ctpr1
    | call ctpr1, wbs = 0x4
    | // speculatively write from return regs, if result > 8*8 bytes, read all from stack
    | ldw 0, RARG1, CCSTATE->ret_size, RARG2
    | cmpedb 0, RARG2, 0x0, pred0
    | disp ctpr1, >3
    | ct ctpr1, pred0
    | addd 0, RARG2, 0x0, CARG3
    | addd 0, RARG4, 0x0, CARG2
    | ldd 0, RARG1, CCSTATE->ret_stack, CARG1
    | disp ctpr1, extern memcpy
    | call ctpr1, wbs = 0x4
    | return ctpr3
    | ct ctpr3
    |3:
    | stdsm 2, RARG1, CCSTATE->gpr[0], CRET1
    | stdsm 2, RARG1, CCSTATE->gpr[1], CRET2
    | stdsm 2, RARG1, CCSTATE->gpr[2], CRET3
    | stdsm 2, RARG1, CCSTATE->gpr[3], CRET4
    | stdsm 2, RARG1, CCSTATE->gpr[4], CRET5
    | stdsm 2, RARG1, CCSTATE->gpr[5], CRET6
    | stdsm 2, RARG1, CCSTATE->gpr[6], CRET7
    | stdsm 2, RARG1, CCSTATE->gpr[7], CRET8
    | return ctpr3
    | ct ctpr3
    |.endif
    |//-----------------------------------------------------------------------
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
    int vk = 0;
    |=>defop:

    switch (op) {

    /* -- Comparison ops ---------------------------------------------------- */

    /* Remember: all ops branch for a true comparison, fall through otherwise. */

    |.macro jmp_comp, lt, ge, le, gt, target
    ||switch (op) {
    || case BC_ISLT:
    | lt 0, RA, RD, pred0
    ||  break;
    || case BC_ISGE:
    | ge 0, RA, RD, pred0
    ||  break;
    || case BC_ISLE:
    | le 0, RA, RD, pred0
    ||  break;
    || case BC_ISGT:
    | gt 0, RA, RD, pred0
    ||  break;
    || default: break;
    ||}
    | disp ctpr1, target
    | ct ctpr1, ~pred0
    |.endmacro

    case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
        | ins_AD // RA = src1*8, RD = src2*8, JMP with RD = target
        | ldd 0, BASE, RA, ITYPE
        | ldd 0, BASE, RD, RB
        | addd 0, ITYPE, 0x0, RA
        | addd 0, RB, 0x0, RD
        | sard 0, ITYPE, 0x2f, ITYPE
        | sard 0, RB, 0x2f, RB
        | disp ctpr1, ->vmeta_comp
        | cmpbsb 0, ITYPE, LJ_TISNUM, pred0
        | ct ctpr1, ~pred0
        | cmpbsb 0, RB, LJ_TISNUM, pred0
        | ct ctpr1, ~pred0
        | addd 0, PC, 0x4, PC
        | // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
        | jmp_comp fcmpltdb, fcmpnltdb, fcmpledb, fcmpnledb, >1
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |1:
        | ins_next
        break;

    case BC_ISEQV: case BC_ISNEV:
        vk = op == BC_ISEQV;
        | ins_AD // RA = src1*8, RD = src2*8, JMP with RD = target
        | ldd 0, BASE, RD, RB
        | ldd 0, BASE, RA, ITYPE
        | addd 0, PC, 0x4, PC
        | addd 0, RB, 0x0, RD
        | addd 0, ITYPE, 0x0, RA
        | sard 0, RB, 0x2f, RB
        | sard 0, ITYPE, 0x2f, ITYPE
        | disp ctpr1, >5
        | cmpbsb 0, RB, LJ_TISNUM, pred0
        | ct ctpr1, ~pred0
        | cmpbsb 0, ITYPE, LJ_TISNUM, pred0
        | ct ctpr1, ~pred0
        | fcmpuoddb 0, RA, RD, pred0
        | fcmpeqdb 0, RA, RD, pred1
        if (vk) {
        | disp ctpr1, >2
        | ct ctpr1, pred0
        | ct ctpr1, ~pred1
        |1: // EQ: Branch to the target.
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |2: // NE: Fallthrough to next instruction.
        } else {
        | disp ctpr1, >2
        | ct ctpr1, pred0
        | disp ctpr1, >1
        | ct ctpr1, pred1
        |2: // NE: Branch to the target.
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |1: // EQ: Fallthrough to next instruction.
        }
        | ins_next
        |5: // Either or both types are not numbers.
        |.if FFI
        | cmpesb 0, RB, LJ_TCDATA, pred0
        | disp ctpr1, ->vmeta_equal_cd
        | ct ctpr1, pred0
        | cmpesb 0, ITYPE, LJ_TCDATA, pred0
        | ct ctpr1, pred0
        |.endif
        | cmpedb 0, RA, RD, pred0
        | disp ctpr1, <1                    // Same GCobjs or pvalues?
        | ct ctpr1, pred0
        | cmpesb 0, RB, ITYPE, pred0
        | disp ctpr1, <2                    // Not the same type?
        | ct ctpr1, ~pred0
        | cmpbesb 0, RB, LJ_TISTABUD, pred0
        | ct ctpr1, ~pred0                  // Different objects and not table/ud?
        | // Different tables or userdatas. Need to check __eq metamethod.
        | // Field metatable must be at same offset for GCtab and GCudata!
        | cleartp RA
        | ldd 0, RA, TAB->metatable, RB
        | cmpedb 0, RB, 0x0, pred0
        | disp ctpr1, <2                    // No metatable?
        | ct ctpr1, pred0
        | ldb 0, RB, TAB->nomm, TMP0
        | cmpandedb 0, TMP0, 1<<MM_eq, pred0
        | ct ctpr1, ~pred0                  //  Or 'no __eq' flag set?
        if (vk) {
        | addd 0, 0x0, 0x0, RB                 // ne = 0
        } else {
        | addd 0, 0x0, 0x1, RB                 // ne = 1
        }
        | disp ctpr1, ->vmeta_equal         // Handle __eq metamethod.
        | ct ctpr1
        break;

    case BC_ISEQS: case BC_ISNES:
        vk = op == BC_ISEQS;
        | ins_AND // RA = src*8, RD = str_const*8, JMP with RD = target
        | ldd 0, BASE, RA, RB
        | subd 0, KBASE, RD, TMP0
        | ldd 0, TMP0, 0xfffffff8, RD
        | addd 0, PC, 0x4, PC
        | checkstr RB, >3
        | cmpedb 0, RB, RD, pred0
        if (vk) {
        | disp ctpr1, >2
        | ct ctpr1, ~pred0
        |1: // EQ: Branch to the target.
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |2: // NE: Fallthrough to next instruction.
        |.if not FFI
        |3:
        |.endif
        } else {
        | disp ctpr1, >1
        | ct ctpr1, pred0
        |.if not FFI
        |3:
        |.endif
        |2: // NE: Branch to the target.
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |1: // EQ: Fallthrough to next instruction.
        }
        | ins_next
        |.if FFI
        |3:
        | cmpesb 0, ITYPE, LJ_TCDATA, pred0
        | disp ctpr1, <2
        | ct ctpr1, ~pred0
        | disp ctpr1, ->vmeta_equal_cd
        | ct ctpr1
        |.endif
        break;

    case BC_ISEQN: case BC_ISNEN:
        vk = op == BC_ISEQN;
        | ins_AD // RA = src*8, RD = num_const*8, JMP with RD = target
        | ldd 0, BASE, RA, RB
        | addd 0, PC, 0x4, PC
        | checknum RB, >3
        | ldd 0, KBASE, RD, TMP0
        | ldd 0, BASE, RA, TMP1
        | fcmpuoddb 0, TMP0, TMP1, pred0
        | fcmpeqdb 0, TMP0, TMP1, pred1
        if (vk) {
        | disp ctpr1, >2
        | ct ctpr1, pred0
        | ct ctpr1, ~pred1
        |1: // EQ: Branch to the target.
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |2: // NE: Fallthrough to next instruction.
        |.if not FFI
        |3:
        |.endif
        } else {
        | disp ctpr1, >2
        | ct ctpr1, pred0
        | disp ctpr1, >1
        | ct ctpr1, pred1
        |.if not FFI
        |3:
        |.endif
        |2: // NE: Branch to the target.
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |1: // EQ: Fallthrough to next instruction.
        }
        | ins_next
        |.if FFI
        |3:
        | cmpesb 0, ITYPE, LJ_TCDATA, pred0
        | disp ctpr1, <2
        | ct ctpr1, ~pred0
        | disp ctpr1, ->vmeta_equal_cd
        | ct ctpr1
        |.endif
        break;

    case BC_ISEQP: case BC_ISNEP:
        vk = op == BC_ISEQP;
        | ins_AND // RA = src*8, RD = primitive_type*8 (~), JMP with RD = target
        | ldd 0, BASE, RA, RB
        | shrd 0, RD, 0x3, RD
        | xord 0, RD, 0xffffffff, RD
        | sard 0, RB, 0x2f, RB
        | addd 0, PC, 0x4, PC
        | cmpesb 0, RB, RD, pred0
        if (vk) {
        | disp ctpr1, >2
        | ct ctpr1, ~pred0
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |1:
        | ins_next
        |2:
        | cmpesb 0, RB, LJ_TCDATA, pred0
        | disp ctpr1, <1
        | ct ctpr1, ~pred0
        | disp ctpr1, ->vmeta_equal_cd
        | ct ctpr1
        } else {
        | disp ctpr1, >1
        | ct ctpr1, pred0
        | cmpesb 0, RB, LJ_TCDATA, pred0
        | disp ctpr1, ->vmeta_equal_cd
        | ct ctpr1, pred0
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |1:
        | ins_next
        }
        break;

    /* -- Unary test and copy ops ------------------------------------------- */

    case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
        | ins_AD // RA = dst*8 or unused, RD = src*8, JMP with RD = target
        | ldd 0, BASE, RD, ITYPE
        | addd 0, PC, 0x4, PC
        if (op == BC_ISTC || op == BC_ISFC) {
          | addd 0, ITYPE, 0x0, RB
        }
        | sard 0, ITYPE, 0x2f, ITYPE
        | cmpbsb 0, ITYPE, LJ_TISTRUECOND, pred0
        | disp ctpr1, >1
        if (op == BC_IST || op == BC_ISTC) {
          | ct ctpr1, ~pred0
        } else {
          | ct ctpr1, pred0
        }
        if (op == BC_ISTC || op == BC_ISFC) {
          | std 2, BASE, RA, RB
        }
        | ldh 0, PC, PC_RD, RD
        | branchPC RD
        |1:
        | ins_next
        break;

    case BC_ISTYPE:
        | ins_AD // RA = src*8, RD = -type*8
        | ldd 0, BASE, RA, RB
        | sard 0, RB, 0x2c, RB
        | andd 0, RB, U64x(0xffffffff,0xfffffff8), RB
        | addd 0, RB, RD, RB
        | cmpedb 0, RB, 0x0, pred0
        | disp ctpr1, ->vmeta_istype
        | ct ctpr1, ~pred0
        | ins_next
        break;

    case BC_ISNUM:
        | ins_AD // RA = src*8, RD = -(TISNUM-1)*8
        | ldd 0, BASE, RA, TMP0
        | checknumtp TMP0, ->vmeta_istype
        | ins_next
        break;

    /* -- Unary ops --------------------------------------------------------- */

    case BC_MOV:
        | // ins_AD RA = dst*8, RD = src*8
        |<
        | addd 1, PC, 0x4, PC
        | ldb 2, PC, 0x0, TMP1
        | ldd 3, BASE, RD, CARG1
        | ldw 5, PC, 0x0, TMP0
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x5, RA
        | std 5, BASE, RA, CARG1
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | shrd 4, TMP0, 0x15, RB
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        |<
        | andd 3, RA, 0x7f8, RA
        | ct ctpr1
        |>
        break;

    case BC_NOT:
        | ins_AD // RA = dst*8, RD = src*8
        | ldd 0, BASE, RD, RB
        | sard 0, RB, 0x2f, RB
        | addd 0, 0x0, 0x2, RC
        | cmpbsb 0, RB, LJ_TISTRUECOND, pred0
        | disp ctpr1, >1
        | ct ctpr1, ~pred0
        | subd 0, RC, 0x1, RC
        |1:
        | shld 0, RC, 0x2f, RC
        | xord 0, RC, 0xffffffff, RC
        | std 2, BASE, RA, RC
        | ins_next
        break;

    case BC_UNM:
        | ins_AD // RA = dst*8, RD = src*8
        | ldd 0, BASE, RD, RB
        | checknum RB, ->vmeta_unm
        | xord 0, RB, U64x(0x80000000,0x00000000), RB
        | std 2, BASE, RA, RB
        | ins_next
        break;

    case BC_LEN:
        | ins_AD // RA = dst*8, RD = src*8
        | ldd 0, BASE, RD, RD
        | checkstr RD, >2
        | ldw 0, RD, STR->len, TMP0
        | istofd 0, TMP0, TMP1
        |1:
        | std 2, BASE, RA, TMP1
        | ins_next
        |2:
        | cmpedb 0, ITYPE, LJ_TTAB, pred0
        | disp ctpr1, ->vmeta_len
        | ct ctpr1, ~pred0
        | addd 0, RD, 0x0, CARG1
#if LJ_52
        | ldd 0, RD, TAB->metatable, RB
        | cmpedb 0, RB, 0x0, pred0
        | disp ctpr1, >9
        | ct ctpr1, ~pred0
        |3:
#endif
        |->BC_LEN_Z:
        | disp ctpr1, extern lj_tab_len     // (GCtab *t)
        | call ctpr1, wbs = 0x8
        | // Length of table returned.
        | istofd 0, CRET1, TMP1
        | ldb 0, PC, PC_RA, RA
        | shld 0, RA, 0x3, RA
        | disp ctpr1, <1
        | ct ctpr1
#if LJ_52
        |9: // Check for __len.
        | ldb 0, RB, TAB->nomm, TMP0
        | cmpandedb 0, TMP0, 1<<MM_len, pred0
        | disp ctpr1, <3
        | ct ctpr1, ~pred0
        | disp ctpr1, ->vmeta_len           // 'no __len' flag NOT set: check.
        | ct ctpr1
#endif
        break;

    /* -- Binary ops -------------------------------------------------------- */

    |.macro ins_arith_opt, ins, ch, nop_n
    || vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    || switch (vk) {
    ||  case 0:
    |<
    | ldbsm 2, PC, 0x0, CARG3
    | ldd 3, KBASE, RC, TMP1
    | addd 4, RA, 0x0, CARG1
    | ldd 5, BASE, RB, TMP0
    | disp ctpr1, ->vmeta_arith_vn
    | nop 2
    |>
    |<
    | shld 1, CARG3, 0x3, CARG3
    | sard 3, TMP0, 0x2f, ITYPE
    | ins ch, TMP0, TMP1, CARG2
    | nop nop_n
    |>
    |<
    | ldd 2, CARG3, DISPATCH, CARG3
    | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
    | ldwsm 5, PC, 0x0, CARG5
    | nop 2
    |>
    ||   break;
    ||  case 1:
    |<
    | ldbsm 2, PC, 0x0, CARG3
    | ldd 3, KBASE, RC, TMP1
    | addd 4, RA, 0x0, CARG1
    | ldd 5, BASE, RB, TMP0
    | disp ctpr1, ->vmeta_arith_nv
    | nop 2
    |>
    |<
    | shld 1, CARG3, 0x3, CARG3
    | sard 3, TMP0, 0x2f, ITYPE
    | ins ch, TMP1, TMP0, CARG2
    | nop nop_n
    |>
    |<
    | ldd 2, CARG3, DISPATCH, CARG3
    | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
    | ldwsm 5, PC, 0x0, CARG5
    | nop 2
    |>
    ||   break;
    ||  default:
    |<
    | ldbsm 2, PC, 0x0, CARG3
    | ldd 3, BASE, RC, TMP1
    | addd 4, RA, 0x0, CARG1
    | ldd 5, BASE, RB, TMP0
    | disp ctpr1, ->vmeta_arith_vv
    | nop 2
    |>
    |<
    | shld 0, CARG3, 0x3, CARG3
    | sard 2, TMP1, 0x2f, CARG4
    | sard 3, TMP0, 0x2f, ITYPE
    | ins ch, TMP0, TMP1, CARG2
    | nop nop_n
    |>
    |<
    | cmpbsb 1, CARG4, LJ_TISNUM, pred1
    | ldd 2, CARG3, DISPATCH, CARG3
    | cmpbsb 3, ITYPE, LJ_TISNUM, pred0
    | ldwsm 5, PC, 0x0, CARG5
    | nop 1
    |>
    |<
    | pass pred0, p0
    | pass pred1, p1
    | landp p0, p1, p4
    | pass p4, pred0
    |>
    ||  break;
    || }
    |<
    | movtd 0, CARG3, ctpr2
    | addd 1, PC, 0x4, PC, pred0
    |>
    |<
    | shrd 3, CARG5, 0xd, RD, pred0
    | shrd 4, CARG5, 0x15, RB, pred0
    | shrd 5, CARG5, 0x5, RA, pred0
    | ct ctpr1, ~pred0
    |>
    |<
    | andd 3, RD, 0x7fff8, RD
    | andd 4, RA, 0x7f8, RA
    |>
    |<
    | andd 3, RB, 0x7f8, RB
    | andd 4, RD, 0x7f8, RC
    | std 5, BASE, CARG1, CARG2
    | ct ctpr2
    |>
    |.endmacro

    case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        | ins_arith_opt faddd, 4, 0
        break;

    case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        | ins_arith_opt fsubd, 4, 0
        break;

    case BC_MULVN: case BC_MULNV: case BC_MULVV:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        | ins_arith_opt fmuld, 4, 1
        break;

    case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
        | // ins_ABC RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        | ins_arith_opt fdivd, 5, 7 
        break;

    case BC_MODVN: case BC_MODNV: case BC_MODVV:
        | ins_ABC // RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        switch (op) {
        case BC_MODVN:
          | ldd 0, BASE, RB, CARG1
          | ldd 0, KBASE, RC, CARG2
          | checknumtp CARG1, ->vmeta_arith_vn
          break;
        case BC_MODNV:
          | ldd 0, KBASE, RC, CARG1
          | ldd 0, BASE, RB, CARG2
          | checknumtp CARG2, ->vmeta_arith_nv
          break;
        case BC_MODVV:
          | ldd 0, BASE, RB, CARG1
          | ldd 0, BASE, RC, CARG2
          | checknumtp CARG1, ->vmeta_arith_vv
          | checknumtp CARG2, ->vmeta_arith_vv
          break;
        default:
          break;
        }
        | disp ctpr1, ->vm_mod
        | call ctpr1, wbs = 0x8
        | std 2, BASE, RA, CRET1
        | ins_next
        break;

    case BC_POW:
        | ins_ABC // RA = dst*8, RB = src1*8, RC = src2*8 or num_const*8
        | ldd 0, BASE, RB, CARG1
        | ldd 0, BASE, RC, CARG2
        | checknumtp CARG1, ->vmeta_arith_vv
        | checknumtp CARG2, ->vmeta_arith_vv
        | disp ctpr1, extern pow
        | call ctpr1, wbs = 0x8
        | ldb 0, PC, PC_RA, RA
        | shld 0, RA, 0x3, RA
        | std 2, BASE, RA, CRET1
        | ins_next
        break;

    case BC_CAT:
        | ins_ABC // RA = dst*8, RB = src_start*8, RC = src_end*8
        | ldd 0, STACK, SAVE_L, CARG1
        | std 2, CARG1, L->base, BASE
        | addd 0, BASE, RC, CARG2
        | addd 0, RC, 0x0, CARG3
        | subd 0, CARG3, RB, CARG3
        | shrd 0, CARG3, 0x3, CARG3
        |->BC_CAT_Z:
        | addd 0, CARG1, 0x0, RB
        | std 2, STACK, SAVE_PC, PC
        | disp ctpr1, extern lj_meta_cat    // (lua_State *L, TValue *top, int left)
        | call ctpr1, wbs = 0x8
        | // NULL (finished) or TValue * (metamethod) returned.
        | ldd 0, RB, L->base, BASE
        | cmpedb 0, CRET1, 0x0, pred0
        | disp ctpr1, ->vmeta_binop
        | ct ctpr1, ~pred0
        | ldb 0, PC, PC_RB, RB                 // Copy result to Stk[RA] from Stk[RB].
        | shld 0, RB, 0x3, RB
        | ldb 0, PC, PC_RA, RA
        | shld 0, RA, 0x3, RA
        | ldd 0, BASE, RB, TMP0
        | std 2, BASE, RA, TMP0
        | ins_next
        break;

    /* -- Constant ops ------------------------------------------------------ */

    case BC_KSTR:
        | ins_AND // RA = dst*8, RD = str_const*8 (~)
        | subd 0, KBASE, RD, TMP0
        | ldd 0, TMP0, 0xfffffff8, RD
        | settp RD, LJ_TSTR
        | std 2, BASE, RA, RD
        | ins_next
        break;

    case BC_KCDATA:
        |.if FFI
        | ins_AND // RA = dst*8, RD = cdata_const*8 (~)
        | subd 0, KBASE, RD, TMP0
        | ldd 0, TMP0, 0xfffffff8, RD
        | settp RD, LJ_TCDATA
        | std 2, BASE, RA, RD
        | ins_next
        |.endif
        break;

    case BC_KSHORT:
        | ins_AD // RA = dst*8, RD = int16_literal*8
        | shrd 0, RD, 0x3, RD
        | sxt 0, 0x1, RD, RD                   // Sign-extend literal.
        | idtofd 0, RD, RD
        | std 2, BASE, RA, RD
        | ins_next
        break;

    case BC_KNUM:
        | ins_AD // RA = dst*8, RD = num_const*8
        | ldd 0, KBASE, RD, TMP0
        | std 2, BASE, RA, TMP0
        | ins_next
        break;

    case BC_KPRI:
        | ins_AD // RA = dst*8, RD = primitive_type*8 (~)
        | shld 0, RD, 0x2c, RD
        | xord 0, RD, 0xffffffff, RD
        | std 2, BASE, RA, RD
        | ins_next
        break;

    case BC_KNIL:
        | ins_AD // RA = dst_start*8, RD = dst_end*8
        | addd 0, BASE, RA, RA
        | addd 0, RA, 0x8, RA
        | addd 0, BASE, RD, RD
        | addd 0, 0x0, LJ_TNIL, RB
        | std 2, RA, 0xfffffff8, RB            // Sets minimum 2 slots
        |1:
        | std 2, RA, 0x0, RB
        | addd 0, RA, 0x8, RA
        | cmpbedb 0, RA, RD, pred0
        | disp ctpr1, <1
        | ct ctpr1, pred0
        | ins_next
        break;

    /* -- Upvalue and function ops ------------------------------------------ */

    case BC_UGET:
        | ins_AD // RA = dst*8, RD = upvalue*8
        | ldd 0, BASE, 0xfffffff0, RB
        | cleartp RB
        | addd 0, RB, RD, TMP0
        | ldd 0, TMP0, offsetof(GCfuncL, uvptr), RB
        | ldd 0, RB, UPVAL->v, RB
        | ldd 0, RB, 0x0, RD
        | std 2, BASE, RA, RD
        | ins_next
        break;

    case BC_USETV:
#define TV2MARKOFS \
 ((int32_t)offsetof(GCupval, marked)-(int32_t)offsetof(GCupval, tv))
        | ins_AD // RA = upvalue*8, RD = src*8
        | ldd 0, BASE, 0xfffffff0, RB
        | cleartp RB
        | addd 0, RB, RA, TMP0
        | ldd 0, TMP0, offsetof(GCfuncL, uvptr), RB
        | ldb 0, RB, UPVAL->closed, TMP0
        | cmpedb 0, TMP0, 0x0, pred0
        | ldd 0, RB, UPVAL->v, RB
        | ldd 0, BASE, RD, RA
        | std 2, RB, 0x0, RA
        | disp ctpr1, >1
        | ct ctpr1, pred0
        | // Check barrier for closed upvalue.
        | ldb 0, RB, TV2MARKOFS, TMP0
        | cmpandedb 0, TMP0, LJ_GC_BLACK, pred0
        | disp ctpr1, >2                    // isblack(uv)
        | ct ctpr1, ~pred0
        |1:
        | ins_next
        |2: // Upvalue is black. Check if new value is collectable and white.
        | addd 0, RA, 0x0, RD
        | sard 0, RD, 0x2f, RD
        | subs 0, RD, LJ_TISGCV, RD
        | cmpbesb 0, RD, LJ_TNUMX - LJ_TISGCV, pred0
        | disp ctpr1, <1                    // tvisgcv(v)
        | ct ctpr1, pred0
        | cleartp RA
        | ldb 0, RA, GCOBJ->gch.marked, TMP0
        | cmpandedb 0, TMP0, LJ_GC_WHITES, pred0
        | disp ctpr1, <1                    // iswhite(v)
        | ct ctpr1, pred0
        | // Crossed a write barrier. Move the barrier forward.
        | addd 0, RB, 0x0, CARG2
        | addd 0, DISPATCH, GG_DISP2G, CARG1
        | disp ctpr1, extern lj_gc_barrieruv // (global_State *g, TValue *tv)
        | call ctpr1, wbs = 0x8
        | disp ctpr1, <1
        | ct ctpr1
        break;
#undef TV2MARKOFS

    case BC_USETS:
        | ins_AND // RA = upvalue*8, RD = str_const*8 (~)
        | ldd 0, BASE, 0xfffffff0, RB
        | cleartp RB
        | addd 0, RB, RA, TMP0
        | ldd 0, TMP0, offsetof(GCfuncL, uvptr), RB
        | subd 0, KBASE, RD, TMP0
        | ldd 0, TMP0, 0xfffffff8, RA
        | ldd 0, RB, UPVAL->v, RD
        | settp ITYPE, RA, LJ_TSTR
        | std 2, RD, 0x0, ITYPE
        | ldb 0, RB, UPVAL->marked, TMP0
        | cmpandedb 0, TMP0, LJ_GC_BLACK, pred0
        | disp ctpr1, >2                    // isblack(uv)
        | ct ctpr1, ~pred0
        |1:
        | ins_next
        |2: // Check if string is white and ensure upvalue is closed.
        | ldb 0, RA, GCOBJ->gch.marked, TMP0
        | cmpandedb 0, TMP0, LJ_GC_WHITES, pred0
        | disp ctpr1, <1                    // iswhite(str)
        | ct ctpr1, pred0
        | ldb 0, RB, UPVAL->closed, TMP0
        | cmpedb 0, TMP0, 0x0, pred0
        | disp ctpr1, <1
        | ct ctpr1, pred0
        | // Crossed a write barrier. Move the barrier forward.
        | addd 0, RD, 0x0, CARG2
        | addd 0, DISPATCH, GG_DISP2G, CARG1
        | disp ctpr1, extern lj_gc_barrieruv // (global_State *g, TValue *tv)
        | call ctpr1, wbs = 0x8
        | disp ctpr1, <1
        | ct ctpr1
        break;

    case BC_USETN:
        | ins_AD // RA = upvalue*8, RD = num_const*8
        | ldd 0, BASE, 0xfffffff0, RB
        | cleartp RB
        | ldd 0, KBASE, RD, TMP0
        | addd 0, RB, RA, TMP1
        | ldd 0, TMP1, offsetof(GCfuncL, uvptr), RB
        | ldd 0, RB, UPVAL->v, RA
        | std 2, RA, 0x0, TMP0
        | ins_next
        break;

    case BC_USETP:
        | ins_AD // RA = upvalue*8, RD = primitive_type*8 (~)
        | ldd 0, BASE, 0xfffffff0, RB
        | cleartp RB
        | addd 0, RB, RA, TMP0
        | ldd 0, TMP0, offsetof(GCfuncL, uvptr), RB
        | shld 0, RD, 0x2c, RD
        | xord 0, RD, 0xffffffff, RD
        | ldd 0, RB, UPVAL->v, RA
        | std 2, RA, 0x0, RD
        | ins_next
        break;

    case BC_UCLO:
        | ins_AD // RA = level*8, RD = target*8
        | shrd 0, RD, 0x3, RD
        | branchPC RD                       // Do this first to free RD.
        | ldd 0, STACK, SAVE_L, RB
        | ldd 0, RB, L->openupval, TMP0
        | cmpedb 0, TMP0, 0x0, pred0
        | disp ctpr1, >1
        | ct ctpr1, pred0
        | std 2, RB, L->base, BASE
        | addd 0, BASE, RA, CARG2
        | addd 0, RB, 0x0, CARG1
        | disp ctpr1, extern lj_func_closeuv // (lua_State *L, TValue *level)
        | call ctpr1, wbs = 0x8
        | ldd 0, RB, L->base, BASE
        |1:
        | ins_next
        break;

    case BC_FNEW:
        | // ins_AND RA = dst*8, RD = proto_const*8 (~) (holding function prototype)
        | disp ctpr1, extern lj_func_newL_gc // (lua_State *L, GCproto *pt, GCfuncL *parent)
        |<
        | ldd 0, STACK, SAVE_L, RB
        | ldd 3, BASE, 0xfffffff0, CARG3
        | subd 4, KBASE, RD, TMP0
        | nop 1
        |>
        | ldd 3, TMP0, 0xfffffff8, CARG2       // Fetch GCproto *.
        |<
        | addd 0, RB, 0x0, CARG1
        | std 2, RB, L->base, BASE
        |>
        |<
        | std 2, STACK, SAVE_PC, PC
        | andd 3, CARG3, U64x(0x00007fff,0xffffffff), CARG3
        | call ctpr1, wbs = 0x8
        |>
        | // GCfuncL * returned.
        |<
        | ldb 0, PC, PC_RA, RA
        | ldb 2, PC, 0x0, TMP1
        | ldw 3, PC, 0x0, TMP0
        | ldd 5, RB, L->base, BASE
        | nop 2
        |>
        |<
        | shld 0, TMP1, 0x3, TMP1
        | shld 1, RA, 0x3, RA
        | addd 2, 0x0, LJ_TFUNC, ITYPE
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        |>
        |<
        | ldd 0, TMP1, DISPATCH, TMP1
        | shld 1, ITYPE, 0x2f, ITYPE
        | addd 2, PC, 0x4, PC
        | andd 3, RD, 0x7fff8, RD
        |>
        |<
        | ord 0, CRET1, ITYPE, CRET1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        |<
        | std 2, BASE, RA, CRET1
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 4, RA, 0x7f8, RA
        |>
        | ct ctpr1
        break;

    /* -- Table ops --------------------------------------------------------- */

    case BC_TNEW:
        | ins_AD // RA = dst*8, RD = (hbits|asize)*8
        | ldd 0, STACK, SAVE_L, RB
        | std 2, RB, L->base, BASE
        | ldd 0, DISPATCH, DISPATCH_GL(gc.total), TMP0
        | ldd 0, DISPATCH, DISPATCH_GL(gc.threshold), TMP1
        | cmpbdb 0, TMP0, TMP1, pred0
        | std 2, STACK, SAVE_PC, PC
        | disp ctpr1, >5
        | ct ctpr1, ~pred0
        | shrd 0, RD, 0x3, RD
        |1:
        | shrd 0, RD, 0xb, CARG3
        | andd 0, RD, 0x7ff, RD
        | cmpedb 0, RD, 0x7ff, pred0
        | disp ctpr1, >3
        | ct ctpr1, pred0
        |2:
        | addd 0, RB, 0x0, CARG1
        | addd 0, RD, 0x0, CARG2
        | disp ctpr1, extern lj_tab_new     // (lua_State *L, int32_t asize, uint32_t hbits)
        | call ctpr1, wbs = 0x8
        | // Table * returned.
        | ldd 0, RB, L->base, BASE
        | ldb 0, PC, PC_RA, RA
        | shld 0, RA, 0x3, RA
        | settp CRET1, LJ_TTAB
        | std 2, BASE, RA, CRET1
        | ins_next
        |3:                                 // Turn 0x7ff into 0x801.
        | addd 0, 0x0, 0x801, RD
        | disp ctpr1, <2
        | ct ctpr1
        |5:
        | addd 0, RB, 0x0, CARG1
        | disp ctpr1, extern lj_gc_step_fixtop // (lua_State *L)
        | call ctpr1, wbs = 0x8
        | ldh 0, PC, PC_RD, RD
        | disp ctpr1, <1
        | ct ctpr1
        break;

    case BC_TDUP:
        | ins_AND // RA = dst*8, RD = table_const*8 (~)
        | ldd 0, STACK, SAVE_L, RB
        | ldd 0, DISPATCH, DISPATCH_GL(gc.total), TMP0
        | ldd 0, DISPATCH, DISPATCH_GL(gc.threshold), TMP1
        | std 2, STACK, SAVE_PC, PC
        | std 2, RB, L->base, BASE
        | cmpbdb 0, TMP0, TMP1, pred0
        | disp ctpr1, >3
        | ct ctpr1, ~pred0
        |2:
        | subd 0, KBASE, RD, TMP0
        | ldd 0, TMP0, 0xfffffff8, CARG2
        | addd 0, RB, 0x0, CARG1
        | disp ctpr1, extern lj_tab_dup     // (lua_State *L, Table *kt)
        | call ctpr1, wbs = 0x8
        | ldd 0, RB, L->base, BASE
        | ldb 0, PC, PC_RA, RA
        | shld 0, RA, 0x3, RA
        | settp CRET1, LJ_TTAB              // returned Table *
        | std 2, BASE, RA, CRET1
        | ins_next
        |3:
        | addd 0, RB, 0x0, CARG1
        | disp ctpr1, extern lj_gc_step_fixtop // (lua_State *L)
        | call ctpr1, wbs = 0x8
        | ldh 0, PC, PC_RD, RD
        | shld 0, RD, 0x3, RD
        | disp ctpr1, <2
        | ct ctpr1
        break;

    case BC_GGET:
        | // ins_AND RA = dst*8, RD = str_const*8 (~)
        |<
        | ldb 2, PC, 0x0, CARG4
        | ldd 3, BASE, 0xfffffff0, RB
        | addd 4, 0x0, LJ_TSTR, CARG1
        | subd 5, KBASE, RD, TMP0
        | nop 1
        |>
        | ldw 3, PC, 0x0, CARG3
        |<
        | ldd 3, TMP0, 0xfffffff8, RC
        | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
        |>
        |<
        | shld 0, CARG4, 0x3, CARG4
        | ldd 3, RB, LFUNC->env, RB
        | shld 4, CARG1, 0x2f, CARG1
        | nop 2
        |>
        |<
        | ldw 3, RB, TAB->hmask, TMP0       // RB = GCtab *, RC = GCstr *
        | ldw 5, RC, STR->sid, TMP1
        |>
        |<
        | ldd 2, CARG4, DISPATCH, CARG4
        | ldd 3, RB, TAB->node, CARG2
        | nop 1
        |>
        |<
        | andd 4, TMP0, TMP1, TMP1          // idx = str->sid & tab->hmask
        |>
        |<
        | movtd 0, CARG4, ctpr3
        | shld 3, TMP1, 0x5, TMP0
        | shld 4, TMP1, 0x3, TMP1
        |>
        | subd 3, TMP0, TMP1, TMP1
        |<
        | addd 3, CARG2, TMP1, TMP0         // node = tab->node + (idx*32-idx*8)
        | ord 4, RC, CARG1, ITYPE
        |>
        |<
        | ldd 3, TMP0, NODE->key, TMP1
        | lddsm 5, TMP0, NODE->next, CARG5
        | nop 2
        |>
        |1:
        |<
        | disp ctpr2, <1
        | cmpedbsm 3, CARG5, 0x0, pred2
        | cmpedb 4, TMP1, ITYPE, pred3
        | lddsm 5, TMP0, NODE->val, CARG4    // Get node value.
        | nop 1
        |>
        |<
        | disp ctpr1, >2
        | pass pred3, p0
        | pass pred2, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred4
        | landp ~p0, p1, p5
        | pass p5, pred2
        |>
        |<
        | addd 3, CARG5, 0x0, TMP0, ~pred3   // Follow hash chain.
        | addd 4, CARG4, 0x0, ITYPE, pred3
        |>
        |<
        | ldd 3, TMP0, NODE->key, TMP1, pred4
        | cmpedbsm 4, ITYPE, LJ_TNIL, pred1
        | lddsm 5, TMP0, NODE->next, CARG5, pred4
        | nop 1
        |>
        | ct ctpr2, pred4
        |<
        | addd 3, 0x0, LJ_TNIL, ITYPE, pred2 // End of hash chain: key not found, nil result.
        | ct ctpr1, pred2
        |>
        |<
        | addd 2, PC, 0x4, PC, ~pred1
        | shrd 3, CARG3, 0xd, RD, ~pred1
        | shrd 4, CARG3, 0x15, RB, ~pred1
        | std 5, BASE, RA, ITYPE, ~pred1
        | ct ctpr1, pred1
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RB, 0x7f8, RB
        | shrd 5, CARG3, 0x5, RA
        |>
        |<
        | andd 4, RD, 0x7f8, RC
        | andd 5, RA, 0x7f8, RA
        | ct ctpr3
        |>
        |2:
        |<
        | disp ctpr1, ->vmeta_tgets
        | ldd 3, RB, TAB->metatable, TMP0   //  Check for __index if table value is nil
        | nop 2
        |>
        |<
        | ldbsm 3, TMP0, TAB->nomm, TMP1
        | cmpedb 4, TMP0, 0x0, pred0
        | nop 2
        |>
        | cmpandedbsm 4, TMP1, 1<<MM_index, pred1
        |<
        | pass pred0, p0                    // No metatable: done
        | pass pred1, p1                    // 'no __index' flag set: done.
        | landp ~p0, p1, p4
        | pass p4, pred0
        |>
        |<
        | addd 0, PC, 0x4, PC, ~pred0
        | shrd 3, CARG3, 0xd, RD, ~pred0
        | shrd 4, CARG3, 0x15, RB, ~pred0
        | std 5, BASE, RA, ITYPE, ~pred0
        | ct ctpr1, pred0
        |>
        |<
        | shrd 3, CARG3, 0x5, RA
        | andd 4, RB, 0x7f8, RB
        | andd 5, RD, 0x7fff8, RD
        |>
        |<
        | andd 3, RA, 0x7f8, RA
        | andd 4, RD, 0x7f8, RC
        | ct ctpr3
        |>
        break;

    case BC_GSET:
        | ins_AND // RA = src*8, RD = str_const*8 (~)
        | ldd 0, BASE, 0xfffffff0, RB
        | cleartp RB
        | ldd 0, RB, LFUNC->env, RB
        | subd 0, KBASE, RD, TMP0
        | ldd 0, TMP0, 0xfffffff8, RC
        | disp ctpr1, ->BC_TSETS_Z
        | ct ctpr1
        break;

    case BC_TGETV:
        | ins_ABC // RA = dst*8, RB = table*8, RC = key*8
        | ldd 0, BASE, RB, RB
        | ldd 0, BASE, RC, RC
        | checktab RB, ->vmeta_tgetv
        | // Integer key?
        | // Convert number to int and back and compare.
        | checknum RC, >5
        | fdtoistr 0, RC, TMP0
        | istofd 0, TMP0, TMP1
        | fcmpeqdb 0, RC, TMP1, pred0
        | disp ctpr1, ->vmeta_tgetv         // Generic numeric key? Use fallback.
        | ct ctpr1, ~pred0
        | sxt 0, 0x2, TMP0, RC
        | ldw 0, RB, TAB->asize, TMP0
        | cmpbsb 0, RC, TMP0, pred0
        | disp ctpr1, ->vmeta_tgetv
        | ct ctpr1, ~pred0
        | shld 0, RC, 0x3, RC
        | ldd 0, RB, TAB->array, TMP0
        | addd 0, RC, TMP0, RC
        | // Get array slot.
        | ldd 0, RC, 0x0, ITYPE
        | cmpedb 0, ITYPE, LJ_TNIL, pred0
        | disp ctpr1, >2
        | ct ctpr1, pred0
        |1:
        | std 2, BASE, RA, ITYPE
        | ins_next
        |2: // Check for __index if table value is nil.
        | ldd 0, RB, TAB->metatable, TMP0
        | cmpedb 0, TMP0, 0x0, pred0
        | disp ctpr1, <1
        | ct ctpr1, pred0
        | ldb 0, TMP0, TAB->nomm, TMP0
        | cmpandedb 0, TMP0, 1<<MM_index, pred0
        | disp ctpr1, ->vmeta_tgetv         // 'no __index' flag NOT set: check.
        | ct ctpr1, pred0
        | disp ctpr1, <1
        | ct ctpr1
        |5: // String key?
        | cmpesb 0, ITYPE, LJ_TSTR, pred0
        | disp ctpr1, ->vmeta_tgetv
        | ct ctpr1, ~pred0
        | cleartp RC
        |<
        | ldw 0, RB, TAB->hmask, TMP0
        | ldw 2, RC, STR->sid, TMP1
        |>
        | andd 0, TMP0, TMP1, TMP1             // idx = str->sid & tab->hmask
        | smulx 0, TMP1, #NODE, TMP0
        | ldd 0, RB, TAB->node, TMP1
        |<
        | addd 0, TMP1, TMP0, TMP0
        | addd 1, 0x0, LJ_TSTR, ITYPE
        |>
        | shld 0, ITYPE, 0x2f, ITYPE
        | ord 0, ITYPE, RC, ITYPE
        |6:
        | ldd 0, TMP0, NODE->key, TMP1
        | cmpedb 0, TMP1, ITYPE, pred0
        | disp ctpr1, >8
        | ct ctpr1, ~pred0
        | // Get node value.
        | ldd 0, TMP0, NODE->val, ITYPE
        | cmpedb 0, ITYPE, LJ_TNIL, pred0
        | disp ctpr1, >9                    // Key found, but nil value?
        | ct ctpr1, pred0
        |7:
        | std 2, BASE, RA, ITYPE
        | ins_next
        |8:                                 // Follow hash chain.
        | ldd 0, TMP0, NODE->next, TMP0
        | cmpedb 0, TMP0, 0x0, pred0
        | disp ctpr1, <6
        | ct ctpr1, ~pred0
        | // End of hash chain: key not found, nil result.
        | addd 0, 0x0, LJ_TNIL, ITYPE
        |9:                                 // Check for __index if table value is nil
        | ldd 0, RB, TAB->metatable, TMP0
        | cmpedb 0, TMP0, 0x0, pred0
        | disp ctpr1, <7                    // No metatable: done
        | ct ctpr1, pred0
        | ldb 0, TMP0, TAB->nomm, TMP1
        | cmpandedb 0, TMP1, 1<<MM_index, pred0
        | disp ctpr1, <7                    // 'no __index' flag set: done.
        | ct ctpr1, ~pred0
        | disp ctpr1, ->vmeta_tgets
        | ct ctpr1
        break;

    case BC_TGETS:
        | // ins_ABC RA = dst*8, RB = table*8, RC = str_const*8 (~)
        |<
        | ldb 2, PC, 0x0, CARG4
        | ldd 3, BASE, RB, RB
        | addd 4, 0x0, LJ_TSTR, CARG1
        | subd 5, KBASE, RC, TMP0
        | disp ctpr1, ->vmeta_tgets
        | nop 2
        |>
        |<
        | ldd 3, TMP0, 0xfffffff8, RC
        | sard 4, RB, 0x2f, ITYPE
        | andd 5, RB, U64x(0x00007fff,0xffffffff), RB
        | nop 1
        |>
        |<
        | shld 0, CARG4, 0x3, CARG4
        | cmpesb 3, ITYPE, LJ_TTAB, pred0
        | shld 4, CARG1, 0x2f, CARG1
        | ldw 5, PC, 0x0, CARG3
        |>
        |<
        | ldw 3, RB, TAB->hmask, TMP0, pred0 // RB = GCtab *, RC = GCstr *
        | ldw 5, RC, STR->sid, TMP1, pred0
        |>
        |<
        | ldd 2, CARG4, DISPATCH, CARG4
        | ldd 3, RB, TAB->node, CARG2, pred0
        | nop 1
        |>
        |<
        | andd 4, TMP0, TMP1, TMP1, pred0   // idx = str->sid & tab->hmask
        | ct ctpr1, ~pred0
        |>
        |<
        | movtd 0, CARG4, ctpr3
        | shld 3, TMP1, 0x5, TMP0
        | shld 4, TMP1, 0x3, TMP1
        |>
        | subd 3, TMP0, TMP1, TMP1
        |<
        | addd 3, CARG2, TMP1, TMP0         // node = tab->node + (idx*32-idx*8)
        | ord 4, RC, CARG1, ITYPE
        |>
        |<
        | ldd 3, TMP0, NODE->key, TMP1
        | lddsm 5, TMP0, NODE->next, CARG5
        | nop 2
        |>
        |1:
        |<
        | disp ctpr2, <1
        | cmpedbsm 3, CARG5, 0x0, pred2
        | cmpedb 4, TMP1, ITYPE, pred3
        | lddsm 5, TMP0, NODE->val, CARG4    // Get node value.
        | nop 1
        |>
        |<
        | disp ctpr1, >2
        | pass pred3, p0
        | pass pred2, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred4
        | landp ~p0, p1, p5
        | pass p5, pred2
        |>
        |<
        | addd 3, CARG5, 0x0, TMP0, ~pred3   // Follow hash chain.
        | addd 4, CARG4, 0x0, ITYPE, pred3
        |>
        |<
        | ldd 3, TMP0, NODE->key, TMP1, pred4
        | cmpedbsm 4, ITYPE, LJ_TNIL, pred1
        | lddsm 5, TMP0, NODE->next, CARG5, pred4
        | nop 1
        |>
        | ct ctpr2, pred4
        |<
        | addd 3, 0x0, LJ_TNIL, ITYPE, pred2 // End of hash chain: key not found, nil result.
        | ct ctpr1, pred2
        |>
        |<
        | addd 0, PC, 0x4, PC, ~pred1
        | shrd 3, CARG3, 0xd, RD, ~pred1
        | shrd 4, CARG3, 0x15, RB, ~pred1
        | std 5, BASE, RA, ITYPE, ~pred1
        | ct ctpr1, pred1
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RB, 0x7f8, RB
        | shrd 5, CARG3, 0x5, RA
        |>
        |<
        | andd 3, RD, 0x7f8, RC
        | andd 4, RA, 0x7f8, RA
        | ct ctpr3
        |>
        |2:
        |<
        | disp ctpr1, ->vmeta_tgets
        | ldd 3, RB, TAB->metatable, TMP0   //  Check for __index if table value is nil
        | nop 2
        |>
        |<
        | ldbsm 3, TMP0, TAB->nomm, TMP1
        | cmpedb 4, TMP0, 0x0, pred0
        | nop 2
        |>
        | cmpandedbsm 4, TMP1, 1<<MM_index, pred1
        |<
        | pass pred0, p0                    // No metatable: done
        | pass pred1, p1                    // 'no __index' flag set: done.
        | landp ~p0, p1, p4
        | pass p4, pred0
        |>
        |<
        | addd 0, PC, 0x4, PC, ~pred0
        | shrd 3, CARG3, 0xd, RD, ~pred0
        | shrd 4, CARG3, 0x15, RB, ~pred0
        | std 5, BASE, RA, ITYPE, ~pred0
        | ct ctpr1, pred0
        |>
        |<
        | andd 3, RD, 0x7fff8, RD
        | shrd 4, CARG3, 0x5, RA
        | andd 5, RB, 0x7f8, RB
        |>
        |<
        | andd 3, RA, 0x7f8, RA
        | andd 4, RD, 0x7f8, RC
        | ct ctpr3
        |>
        break;

    case BC_TGETB:
        | ins_ABC // RA = dst*8, RB = table*8, RC = index*8
        | ldd 0, BASE, RB, RB
        | checktab RB, ->vmeta_tgetb
        | ldw 0, RB, TAB->asize, TMP0
        | sard 0, RC, 0x3, TMP1
        | cmpbdb 0, TMP1, TMP0, pred0
        | disp ctpr1, ->vmeta_tgetb
        | ct ctpr1, ~pred0
        | ldd 0, RB, TAB->array, TMP0
        | addd 0, RC, TMP0, RC
        | // Get array slot.
        | ldd 0, RC, 0x0, ITYPE
        | cmpedb 0, ITYPE, LJ_TNIL, pred0
        | disp ctpr1, >2
        | ct ctpr1, pred0
        |1:
        | std 2, BASE, RA, ITYPE
        | ins_next
        |2:                                 // Check for __index if table value is nil.
        | ldd 0, RB, TAB->metatable, TMP0
        | cmpedb 0, TMP0, 0x0, pred0
        | disp ctpr1, <1
        | ct ctpr1, pred0
        | ldb 0, TMP0, TAB->nomm, TMP1
        | cmpandedb 0, TMP1, 1<<MM_index, pred0
        | disp ctpr1, ->vmeta_tgetb         // 'no __index' flag NOT set: check.
        | ct ctpr1, pred0
        | disp ctpr1, <1
        | ct ctpr1
        break;

    case BC_TGETR:
        | ins_ABC // RA = dst*8, RB = table*8, RC = key*8
        | ldd 0, BASE, RB, RB
        | cleartp RB
        | ldd 0, BASE, RC, RC
        | fdtoistr 0, RC, RC
        | ldw 0, RB, TAB->asize, TMP0
        | cmpbsb 0, RC, TMP0, pred0
        | disp ctpr1, ->vmeta_tgetr         // Not in array part? Use fallback.
        | ct ctpr1, ~pred0
        | shls 0, RC, 0x3, RC
        | sxt 0, 0x2, RC, RC
        | ldd 0, RB, TAB->array, TMP0
        | addd 0, TMP0, RC, RC
        | // Get array slot.
        | ldd 0, RC, 0x0, ITYPE
        | std 2, BASE, RA, ITYPE
        | ins_next
        break;

    case BC_TSETV:
        | ins_ABC // RA = src*8, RB = table*8, RC = key*8
        | ldd 0, BASE, RB, RB
        | ldd 0, BASE, RC, RC
        | checktab RB, ->vmeta_tsetv
        | // Integer key?  Convert number to int and back and compare.
        | checknum RC, >5
        | fdtoistr 0, RC, TMP0
        | istofd 0, TMP0, TMP1
        | fcmpeqdb 0, RC, TMP1, pred0
        | disp ctpr1, ->vmeta_tsetv         // Generic numeric key? Use fallback.
        | ct ctpr1, ~pred0
        | sxt 0, 0x2, TMP0, RC
        | ldw 0, RB, TAB->asize, TMP0
        | cmpbsb 0, RC, TMP0, pred0
        | disp ctpr1, ->vmeta_tsetv
        | ct ctpr1, ~pred0
        | shld 0, RC, 0x3, RC
        | ldd 0, RB, TAB->array, TMP0
        | addd 0, RC, TMP0, RC
        | ldw 0, RC, 0x0, TMP0
        | cmpesb 0, TMP0, LJ_TNIL, pred0
        | disp ctpr1, >3                    // Previous value is nil?
        | ct ctpr1, pred0
        |1:
        | ldb 0, RB, TAB->marked, TMP0
        | cmpandedb 0, TMP0, LJ_GC_BLACK, pred0 // isblack(table)
        | disp ctpr1, >7
        | ct ctpr1, ~pred0
        |2:                                 // Set array slot
        | ldd 0, BASE, RA, RB
        | std 2, RC, 0x0, RB
        | ins_next
        |3: // Check for __newindex if previous value is nil.
        | ldd 0, RB, TAB->metatable, TMP1
        | cmpedb 0, TMP1, 0x0, pred0
        | disp ctpr1, <1
        | ct ctpr1, pred0
        | ldb 0, TMP1, TAB->nomm, TMP0
        | cmpandedb 0, TMP0, 1<<MM_newindex, pred0
        | disp ctpr1, ->vmeta_tsetv         // 'no __newindex' flag NOT set: check.
        | ct ctpr1, pred0
        | disp ctpr1, <1
        | ct ctpr1
        |5: // String key?
        | cmpesb 0, ITYPE, LJ_TSTR, pred0
        | disp ctpr1, ->vmeta_tsetv
        | ct ctpr1, ~pred0
        | cleartp RC
        | disp ctpr1, ->BC_TSETS_Z
        | ct ctpr1
        |7: // Possible table write barrier for the value. Skip valiswhite check.
        | barrierback RB, TMP1, TMP0
        | disp ctpr1, <2
        | ct ctpr1
        break;

    case BC_TSETS:
        | ins_ABC // RA = src*8, RB = table*8, RC = str_const*8 (~)
        | ldd 0, BASE, RB, RB
        | subd 0, KBASE, RC, TMP0
        | ldd 0, TMP0, 0xfffffff8, RC
        | checktab RB, ->vmeta_tsets
        |->BC_TSETS_Z:
        | // RB = GCtab *, RC = GCstr *
        | ldw 0, RB, TAB->hmask, TMP0
        | ldw 0, RC, STR->sid, TMP1
        | andd 0, TMP0, TMP1, TMP1             // idx = str->sid & tab->hmask
        | smulx 0, TMP1, #NODE, TMP0
        | addd 0, 0x0, 0x0, TMP1
        | stb 2, RB, TAB->nomm, TMP1           // Clear metamethod cache.
        | ldd 0, RB, TAB->node, TMP1
        | addd 0, TMP1, TMP0, TMP0
        | settp ITYPE, RC, LJ_TSTR
        |1:
        | ldd 0, TMP0, NODE->key, TMP1
        | cmpedb 0, TMP1, ITYPE, pred0
        | disp ctpr1, >5
        | ct ctpr1, ~pred0
        | // Ok, key found. Assumes: offsetof(Node, val) == 0
        | ldd 0, TMP0, 0x0, TMP1
        | cmpedb 0, TMP1, LJ_TNIL, pred0
        | disp ctpr1, >4                    // Previous value is nil?
        | ct ctpr1, pred0
        |2:
        | ldb 0, RB, TAB->marked, TMP1
        | cmpandedb 0, TMP1, LJ_GC_BLACK, pred0
        | disp ctpr1, >7                    // isblack(table)
        | ct ctpr1, ~pred0
        |3:                                 // Set node value.
        | ldd 0, BASE, RA, ITYPE
        | std 2, TMP0, 0x0, ITYPE
        | ins_next
        |4:                                 // Check for __newindex if previous value is nil.
        | ldd 0, RB, TAB->metatable, ITYPE
        | cmpedb 0, ITYPE, 0x0, pred0
        | disp ctpr1, <2
        | ct ctpr1, pred0
        | ldb 0, ITYPE, TAB->nomm, TMP1
        | cmpandedb 0, TMP1, 1<<MM_newindex, pred0
        | disp ctpr1, ->vmeta_tsets         // 'no __newindex' flag NOT set: check.
        | ct ctpr1, pred0
        | disp ctpr1, <2
        | ct ctpr1
        |5:                                 // Follow hash chain.
        | ldd 0, TMP0, NODE->next, TMP0
        | cmpedb 0, TMP0, 0x0, pred0
        | disp ctpr1, <1
        | ct ctpr1, ~pred0
        | // End of hash chain: key not found, add a new one.
        | // But check for __newindex first.
        | ldd 0, RB, TAB->metatable, TMP0
        | cmpedb 0, TMP0, 0x0, pred0
        | disp ctpr1, >6                    // No metatable: continue.
        | ct ctpr1, pred0
        | ldb 0, TMP0, TAB->nomm, TMP1
        | cmpandedb 0, TMP1, 1<<MM_newindex, pred0
        | disp ctpr1, ->vmeta_tsets         // 'no __newindex' flag NOT set: check.
        | ct ctpr1, pred0
        |6:
        | ldd 0, STACK, SAVE_L, CARG1
        | std 2, CARG1, L->base, BASE
        | addd 0, RB, 0x0, CARG2
        | addd 0, DISPATCH, DISPATCH_GL(tmptv), CARG3
        | std 2, CARG3, 0x0, ITYPE
        | std 2, STACK, SAVE_PC, PC
        | disp ctpr1, extern lj_tab_newkey  // (lua_State *L, GCtab *t, TValue *k)
        | call ctpr1, wbs = 0x8
        | // Handles write barrier for the new key. TValue * returned.
        | ldd 0, STACK, SAVE_L, TMP1
        | ldd 0, TMP1, L->base, BASE
        | addd 0, CRET1, 0x0, TMP0
        | ldb 0, PC, PC_RA, RA
        | shld 0, RA, 0x3, RA
        | disp ctpr1, <2                    // Must check write barrier for value.
        | ct ctpr1
        |7:                                 // Possible table write barrier for the value. Skip valiswhite check.
        | barrierback RB, ITYPE, TMP1
        | disp ctpr1, <3
        | ct ctpr1
        break;

    case BC_TSETB:
        | ins_ABC // RA = src*8, RB = table*8, RC = byte_literal*8
        | ldd 0, BASE, RB, RB
        | checktab RB, ->vmeta_tsetb
        | ldw 0, RB, TAB->asize, TMP0
        | shld 0, TMP0, 0x3, TMP0
        | cmpbdb 0, RC, TMP0, pred0
        | disp ctpr1, ->vmeta_tsetb
        | ct ctpr1, ~pred0
        | ldd 0, RB, TAB->array, TMP0
        | addd 0, RC, TMP0, RC
        | ldd 0, RC, 0x0, TMP0
        | cmpedb 0, TMP0, LJ_TNIL, pred0
        | disp ctpr1, >3                    // Previous value is nil?
        | ct ctpr1, pred0
        |1:
        | ldb 0, RB, TAB->marked, TMP0
        | cmpandedb 0, TMP0, LJ_GC_BLACK, pred0
        | disp ctpr1, >7                    // isblack(table)
        | ct ctpr1, ~pred0
        |2: // Set array slot.
        | ldd 0, BASE, RA, ITYPE
        | std 2, RC, 0x0, ITYPE
        | ins_next
        |3: // Check for __newindex if previous value is nil.
        | ldd 0, RB, TAB->metatable, TMP1
        | cmpedb 0, TMP1, 0x0, pred0
        | disp ctpr1, <1
        | ct ctpr1, pred0
        | ldb 0, TMP1, TAB->nomm, TMP0
        | cmpandedb 0, TMP0, 1<<MM_newindex, pred0
        | disp ctpr1, ->vmeta_tsetb         // 'no __newindex' flag NOT set: check.
        | ct ctpr1, pred0
        | disp ctpr1, <1
        | ct ctpr1
        |7: // Possible table write barrier for the value. Skip valiswhite check.
        | barrierback RB, TMP1, TMP0
        | disp ctpr1, <2
        | ct ctpr1
        break;

    case BC_TSETR:
        | ins_ABC // RA = src*8, RB = table*8, RC = key*8
        | ldd 0, BASE, RB, RB
        | cleartp RB
        | ldd 0, BASE, RC, RC
        | fdtoistr 0, RC, RC
        | ldb 0, RB, TAB->marked, TMP0
        | cmpandedb 0, TMP0, LJ_GC_BLACK, pred0
        | disp ctpr1, >7
        | ct ctpr1, ~pred0
        |2:
        | ldw 0, RB, TAB->asize, TMP0
        | cmpbsb 0, RC, TMP0, pred0
        | disp ctpr1, ->vmeta_tsetr
        | ct ctpr1, ~pred0
        | shls 0, RC, 0x3, RC
        | sxt 0, 0x2, RC, RC
        | ldd 0, RB, TAB->array, TMP0
        | addd 0, TMP0, RC, RC
        | // Set array slot.
        | ldd 0, BASE, RA, ITYPE
        | std 2, RC, 0x0, ITYPE
        | ins_next
        |7: // Possible table write barrier for the value. Skip valiswhite check.
        | barrierback RB, TMP1, TMP0
        | disp ctpr1, <2
        | ct ctpr1
        break;

    case BC_TSETM:
        | ins_AD // RA = base*8 (table at base-1), RD = num_const*8 (start_index)
        |1:
        | ldw 0, KBASE, RD, TMP1               // Integer constant is in lo-word.
        | shld 0, TMP1, 0x3, TMP1
        | addd 0, BASE, RA, RA
        | ldd 0, RA, 0xfffffff8, RB            // Guaranteed to be a table.
        | cleartp RB
        | ldb 0, RB, TAB->marked, TMP0
        | cmpandedb 0, TMP0, LJ_GC_BLACK, pred0
        | disp ctpr1, >7                    // isblack(table)
        | ct ctpr1, ~pred0
        |2:
        | ldw 0, STACK, MULTRES, RD
        | subd 0, RD, 0x8, RD
        | cmpedb 0, RD, 0x0, pred0
        | disp ctpr1, >4                    // Nothing to copy?
        | ct ctpr1, pred0
        | addd 0, RD, TMP1, RD                 // Compute needed size.
        | ldw 0, RB, TAB->asize, TMP0
        | shld 0, TMP0, 0x3, TMP0
        | cmpbedb 0, RD, TMP0, pred0
        | disp ctpr1, >5                    // Doesn't fit into array part?
        | ct ctpr1, ~pred0
        | subd 0, RD, TMP1, RD
        | ldd 0, RB, TAB->array, TMP0
        | addd 0, TMP1, TMP0, TMP1
        |3: // Copy result slots to table.
        | ldd 0, RA, 0x0, RB
        | addd 0, RA, 0x8, RA
        | std 2, TMP1, 0x0, RB
        | addd 0, TMP1, 0x8, TMP1
        | subd 0, RD, 0x8, RD
        | cmpedb 0, RD, 0x0, pred0
        | disp ctpr1, <3
        | ct ctpr1, ~pred0
        |4:
        | ins_next
        |5: // Need to resize array part.
        | ldd 0, STACK, SAVE_L, CARG1
        | std 2, CARG1, L->base, BASE
        | addd 0, RB, 0x0, CARG2
        | addd 0, RD, 0x0, CARG3
        | shrd 0, CARG3, 0x3, CARG3
        | addd 0, CARG1, 0x0, RB
        | std 2, STACK, SAVE_PC, PC
        | disp ctpr1, extern lj_tab_reasize // (lua_State *L, GCtab *t, int nasize)
        | call ctpr1, wbs = 0x8
        | ldd 0, RB, L->base, BASE
        | ldb 0, PC, PC_RA, RA                 // Restore RA.
        | shld 0, RA, 0x3, RA
        | ldh 0, PC, PC_RD, RD                 // Restore RD.
        | shld 0, RD, 0x3, RD
        | disp ctpr1, <1
        | ct ctpr1                          // Retry.
        |7: // Possible table write barrier for any value. Skip valiswhite check.
        | barrierback RB, RD, TMP0
        | disp ctpr1, <2
        | ct ctpr1
        break;

    /* -- Calls and vararg handling ----------------------------------------- */

    case BC_CALL: case BC_CALLM:
        | // ins_A_C  RA = base*8, (RB = (nresults+1)*8,) RD = (nargs+1)*8 | extra_nargs*8
        |<
        | ldw 3, STACK, MULTRES, TMP0
        | addd 4, RA, 0x10, RA
        | ldd 5, BASE, RA, RB
        | disp ctpr1, ->vmeta_call
        | nop 1
        |>
        | andd 4, RD, 0x7f8, RD
        if (op == BC_CALLM) {
          |<
          | sard 3, RB, 0x2f, ITYPE
          | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
          | addd 5, RD, TMP0, RD
          |>
        } else {
          |<
          | sard 3, RB, 0x2f, ITYPE
          | andd 4, RB, U64x(0x00007fff,0xffffffff), RB
          |>
        }
        |<
        | cmpesb 3, ITYPE, LJ_TFUNC, pred0
        | addd 4, BASE, RA, CARG1
        | lddsm 5, RB, LFUNC->pc, CARG2
        | nop 1
        |>
        |<
        | addd 3, BASE, RA, BASE, pred0
        | addd 4, BASE, RA, RA, ~pred0
        |>
        |<
        | ldw 3, CARG2, 0x0, RA, pred0
        | addd 4, CARG2, 0x4, PC, pred0
        | std 5, CARG1, 0xfffffff8, PC, pred0
        | nop 1
        |>
        | ct ctpr1, ~pred0
        |<
        | andd 3, RA, 0xff, TMP0
        | shrd 4, RA, 0x5, RA
        |>
        |<
        | andd 3, RA, 0x7f8, RA
        | shld 4, TMP0, 0x3, TMP0                      // jmp to [DISPATCH+OP*8]
        |>
        |<
        | ldd 3, TMP0, DISPATCH, TMP0
        | nop 2
        |>
        | movtd 0, TMP0, ctpr1
        | ct ctpr1
        break;

    case BC_CALLMT:
        | ins_AD // RA = base*8, RD = extra_nargs*8
        | ldd 0, STACK, MULTRES, TMP0
        | addd 0, RD, TMP0, RD
        | // Fall through. Assumes BC_CALLT follows and ins AD is a no-op.
        break;

    case BC_CALLT:
        | ins_AD // RA = base*8, RD = (nargs+1)*8
        | addd 0, BASE, RA, RA
        | addd 0, RA, 0x10, RA
        | addd 0, BASE, 0x0, KBASE             // Use KBASE for move + vmeta_call hint.
        | ldd 0, RA, 0xfffffff0, RB
        | checktp_nc RB, LJ_TFUNC, ->vmeta_call
        |->BC_CALLT_Z:
        | ldd 0, BASE, 0xfffffff8, PC
        | cmpandedb 0, PC, FRAME_TYPE, pred0
        | disp ctpr1, >7
        | ct ctpr1, ~pred0
        |1:
        | std 2, BASE, 0xfffffff0, RB          // Copy func+tag down, reloaded below.
        | stw 2, STACK, MULTRES, RD
        | subd 0, RD, 0x8, RD
        | cmpedb 0, RD, 0x0, pred0
        | disp ctpr1, >3
        | ct ctpr1, pred0
        |2: // Move args down.
        | ldd 0, RA, 0x0, RB
        | addd 0, RA, 0x8, RA
        | std 2, KBASE, 0x0, RB
        | addd 0, KBASE, 0x8, KBASE
        | subd 0, RD, 0x8, RD
        | cmpedb 0, RD, 0x0, pred0
        | disp ctpr1, <2
        | ct ctpr1, ~pred0
        | ldd 0, BASE, 0xfffffff0, RB
        |3:
        | cleartp RB
        | ldw 0, STACK, MULTRES, RD
        | ldb 0, RB, LFUNC->ffid, TMP0
        | cmpbedb 0, TMP0, 0x1, pred0          // (> FF_C) Calling a fast function?
        | disp ctpr1, >5
        | ct ctpr1, ~pred0
        |4:
        | ins_callt
        |5: // Tailcall to a fast function.
        | cmpandedb 0, PC, FRAME_TYPE, pred0
        | disp ctpr1, <4
        | ct ctpr1, ~pred0
        | ldb 0, PC, PC_RA, RA
        | shld 0, RA, 0x3, RA
        | subd 0, BASE, RA, TMP0
        | ldd 0, TMP0, 0xffffffe0, KBASE       // Need to prepare KBASE.
        | cleartp KBASE
        | ldd 0, KBASE, LFUNC->pc, KBASE
        | ldd 0, KBASE, PC2PROTO(k), KBASE
        | disp ctpr1, <4
        | ct ctpr1
        |7: // Tailcall from a vararg function.
        | subd 0, PC, FRAME_VARG, PC
        | cmpandedb 0, PC, FRAME_TYPEP, pred0
        | disp ctpr1, >8                    // Vararg frame below?
        | ct ctpr1, ~pred0
        | subd 0, BASE, PC, BASE               // Need to relocate BASE/KBASE down.
        | addd 0, BASE, 0x0, KBASE
        | ldd 0, BASE, 0xfffffff8, PC
        | disp ctpr1, <1
        | ct ctpr1
        |8:
        | addd 0, PC, FRAME_VARG, PC
        | disp ctpr1, <1
        | ct ctpr1
        break;

    case BC_ITERC:
        | ins_A // RA = base*8, (RB = nresults+1)*8, RD=(nargs+1)*8 (2+1)*8
        | addd 0, BASE, RA, RA                 // fb = base+2
        | addd 0, RA, 0x10, RA
        | ldd 0, RA, 0xffffffe0, RB            // Copy state. fb[0] = fb[-4].
        | ldd 0, RA, 0xffffffe8, RC            // Copy control var. fb[1] = fb[-3].
        | std 2, RA, 0x0, RB
        | std 2, RA, 0x8, RC
        | ldd 0, RA, 0xffffffd8, RB            // Copy callable. fb[-2] = fb[-5]
        | std 2, RA, 0xfffffff0, RB
        | addd 0, 0x0, 0x18, RD                // Handle like a regular 2-arg call.
        | checkfunc RB, ->vmeta_call
        | addd 0, RA, 0x0, BASE
        | ins_call
        break;

    case BC_ITERN:
        | ins_A // RA = base*8, (RB = (nresults+1)*8, RC = (nargs+1)*8 (2+1)*8)
        | addd 0, BASE, RA, TMP0
        | ldd 0, TMP0, 0xfffffff0, RB
        | cleartp RB
        | ldw 0, TMP0, 0xfffffff8, RC          // Get index from control var.
        | ldw 0, RB, TAB->asize, TMP1
        | addd 0, PC, 0x4, PC
        | ldd 0, RB, TAB->array, ITYPE
        |1: // Traverse array part.
        | cmpbsb 0, RC, TMP1, pred0
        | disp ctpr1, >5                    // Index points after array part?
        | ct ctpr1, ~pred0
        | shls 0, RC, 0x3, TMP0
        | ldd 0, ITYPE, TMP0, TMP0
        | cmpedb 0, TMP0, LJ_TNIL, pred0
        | disp ctpr1, >4
        | ct ctpr1, pred0
        | // Copy array slot to returned value.
        | addd 0, TMP0, 0x0, RB
        | addd 0, BASE, RA, TMP0
        | std 2, TMP0, 0x8, RB
        | // Return array index as a numeric key
        | istofd 0, RC, TMP1
        | std 2, TMP0, 0x0, TMP1
        | adds 0, RC, 0x1, RC
        | stw 2, TMP0, 0xfffffff8, RC          // Update control var.
        |2:
        | ldh 0, PC, PC_RD, RD                 // Get target from ITERL.
        | branchPC RD
        |3:
        | ins_next
        |4: // Skip holes in array part.
        | adds 0, RC, 0x1, RC
        | disp ctpr1, <1
        | ct ctpr1
        |5: // Traverse hash part.
        | subs 0, RC, TMP1, RC
        |6:
        | ldw 0, RB, TAB->hmask, TMP0
        | cmpbesb 0, RC, TMP0, pred0
        | disp ctpr1, <3                    // End of iteration? Branch to ITERL+1.
        | ct ctpr1, ~pred0
        | smulx 0, RC, #NODE, ITYPE
        | ldd 0, RB, TAB->node, TMP0
        | addd 0, ITYPE, TMP0, ITYPE
        | ldd 0, ITYPE, NODE->val, TMP0
        | cmpedb 0, TMP0, LJ_TNIL, pred0
        | disp ctpr1, >7
        | ct ctpr1, pred0
        | adds 0, RC, TMP1, TMP1
        | adds 0, TMP1, 0x1, TMP1
        | // Copy key and value from hash slot.
        | ldd 0, ITYPE, NODE->key, RB
        | ldd 0, ITYPE, NODE->val, RC
        | addd 0, BASE, RA, TMP0
        | std 2, TMP0, 0x0, RB
        | std 2, TMP0, 0x8, RC
        | stw 2, TMP0, 0xfffffff8, TMP1
        | disp ctpr1, <2
        | ct ctpr1
        |7: // Skip holes in hash part.
        | adds 0, RC, 0x1, RC
        | disp ctpr1, <6
        | ct ctpr1
        break;

    case BC_ISNEXT:
        | ins_AD // RA = base*8, RD = target*8 (points to ITERN)
        | shrd 0, RD, 0x3, RD
        | addd 0, BASE, RA, TMP0
        | ldd 0, TMP0, 0xffffffe8, RB
        | checkfunc RB, >5
        | ldd 0, TMP0, 0xfffffff0, TMP1
        | checktptp TMP1, LJ_TTAB, >5
        | ldd 0, TMP0, 0xffffffe8, TMP1
        | cmpedb 0, TMP1, LJ_TNIL, pred0
        | disp ctpr1, >5
        | ct ctpr1, ~pred0
        | ldb 0, RB, CFUNC->ffid, TMP1
        | cmpedb 0, TMP1, FF_next_N, pred0
        | disp ctpr1, >5
        | ct ctpr1, ~pred0
        | branchPC RD
        | addd 0, 0x0, U64x(0xfffe7fff,0x00000000), TMP1
        | std 2, TMP0, 0xfffffff8, TMP1        // Initialize control var.
        |1:
        | ins_next
        |5: // Despecialize bytecode if any of the checks fail.
        | addd 0, 0x0, BC_JMP, TMP1
        | stb 2, PC, PC_OP, TMP1
        | branchPC RD
        | addd 0, 0x0, BC_ITERC, TMP1
        | stb 2, PC, 0x0, TMP1
        | disp ctpr1, <1
        | ct ctpr1
        break;

    case BC_VARG:
        | ins_ABC // RA = base*8, RB = (nresults+1)*8, RC = numparams*8
        | addd 0, BASE, RC, TMP1
        | addd 0, TMP1, FRAME_VARG+0x10, TMP1
        | addd 0, BASE, RA, RA
        | ldd 0, BASE, 0xfffffff8, TMP0
        | subd 0, TMP1, TMP0, TMP1
        | // Note: TMP1 may now be even _above_ BASE if nargs was < numparams.
        | cmpedb 0, RB, 0x0, pred0
        | disp ctpr1, >5                    // Copy all varargs?
        | ct ctpr1, pred0
        | addd 0, RA, RB, TMP0
        | subd 0, TMP0, 0x8, RB
        | cmpbdb 0, TMP1, BASE, pred0
        | disp ctpr1, >2                    // No vrarg slots?
        | ct ctpr1, ~pred0
        |1: // Copy vararg slots to destination slots.
        | ldd 0, TMP1, 0xfffffff0, RC
        | addd 0, TMP1, 0x8, TMP1
        | std 2, RA, 0x0, RC
        | addd 0, RA, 0x8, RA
        | cmpbdb 0, RA, RB, pred0
        | disp ctpr1, >3                    // All destination slots filled?
        | ct ctpr1, ~pred0
        | cmpbdb 0, TMP1, BASE, pred0
        | disp ctpr1, <1                    // No more vararg slots?
        | ct ctpr1, pred0
        |2: // Fill up remainder with nil.
        | addd 0, 0x0, LJ_TNIL, TMP0
        | std 2, RA, 0x0, TMP0
        | addd 0, RA, 0x8, RA
        | cmpbdb 0, RA, RB, pred0
        | disp ctpr1, <2
        | ct ctpr1, pred0
        |3:
        | ins_next
        |5: // Copy all varargs.
        | addd 0, 0x0, (0+1)*8, TMP0
        | stw 2, STACK, MULTRES, TMP0
        | addd 0, BASE, 0x0, RC
        | cmpbedb 0, RC, TMP1, pred0
        | subd 0, RC, TMP1, RC
        | disp ctpr1, <3                    // No vararg slots?
        | ct ctpr1, pred0
        | addd 0, RC, 0x8, RB
        | stw 2, STACK, MULTRES, RB            // (#varargs+1)*8
        | ldd 0, STACK, SAVE_L, RB
        | addd 0, RC, RA, RC
        | ldd 0, RB, L->maxstack, TMP0
        | cmpbedb 0, RC, TMP0, pred0
        | disp ctpr1, >7                    // Need to grow stack?
        | ct ctpr1, ~pred0
        |6: // Copy all vararg slots.
        | ldd 0, TMP1, 0xfffffff0, RC
        | addd 0, TMP1, 0x8, TMP1
        | std 2, RA, 0x0, RC
        | addd 0, RA, 0x8, RA
        | cmpbdb 0, TMP1, BASE, pred0
        | disp ctpr1, <6                    // No more vararg slots?
        | ct ctpr1, pred0
        | disp ctpr1, <3
        | ct ctpr1
        |7: // Grow stack for varargs.
        | std 2, RB, L->base, BASE
        | std 2, RB, L->top, RA
        | std 2, STACK, SAVE_PC, PC
        | subd 0, TMP1, BASE, TMP1             // Need delta, because BASE may change.
        | ldw 0, STACK, MULTRES, CARG2
        | subd 0, CARG2, 0x8, CARG2
        | shrd 0, CARG2, 0x3, CARG2
        | addd 0, RB, 0x0, CARG1
        | disp ctpr1, extern lj_state_growstack // (lua_State *L, int n)
        | call ctpr1, wbs = 0x8
        | ldd 0, RB, L->base, BASE
        | ldd 0, RB, L->top, RA
        | addd 0, TMP1, BASE, TMP1
        | disp ctpr1, <6
        | ct ctpr1
        break;

    /* -- Returns ----------------------------------------------------------- */

    case BC_RETM:
        | ins_AD // RA = results*8, RD = extra_nresults*8
        |<
        | ldd 0, STACK, MULTRES, TMP0
        | nop 2
        |>
        | addd 3, RD, TMP0, RD                 // MULTRES >=8, so RD >= 8
        | // Fall through. Assumes BC_RET follows and ins_AD is a no-op.
        break;

    case BC_RET:
        | // ins_AD RA = results*8, RD = (nresults+1)*8
        |1:
        |<
        | ldd 0, BASE, 0xfffffff8, PC
        | disp ctpr3, ->vm_return
        | nop 2
        |>
        |<
        | stw 2, STACK, MULTRES, RD            // Save (nresults+1)*8.
        | disp ctpr1, <1
        |>
        |<
        | cmpandedb 1, PC, FRAME_TYPE, pred0   // Check frame type marker.
        | subdsm 3, PC, FRAME_VARG, RB
        |>
        |<
        | cmpandedbsm 0, RB, FRAME_TYPEP, pred1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred1
        |>
        | ct ctpr3, pred1
        |<
        | subd 3, BASE, RB, BASE, ~pred0    // Return from vararg function: relocate BASE down and RA up.
        | addd 4, RA, RB, RA, ~pred0
        | ct ctpr1, ~pred0
        |>
        |->BC_RET_Z:
        | // BASE = base, RA = resultptr, RD = (nresults+1)*8, PC = return
        | addd 0, BASE, 0x0, KBASE             // Use KBASE for result move.
        | subd 0, RD, 0x8, RD
        | cmpedb 0, RD, 0x0, pred0
        | disp ctpr1, >3
        | ct ctpr1, pred0
        |2:                                 // Move results down.
        | ldd 0, KBASE, RA, RB
        | std 2, KBASE, 0xfffffff0, RB
        | addd 0, KBASE, 0x8, KBASE
        | subd 0, RD, 0x8, RD
        | cmpedb 0, RD, 0x0, pred0
        | disp ctpr1, <2
        | ct ctpr1, ~pred0
        |3:
        | ldw 0, STACK, MULTRES, RD          // Note: MULTRES may be >255.
        | ldb 0, PC, PC_RB, RB
        | shld 0, RB, 0x3, RB
        |5:
        | cmpbedb 0, RB, RD, pred0           // More results expected?
        | disp ctpr1, >6
        | ct ctpr1, ~pred0
        | ldb 0, PC, PC_RA, RA
        | shld 0, RA, 0x3, RA
        | subd 0, BASE, RA, BASE
        | subd 0, BASE, 0x10, BASE             // base = base - (RA+2)*8
        | ldd 0, BASE, 0xfffffff0, KBASE
        | cleartp KBASE
        | ldd 0, KBASE, LFUNC->pc, KBASE
        | ldd 0, KBASE, PC2PROTO(k), KBASE
        | ins_next
        |6:                                 // Fill up results with nil.
        | addd 0, 0x0, LJ_TNIL, TMP0
        | std 2, KBASE, 0xfffffff0, TMP0     // Note: relies on shifted base.
        | addd 0, RD, 0x8, RD
        | disp ctpr1, <5
        | ct ctpr1
        break;


    case BC_RET0: case BC_RET1:
        | // ins_AD RA = results*8, RD = (nresults+1)*8
        |1:
        |<
        | ldd 0, BASE, 0xfffffff8, PC
        | disp ctpr3, ->vm_return
        | nop 2
        |>
        |<
        | stw 2, STACK, MULTRES, RD            // Save (nresults+1)*8.
        | disp ctpr1, <1
        |>
        |<
        | ldbsm 0, PC, 0x0, CARG2
        | cmpandedb 1, PC, FRAME_TYPE, pred0   // Check frame type marker.
        | ldwsm 3, PC, 0x0, CARG1
        | subdsm 4, PC, FRAME_VARG, RB
        | disp ctpr2, >3
        |>
        |<
        | cmpandedbsm 3, RB, FRAME_TYPEP, pred1
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp ~p0, ~p1, p4
        | pass p4, pred1
        |>
        | ct ctpr3, pred1
        if (op == BC_RET1) {
          |<
          | shld 2, CARG2, 0x3, CARG2, pred0
          | subd 3, BASE, RB, BASE, ~pred0    // Return from vararg function: relocate BASE down and RA up.
          | addd 4, RA, RB, RA, ~pred0
          | ldd 5, BASE, RA, RB, pred0
          | ct ctpr1, ~pred0
          |>
        } else {
          |<
          | shld 2, CARG2, 0x3, CARG2, pred0
          | subd 3, BASE, RB, BASE, ~pred0    // Return from vararg function: relocate BASE down and RA up.
          | ct ctpr1, ~pred0
          |>
        }
        if (op == BC_RET1) {
          | std 5, BASE, 0xfffffff0, RB
        }
        |2:
        |<
        | ldb 0, PC, PC_RB, TMP0
        | ldb 3, PC, PC_RA, RA
        | disp ctpr1, <2
        | nop 1
        |>
        | andd 4, RD, 0x7f8, TMP1
        | shld 0, TMP0, 0x3, TMP0
        | cmpbedb 0, TMP0, TMP1, pred0
        |<
        | ldd 2, CARG2, DISPATCH, CARG2, pred0
        | shld 3, RA, 0x3, RA, pred0
        | subd 4, BASE, 0x10, BASE, pred0
        | ct ctpr2, ~pred0                  // More results expected?
        |>
        |<
        | addd 1, PC, 0x4, PC
        | subd 3, BASE, RA, BASE            // base = base - (RA+2)*8
        | shrd 4, CARG1, 0xd, RD
        | shrd 5, CARG1, 0x15, RB
        |>
        |<
        | ldd 3, BASE, 0xfffffff0, KBASE
        | shrd 4, CARG1, 0x5, RA
        | andd 5, RD, 0x7fff8, RD
        | nop 2
        |>
        |<
        | movtd 0, CARG2, ctpr1
        | andd 3, KBASE, U64x(0x00007fff,0xffffffff), KBASE
        |>
        |<
        | ldd 3, KBASE, LFUNC->pc, KBASE
        | andd 4, RB, 0x7f8, RB
        | nop 2
        |>
        | andd 5, RA, 0x7f8, RA
        |<
        | ldd 3, KBASE, PC2PROTO(k), KBASE
        | andd 4, RD, 0x7f8, RC
        | ct ctpr1
        |>
        |3:                                 // Fill up results with nil.
        |<
        | subd 3, BASE, 0x18, TMP0
        | addd 4, 0x0, LJ_TNIL, TMP1
        |>
        |<
        | addd 3, RD, 0x8, RD
        | std 5, TMP0, RD, TMP1
        | ct ctpr1
        |>
        break;

    /* -- Loops and branches ------------------------------------------------ */

    case BC_FORL:
        | // Fall through. Assumes BC_IFORL follows and ins_AJ is a no-op.
        break;

    case BC_JFORI: case BC_JFORL:
        | // Unsupported
        break;

    case BC_IFORL:
        | // ins_AJ RA = base*8, RD = target*8 (after end of loop or start of loop)
        |<
        | shrd 0, RD, 0x1, CARG2
        | subd 1, PC, BCBIAS_J*4, CARG3
        | addd 3, BASE, RA, RA
        |>
        |<
        | ldd 3, RA, 0x10, RB
        | ldd 5, RA, 0x0, TMP0
        | nop 2
        |>
        |<
        | faddd 3, TMP0, RB, TMP0
        | fcmpltdb 4, RB, 0x0, pred2
        | ldd 5, RA, 0x8, TMP1
        | nop 5
        |>
        |<
        | fcmpltdb 3, TMP1, TMP0, pred0
        | fcmpltdb 4, TMP0, TMP1, pred1     // Invert comparison if step is negative.
        | std 5, RA, 0x0, TMP0
        | nop 2
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | pass pred2, p2
        | landp ~p0, ~p2, p4
        | landp ~p1, p2, p5
        | landp ~p4, ~p5, p6
        | pass p6, pred0
        |>
        |<
        | addd 0, CARG3, CARG2, PC, ~pred0
        | std 5, RA, 0x18, TMP0
        |>
        |<
        | ldb 0, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | ldw 2, PC, 0x0, TMP0
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 0, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        break;

    case BC_FORI:
        | // ins_AJ RA = base*8, RD = target*8 (after end of loop or start of loop)
        |<
        | subd 2, PC, BCBIAS_J*4, CARG3
        | addd 3, BASE, RA, RA
        | addd 4, 0x0, 0x2f, CARG1
        | disp ctpr2, ->vmeta_for
        |>
        |<
        | shrd 1, RD, 0x1, CARG4
        | ldd 2, RA, 0x10, RB
        | ldd 3, RA, 0x0, TMP0
        | ldd 5, RA, 0x8, TMP1
        | nop 2
        |>
        |<
        | addd 1, CARG3, CARG4, CARG3
        | sard 2, RB, CARG1, ITYPE
        | sard 3, TMP0, CARG1, CARG1
        | sard 4, TMP1, CARG1, CARG2
        |>
        |<
        | cmplsb 0, ITYPE, LJ_TISNUM, pred3
        | cmpbsb 1, ITYPE, LJ_TISNUM, pred0
        | cmpbsb 3, CARG1, LJ_TISNUM, pred1
        | cmpbsb 4, CARG2, LJ_TISNUM, pred2
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | landp p0, p1, p4
        | pass p4, pred0
        | pass pred2, p2
        | landp p4, p2, p5
        | pass p5, pred2
        |>
        |<
        | fcmpltdb 3, TMP1, TMP0, pred0
        | fcmpltdb 4, TMP0, TMP1, pred1     // Invert comparison if step is negative.
        | nop 1
        |>
        |<
        | std 5, RA, 0x18, TMP0, pred2
        | ct ctpr2, ~pred2
        |>
        |<
        | pass pred0, p0
        | pass pred1, p1
        | pass pred3, p3
        | landp ~p0, ~p3, p4
        | landp ~p1, p3, p5
        | landp ~p4, ~p5, p6
        | pass p6, pred0
        |>
        | addd 0, CARG3, 0x0, PC, pred0
        |<
        | ldb 0, PC, 0x0, TMP1
        | addd 1, PC, 0x4, PC
        | ldw 2, PC, 0x0, TMP0
        | nop 2
        |>
        |<
        | shld 2, TMP1, 0x3, TMP1
        | shrd 3, TMP0, 0xd, RD
        | shrd 4, TMP0, 0x15, RB
        | shrd 5, TMP0, 0x5, RA
        |>
        |<
        | ldd 2, TMP1, DISPATCH, TMP1
        | andd 3, RD, 0x7fff8, RD
        | andd 4, RA, 0x7f8, RA
        | nop 2
        |>
        |<
        | movtd 0, TMP1, ctpr1
        | andd 3, RB, 0x7f8, RB
        | andd 4, RD, 0x7f8, RC
        |>
        | ct ctpr1
        break;

    case BC_ITERL:
        | // Fall through. Assumes BC_IITERL follows and ins_AJ is a no-op.
        break;

    case BC_JITERL:
        | // Unsupported
        break;

    case BC_IITERL:
        | ins_AJ // RA = base*8, RD = target*8
        | addd 0, BASE, RA, RA
        | ldd 0, RA, 0x0, RB
        | cmpedb 0, RB, LJ_TNIL, pred0
        | disp ctpr1, >1                    // Stop if iterator returned nil.
        | ct ctpr1, pred0
        | shrd 0, RD, 0x3, RD
        | branchPC RD                       // Otherwise save control var + branch.
        | std 2, RA, 0xfffffff8, RB
        |1:
        | ins_next
        break;

    case BC_LOOP:
        | ins_A // RA = base*8, RD = target*8 (loop extent)
        | // Note: RA/RD is only used by trace recorder to determine scope/extent
        | // This opcode does NOT jump, it's only purpose is to detect a hot loop.
        | //Fall through. Assumes BC_ILOOP follows and ins_A is a no-op.
        break;

    case BC_ILOOP:
        | ins_A // RA = base*8, RD = target*8 (loop extent)
        | ins_next
        break;

    case BC_JLOOP:
        | // Unsupported
        break;

    case BC_JMP:
        | ins_AJ // RA = unused, RD = target*8
        | shrd 0, RD, 0x3, RD
        | branchPC RD
        | ins_next
        break;

    /* -- Function headers -------------------------------------------------- */

    /*
    ** Reminder: A function may be called with func/args above L->maxstack,
    ** i.e. occupying EXTRA_STACK slots. And vmeta_call may add one extra slot,
    ** too. This means all FUNC* ops (including fast functions) must check
    ** for stack overflow _before_ adding more slots!
    */

    case BC_FUNCF:
    case BC_FUNCV: /* NYI: compiled vararg functions. */
        | // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow and ins_AD is a no-op.
        break;

    case BC_JFUNCF:
        | // Unsupported
        break;

    case BC_IFUNCF:
        | ins_AD // BASE = new_base*8, RA = framesize*8, RD = (nargs+1)*8
        | ldd 0, PC, PC2PROTO(k)-4, KBASE
        | ldd 0, STACK, SAVE_L, RB
        | addd 0, BASE, RA, RA                 // Top of frame.
        | ldd 0, RB, L->maxstack, TMP0
        | cmpbedb 0, RA, TMP0, pred0
        | disp ctpr1, ->vm_growstack_f
        | ct ctpr1, ~pred0
        | ldb 0, PC, PC2PROTO(numparams)-4, RA
        | shld 0, RA, 0x3, RA
        | cmpbedb 0, RD, RA, pred0
        | disp ctpr1, >3                    // Check for missing parameters.
        | ct ctpr1, pred0
        |2:
        | ins_next
        |3: // Clear missing parameters.
        | subd 0, RD, 0x8, TMP0
        | addd 0, 0x0, LJ_TNIL, TMP1
        | std 2, BASE, TMP0, TMP1
        | addd 0, RD, 0x8, RD
        | cmpbedb 0, RD, RA, pred0
        | disp ctpr1, <3
        | ct ctpr1, pred0
        | disp ctpr1, <2
        | ct ctpr1
        break;

    case BC_JFUNCV:
        | // Unsupported
        break;

    case BC_IFUNCV:
        | ins_AD // BASE = new base, RA = framesize*8, RB = LFUNC (but we need tagged), RD = (nargs+1)*8
        | addd 0, RD, FRAME_VARG+0x8, RB
        | addd 0, RD, BASE, RD
        | addd 0, RD, 0x8, RD
        | ldd 0, BASE, 0xfffffff0, KBASE
        | std 2, RD, 0xfffffff8, RB            // Store delta + FRAME_VARG
        | std 2, RD, 0xfffffff0, KBASE         // Store copy of LFUNC
        | ldd 0, STACK, SAVE_L, RB
        | addd 0, RA, RD, RA
        | ldd 0, RB, L->maxstack, TMP0
        | cmpbedb 0, RA, TMP0, pred0
        | disp ctpr1, ->vm_growstack_v      // Need to grow stack.
        | ct ctpr1, ~pred0
        | addd 0, BASE, 0x0, RA
        | addd 0, RD, 0x0, BASE
        | ldb 0, PC, PC2PROTO(numparams)-4, RB
        | cmpedb 0, RB, 0x0, pred0
        | disp ctpr1, >2
        | ct ctpr1, pred0
        | addd 0, RA, 0x8, RA
        |1:                                 // Copy fixarg slots up to new frame.
        | addd 0, RA, 0x8, RA
        | cmpbdb 0, RA, BASE, pred0
        | disp ctpr1, >3                    // Less args than parameters?
        | ct ctpr1, ~pred0
        | ldd 0, RA, 0xfffffff0, KBASE
        | std 2, RD, 0x0, KBASE
        | addd 0, RD, 0x8, RD
        | addd 0, 0x0, LJ_TNIL, TMP1
        | std 2, RA, 0xfffffff0, TMP1          // Clear old fixarg slot (help the GC).
        | subd 0, RB, 0x1, RB
        | cmpedb 0, RB, 0x0, pred0
        | disp ctpr1, <1
        | ct ctpr1, ~pred0
        |2:
        | ldd 0, PC, PC2PROTO(k)-4, KBASE
        | ins_next
        |3:                                 // Clear missing parameters.
        | addd 0, 0x0, LJ_TNIL, TMP0
        | std 2, RD, 0x0, TMP0
        | addd 0, RD, 0x8, RD
        | subd 0, RB, 0x1, RB
        | cmpedb 0, RB, 0x0, pred0
        | disp ctpr1, <3
        | ct ctpr1, ~pred0
        | disp ctpr1, <2
        | ct ctpr1
        break;

    case BC_FUNCC: case BC_FUNCCW:
        | ins_AD // BASE = new base, RA = framesize*8, RD = (nargs+1)*8
        | ldd 0, BASE, 0xfffffff0, RB
        | cleartp RB
        | ldd 0, RB, CFUNC->f, KBASE
        | ldd 0, STACK, SAVE_L, RB
        | addd 0, BASE, RD, RD
        | subd 0, RD, 0x8, RD
        | std 2, RB, L->base, BASE
        | addd 0, RD, 8*LUA_MINSTACK, TMP0
        | ldd 0, RB, L->maxstack, TMP1
        | cmpbedb 0, TMP0, TMP1, pred0
        | std 2, RB, L->top, RD
        if (op == BC_FUNCC) {
          | addd 0, RB, 0x0, CARG1
        } else {
          | addd 0, KBASE, 0x0, CARG2
          | addd 0, RB, 0x0, CARG1
        }
        | disp ctpr1, ->vm_growstack_c      // Need to grow stack.
        | ct ctpr1, ~pred0
        | set_vmstate C
        if (op == BC_FUNCC) {
          | movtd 0, KBASE, ctpr1              // (lua_State *L)
        } else {
          | ldd 0, DISPATCH, DISPATCH_GL(wrapf), TMP0
          | movtd 0, TMP0, ctpr1               // (lua_State *L, lua_CFunction f)
        }
        | call ctpr1, wbs = 0x8
        | ldd 0, RB, L->base, BASE
        | std 2, DISPATCH, DISPATCH_GL(cur_L), RB
        | set_vmstate INTERP
        | shld 0, CRET1, 0x3, RD               // return nsresult
        | addd 0, BASE, RD, RA
        | ldd 0, RB, L->top, TMP0
        | subd 0, TMP0, RA, RA                 // RA = (L->top - (L->base+nresults))*8
        | ldd 0, BASE, 0xfffffff8, PC          // Fetch PC of caller
        | disp ctpr1, ->vm_returnc
        | ct ctpr1
        break;

    /* ---------------------------------------------------------------------- */
    default:
        fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
        exit(2);
        break;
    }
}

static int build_backend(BuildCtx *ctx)
{
    int op;
    dasm_growpc(Dst, BC__MAX);
    build_subroutines(ctx);
    |.code_op
    for (op = 0 ; op < BC__MAX; op++)
        build_ins(ctx, (BCOp)op, op);
    return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions */
static void emit_asm_debug(BuildCtx* ctx)
{
    int fcofs = (int)((uint8_t *)ctx->glob[GLOB_vm_ffi_call] - ctx->code);
    switch  (ctx->mode) {
    case BUILD_elfasm:
        fprintf(ctx->fp, "\t.section .debug_frame,\"\",@progbits\n");
        fprintf(ctx->fp,
        ".Lframe0:\n"
        "\t.long .LECIE0-.LSCIE0\n"
        ".LSCIE0:\n"
        "\t.long 0xffffffff\n"
        "\t.byte 0x1\n"
        "\t.string \"\"\n"
        "\t.uleb128 0x1\n"
        "\t.sleb128 -8\n"
        "\t.byte 0x8c\n"
        "\t.byte 0xc\n\t.uleb128 0x19\n\t.uleb128 0\n"
        "\t.byte 0x9\n\t.uleb128 0x8c\n\t.uleb128 0\n"
        "\t.align 8\n"
        ".LECIE0:\n\n");
        fprintf(ctx->fp,
        ".LSFDE0:\n"
        "\t.long .LEFDE0-.LASFDE0\n"
        ".LASFDE0:\n"
        "\t.long .Lframe0\n"
        "\t.quad .Lbegin\n"
        "\t.quad %d\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE0:\n\n", fcofs);
#if LJ_HASFFI
        fprintf(ctx->fp,
        ".LSFDE1:\n"
        "\t.long .LEFDE1-.LASFDE1\n"
        ".LASFDE1:\n"
        "\t.long .Lframe0\n"
        "\t.quad lj_vm_ffi_call\n"
        "\t.quad %d\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
#endif
#if !LJ_NO_UNWIND
        fprintf(ctx->fp, "\t.section .eh_frame,\"a\",@progbits\n");
        fprintf(ctx->fp,
        "\t.globl lj_err_unwind_dwarf\n"
        ".Lframe1:\n"
        "\t.long .LECIE1-.LSCIE1\n"
        ".LSCIE1:\n"
        "\t.long 0\n"
        "\t.byte 0x1\n"
        "\t.string \"zPR\"\n"
        "\t.uleb128 0x1\n"
        "\t.sleb128 -8\n"
        "\t.byte 0x8c\n"
        "\t.uleb128 0xa\n"
        "\t.byte 0\n"
        "\t.quad lj_err_unwind_dwarf\n"
        "\t.byte 0\n"
        "\t.byte 0xc\n\t.uleb128 0x19\n\t.uleb128 0\n"
        "\t.byte 0x9\n\t.uleb128 0x8c\n\t.uleb128 0\n"
        "\t.align 8\n"
        ".LECIE1:\n\n");
        fprintf(ctx->fp,
        ".LSFDE2:\n"
        "\t.long .LEFDE2-.LASFDE2\n"
        ".LASFDE2:\n"
        "\t.long .LASFDE2-.Lframe1\n"
        "\t.quad .Lbegin\n"
        "\t.quad %d\n"
        "\t.uleb128 0\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE2:\n\n", fcofs);
#if LJ_HASFFI
        fprintf(ctx->fp,
        ".Lframe2:\n"
        "\t.long .LECIE2-.LSCIE2\n"
        ".LSCIE2:\n"
        "\t.long 0\n"
        "\t.byte 0x1\n"
        "\t.string \"zR\"\n"
        "\t.uleb128 0x1\n"
        "\t.sleb128 -8\n"
        "\t.byte 0x8c\n"
        "\t.uleb128 1\n"
        "\t.byte 0\n"
        "\t.byte 0xc\n\t.uleb128 0x19\n\t.uleb128 0\n"
        "\t.byte 0x9\n\t.uleb128 0x8c\n\t.uleb128 0\n"
        "\t.align 8\n"
        ".LECIE2:\n\n");
        fprintf(ctx->fp,
        ".LSFDE3:\n"
        "\t.long .LEFDE3-.LASFDE3\n"
        ".LASFDE3:\n"
        "\t.long .LASFDE3-.Lframe2\n"
        "\t.quad lj_vm_ffi_call\n"
        "\t.quad %d\n"
        "\t.uleb128 0\n"
        "\t.byte 0xd\n\t.uleb128 0x18\n"
        "\t.align 8\n"
        ".LEFDE3:\n\n", (int)ctx->codesz - fcofs);
#endif
#endif
        break;
    default:
        break;
    }
}
